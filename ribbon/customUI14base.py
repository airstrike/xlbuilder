#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Dec 17 11:13:05 2019 by generateDS.py version 2.35.7.
# Python 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 21:26:53) [MSC v.1916 32 bit (Intel)]
#
# Command line options:
#   ('-f', '')
#   ('-o', 'customUI14base.py')
#   ('-s', 'customUI14subs.py')
#   ('--super', 'customUI14base')
#   ('--root-element', 'CT_CustomUI|customUI')
#
# Command line arguments:
#   customUI14.xsd
#
# Command line:
#   C:\virtual\terra\Scripts\generateDS.py -f -o "customUI14base.py" -s "customUI14subs.py" --super="customUI14base" --root-element="CT_CustomUI|customUI" customUI14.xsd
#
# Current working directory (os.getcwd()):
#   ribbon
#

from six.moves import zip_longest
import os
import sys
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ImportError:
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ImportError:

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ImportError:
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer valuess')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return ('%0.10f' % input_data).rstrip('0')
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class ST_BoxStyle(Enum):
    """Style of a box control. "horizontal" or "vertical"."""
    HORIZONTAL='horizontal'
    VERTICAL='vertical'


class ST_GalleryShowInRibbon(Enum):
    """Specifies the acceptable values for the gallery element's showInRibbon
    attribute."""
    FALSE='false'
    _0='0'


class ST_ItemSize(Enum):
    """Specifies the size of items in a menu; "normal" or "large"."""
    NORMAL='normal'
    LARGE='large'


class ST_Size(Enum):
    """Specifies the size of the button; "large" or "normal." """
    NORMAL='normal'
    LARGE='large'


class ST_TaskSizes(Enum):
    """Specifies the allowed sizes of task controls in taskGroups or
    taskFormGroups."""
    LARGE_MEDIUM_SMALL='largeMediumSmall'
    LARGE_MEDIUM='largeMedium'
    LARGE='large'
    MEDIUM_SMALL='mediumSmall'
    MEDIUM='medium'
    SMALL='small'


class CT_Command(GeneratedsSuper):
    """Specifies attribute overrides for all controls with specified ID.
    Setting a property with Command element is equivalent to setting
    same properties on all controls with same id in the ribbon, popup menus,
    status bar etc.
    For example
    <command idMso="Print" enabled="false">
    disables all instances of Print button in the application UI."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, onAction=None, enabled=None, getEnabled=None, idMso=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.onAction = _cast(None, onAction)
        self.onAction_nsprefix_ = None
        self.enabled = _cast(bool, enabled)
        self.enabled_nsprefix_ = None
        self.getEnabled = _cast(None, getEnabled)
        self.getEnabled_nsprefix_ = None
        self.idMso = _cast(None, idMso)
        self.idMso_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_Command)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_Command.subclass:
            return CT_Command.subclass(*args_, **kwargs_)
        else:
            return CT_Command(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_onAction(self):
        return self.onAction
    def set_onAction(self, onAction):
        self.onAction = onAction
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    def get_getEnabled(self):
        return self.getEnabled
    def set_getEnabled(self, getEnabled):
        self.getEnabled = getEnabled
    def get_idMso(self):
        return self.idMso
    def set_idMso(self, idMso):
        self.idMso = idMso
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_Command', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_Command')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_Command')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_Command', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_Command'):
        if self.onAction is not None and 'onAction' not in already_processed:
            already_processed.add('onAction')
            outfile.write(' onAction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.onAction), input_name='onAction')), ))
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            outfile.write(' enabled="%s"' % self.gds_format_boolean(self.enabled, input_name='enabled'))
        if self.getEnabled is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            outfile.write(' getEnabled=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getEnabled), input_name='getEnabled')), ))
        if self.idMso is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            outfile.write(' idMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idMso), input_name='idMso')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_Command', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('onAction', node)
        if value is not None and 'onAction' not in already_processed:
            already_processed.add('onAction')
            self.onAction = value
            self.validate_ST_Delegate(self.onAction)    # validate type ST_Delegate
        value = find_attr_value_('enabled', node)
        if value is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            if value in ('true', '1'):
                self.enabled = True
            elif value in ('false', '0'):
                self.enabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getEnabled', node)
        if value is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            self.getEnabled = value
            self.validate_ST_Delegate(self.getEnabled)    # validate type ST_Delegate
        value = find_attr_value_('idMso', node)
        if value is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            self.idMso = value
            self.validate_ST_ID(self.idMso)    # validate type ST_ID
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CT_Command


class CT_ControlBase(GeneratedsSuper):
    """Base control type.
    Doesn't define ID attributes.
    Abstract type, not to be used directly."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, enabled=None, getEnabled=None, label=None, getLabel=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, keytip=None, getKeytip=None, showLabel=None, getShowLabel=None, showImage=None, getShowImage=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.image = _cast(None, image)
        self.image_nsprefix_ = None
        self.imageMso = _cast(None, imageMso)
        self.imageMso_nsprefix_ = None
        self.getImage = _cast(None, getImage)
        self.getImage_nsprefix_ = None
        self.screentip = _cast(None, screentip)
        self.screentip_nsprefix_ = None
        self.getScreentip = _cast(None, getScreentip)
        self.getScreentip_nsprefix_ = None
        self.supertip = _cast(None, supertip)
        self.supertip_nsprefix_ = None
        self.getSupertip = _cast(None, getSupertip)
        self.getSupertip_nsprefix_ = None
        self.enabled = _cast(bool, enabled)
        self.enabled_nsprefix_ = None
        self.getEnabled = _cast(None, getEnabled)
        self.getEnabled_nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.getLabel = _cast(None, getLabel)
        self.getLabel_nsprefix_ = None
        self.insertAfterMso = _cast(None, insertAfterMso)
        self.insertAfterMso_nsprefix_ = None
        self.insertBeforeMso = _cast(None, insertBeforeMso)
        self.insertBeforeMso_nsprefix_ = None
        self.insertAfterQ = _cast(None, insertAfterQ)
        self.insertAfterQ_nsprefix_ = None
        self.insertBeforeQ = _cast(None, insertBeforeQ)
        self.insertBeforeQ_nsprefix_ = None
        self.visible = _cast(bool, visible)
        self.visible_nsprefix_ = None
        self.getVisible = _cast(None, getVisible)
        self.getVisible_nsprefix_ = None
        self.keytip = _cast(None, keytip)
        self.keytip_nsprefix_ = None
        self.getKeytip = _cast(None, getKeytip)
        self.getKeytip_nsprefix_ = None
        self.showLabel = _cast(bool, showLabel)
        self.showLabel_nsprefix_ = None
        self.getShowLabel = _cast(None, getShowLabel)
        self.getShowLabel_nsprefix_ = None
        self.showImage = _cast(bool, showImage)
        self.showImage_nsprefix_ = None
        self.getShowImage = _cast(None, getShowImage)
        self.getShowImage_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_ControlBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_ControlBase.subclass:
            return CT_ControlBase.subclass(*args_, **kwargs_)
        else:
            return CT_ControlBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def get_imageMso(self):
        return self.imageMso
    def set_imageMso(self, imageMso):
        self.imageMso = imageMso
    def get_getImage(self):
        return self.getImage
    def set_getImage(self, getImage):
        self.getImage = getImage
    def get_screentip(self):
        return self.screentip
    def set_screentip(self, screentip):
        self.screentip = screentip
    def get_getScreentip(self):
        return self.getScreentip
    def set_getScreentip(self, getScreentip):
        self.getScreentip = getScreentip
    def get_supertip(self):
        return self.supertip
    def set_supertip(self, supertip):
        self.supertip = supertip
    def get_getSupertip(self):
        return self.getSupertip
    def set_getSupertip(self, getSupertip):
        self.getSupertip = getSupertip
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    def get_getEnabled(self):
        return self.getEnabled
    def set_getEnabled(self, getEnabled):
        self.getEnabled = getEnabled
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_getLabel(self):
        return self.getLabel
    def set_getLabel(self, getLabel):
        self.getLabel = getLabel
    def get_insertAfterMso(self):
        return self.insertAfterMso
    def set_insertAfterMso(self, insertAfterMso):
        self.insertAfterMso = insertAfterMso
    def get_insertBeforeMso(self):
        return self.insertBeforeMso
    def set_insertBeforeMso(self, insertBeforeMso):
        self.insertBeforeMso = insertBeforeMso
    def get_insertAfterQ(self):
        return self.insertAfterQ
    def set_insertAfterQ(self, insertAfterQ):
        self.insertAfterQ = insertAfterQ
    def get_insertBeforeQ(self):
        return self.insertBeforeQ
    def set_insertBeforeQ(self, insertBeforeQ):
        self.insertBeforeQ = insertBeforeQ
    def get_visible(self):
        return self.visible
    def set_visible(self, visible):
        self.visible = visible
    def get_getVisible(self):
        return self.getVisible
    def set_getVisible(self, getVisible):
        self.getVisible = getVisible
    def get_keytip(self):
        return self.keytip
    def set_keytip(self, keytip):
        self.keytip = keytip
    def get_getKeytip(self):
        return self.getKeytip
    def set_getKeytip(self, getKeytip):
        self.getKeytip = getKeytip
    def get_showLabel(self):
        return self.showLabel
    def set_showLabel(self, showLabel):
        self.showLabel = showLabel
    def get_getShowLabel(self):
        return self.getShowLabel
    def set_getShowLabel(self, getShowLabel):
        self.getShowLabel = getShowLabel
    def get_showImage(self):
        return self.showImage
    def set_showImage(self, showImage):
        self.showImage = showImage
    def get_getShowImage(self):
        return self.getShowImage
    def set_getShowImage(self, getShowImage):
        self.getShowImage = getShowImage
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ST_Uri(self, value):
        # Validate type ST_Uri, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Uri' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Uri' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_Keytip(self, value):
        # Validate type ST_Keytip, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Keytip' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Keytip' % {"value" : value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_ControlBase', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_ControlBase')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_ControlBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_ControlBase', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_ControlBase'):
        if self.image is not None and 'image' not in already_processed:
            already_processed.add('image')
            outfile.write(' image=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.image), input_name='image')), ))
        if self.imageMso is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            outfile.write(' imageMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.imageMso), input_name='imageMso')), ))
        if self.getImage is not None and 'getImage' not in already_processed:
            already_processed.add('getImage')
            outfile.write(' getImage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getImage), input_name='getImage')), ))
        if self.screentip is not None and 'screentip' not in already_processed:
            already_processed.add('screentip')
            outfile.write(' screentip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.screentip), input_name='screentip')), ))
        if self.getScreentip is not None and 'getScreentip' not in already_processed:
            already_processed.add('getScreentip')
            outfile.write(' getScreentip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getScreentip), input_name='getScreentip')), ))
        if self.supertip is not None and 'supertip' not in already_processed:
            already_processed.add('supertip')
            outfile.write(' supertip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.supertip), input_name='supertip')), ))
        if self.getSupertip is not None and 'getSupertip' not in already_processed:
            already_processed.add('getSupertip')
            outfile.write(' getSupertip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getSupertip), input_name='getSupertip')), ))
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            outfile.write(' enabled="%s"' % self.gds_format_boolean(self.enabled, input_name='enabled'))
        if self.getEnabled is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            outfile.write(' getEnabled=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getEnabled), input_name='getEnabled')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.getLabel is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            outfile.write(' getLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getLabel), input_name='getLabel')), ))
        if self.insertAfterMso is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            outfile.write(' insertAfterMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterMso), input_name='insertAfterMso')), ))
        if self.insertBeforeMso is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            outfile.write(' insertBeforeMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeMso), input_name='insertBeforeMso')), ))
        if self.insertAfterQ is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            outfile.write(' insertAfterQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterQ), input_name='insertAfterQ')), ))
        if self.insertBeforeQ is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            outfile.write(' insertBeforeQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeQ), input_name='insertBeforeQ')), ))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            outfile.write(' visible="%s"' % self.gds_format_boolean(self.visible, input_name='visible'))
        if self.getVisible is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            outfile.write(' getVisible=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getVisible), input_name='getVisible')), ))
        if self.keytip is not None and 'keytip' not in already_processed:
            already_processed.add('keytip')
            outfile.write(' keytip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.keytip), input_name='keytip')), ))
        if self.getKeytip is not None and 'getKeytip' not in already_processed:
            already_processed.add('getKeytip')
            outfile.write(' getKeytip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getKeytip), input_name='getKeytip')), ))
        if self.showLabel is not None and 'showLabel' not in already_processed:
            already_processed.add('showLabel')
            outfile.write(' showLabel="%s"' % self.gds_format_boolean(self.showLabel, input_name='showLabel'))
        if self.getShowLabel is not None and 'getShowLabel' not in already_processed:
            already_processed.add('getShowLabel')
            outfile.write(' getShowLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getShowLabel), input_name='getShowLabel')), ))
        if self.showImage is not None and 'showImage' not in already_processed:
            already_processed.add('showImage')
            outfile.write(' showImage="%s"' % self.gds_format_boolean(self.showImage, input_name='showImage'))
        if self.getShowImage is not None and 'getShowImage' not in already_processed:
            already_processed.add('getShowImage')
            outfile.write(' getShowImage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getShowImage), input_name='getShowImage')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_ControlBase', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('image', node)
        if value is not None and 'image' not in already_processed:
            already_processed.add('image')
            self.image = value
            self.validate_ST_Uri(self.image)    # validate type ST_Uri
        value = find_attr_value_('imageMso', node)
        if value is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            self.imageMso = value
            self.validate_ST_ID(self.imageMso)    # validate type ST_ID
        value = find_attr_value_('getImage', node)
        if value is not None and 'getImage' not in already_processed:
            already_processed.add('getImage')
            self.getImage = value
            self.validate_ST_Delegate(self.getImage)    # validate type ST_Delegate
        value = find_attr_value_('screentip', node)
        if value is not None and 'screentip' not in already_processed:
            already_processed.add('screentip')
            self.screentip = value
            self.validate_ST_String(self.screentip)    # validate type ST_String
        value = find_attr_value_('getScreentip', node)
        if value is not None and 'getScreentip' not in already_processed:
            already_processed.add('getScreentip')
            self.getScreentip = value
            self.validate_ST_Delegate(self.getScreentip)    # validate type ST_Delegate
        value = find_attr_value_('supertip', node)
        if value is not None and 'supertip' not in already_processed:
            already_processed.add('supertip')
            self.supertip = value
            self.validate_ST_String(self.supertip)    # validate type ST_String
        value = find_attr_value_('getSupertip', node)
        if value is not None and 'getSupertip' not in already_processed:
            already_processed.add('getSupertip')
            self.getSupertip = value
            self.validate_ST_Delegate(self.getSupertip)    # validate type ST_Delegate
        value = find_attr_value_('enabled', node)
        if value is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            if value in ('true', '1'):
                self.enabled = True
            elif value in ('false', '0'):
                self.enabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getEnabled', node)
        if value is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            self.getEnabled = value
            self.validate_ST_Delegate(self.getEnabled)    # validate type ST_Delegate
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
            self.validate_ST_String(self.label)    # validate type ST_String
        value = find_attr_value_('getLabel', node)
        if value is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            self.getLabel = value
            self.validate_ST_Delegate(self.getLabel)    # validate type ST_Delegate
        value = find_attr_value_('insertAfterMso', node)
        if value is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            self.insertAfterMso = value
            self.validate_ST_ID(self.insertAfterMso)    # validate type ST_ID
        value = find_attr_value_('insertBeforeMso', node)
        if value is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            self.insertBeforeMso = value
            self.validate_ST_ID(self.insertBeforeMso)    # validate type ST_ID
        value = find_attr_value_('insertAfterQ', node)
        if value is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            self.insertAfterQ = value
            self.validate_ST_QID(self.insertAfterQ)    # validate type ST_QID
        value = find_attr_value_('insertBeforeQ', node)
        if value is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            self.insertBeforeQ = value
            self.validate_ST_QID(self.insertBeforeQ)    # validate type ST_QID
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            if value in ('true', '1'):
                self.visible = True
            elif value in ('false', '0'):
                self.visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getVisible', node)
        if value is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            self.getVisible = value
            self.validate_ST_Delegate(self.getVisible)    # validate type ST_Delegate
        value = find_attr_value_('keytip', node)
        if value is not None and 'keytip' not in already_processed:
            already_processed.add('keytip')
            self.keytip = value
            self.keytip = ' '.join(self.keytip.split())
            self.validate_ST_Keytip(self.keytip)    # validate type ST_Keytip
        value = find_attr_value_('getKeytip', node)
        if value is not None and 'getKeytip' not in already_processed:
            already_processed.add('getKeytip')
            self.getKeytip = value
            self.validate_ST_Delegate(self.getKeytip)    # validate type ST_Delegate
        value = find_attr_value_('showLabel', node)
        if value is not None and 'showLabel' not in already_processed:
            already_processed.add('showLabel')
            if value in ('true', '1'):
                self.showLabel = True
            elif value in ('false', '0'):
                self.showLabel = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getShowLabel', node)
        if value is not None and 'getShowLabel' not in already_processed:
            already_processed.add('getShowLabel')
            self.getShowLabel = value
            self.validate_ST_Delegate(self.getShowLabel)    # validate type ST_Delegate
        value = find_attr_value_('showImage', node)
        if value is not None and 'showImage' not in already_processed:
            already_processed.add('showImage')
            if value in ('true', '1'):
                self.showImage = True
            elif value in ('false', '0'):
                self.showImage = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getShowImage', node)
        if value is not None and 'getShowImage' not in already_processed:
            already_processed.add('getShowImage')
            self.getShowImage = value
            self.validate_ST_Delegate(self.getShowImage)    # validate type ST_Delegate
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CT_ControlBase


class CT_Control(CT_ControlBase):
    """Specifies a type of control that can be used to
    enable, disable, or clone an existing control."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_ControlBase
    def __init__(self, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, enabled=None, getEnabled=None, label=None, getLabel=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, keytip=None, getKeytip=None, showLabel=None, getShowLabel=None, showImage=None, getShowImage=None, id=None, idQ=None, tag=None, idMso=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_Control, self).__init__(image, imageMso, getImage, screentip, getScreentip, supertip, getSupertip, enabled, getEnabled, label, getLabel, insertAfterMso, insertBeforeMso, insertAfterQ, insertBeforeQ, visible, getVisible, keytip, getKeytip, showLabel, getShowLabel, showImage, getShowImage, extensiontype_,  **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.idMso = _cast(None, idMso)
        self.idMso_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_Control)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_Control.subclass:
            return CT_Control.subclass(*args_, **kwargs_)
        else:
            return CT_Control(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_idMso(self):
        return self.idMso
    def set_idMso(self, idMso):
        self.idMso = idMso
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(CT_Control, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_Control', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_Control')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_Control')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_Control', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_Control'):
        super(CT_Control, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_Control')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.idMso is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            outfile.write(' idMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idMso), input_name='idMso')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_Control', fromsubclass_=False, pretty_print=True):
        super(CT_Control, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('idMso', node)
        if value is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            self.idMso = value
            self.validate_ST_ID(self.idMso)    # validate type ST_ID
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CT_Control, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CT_Control, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CT_Control


class CT_ControlCloneRegular(CT_Control):
    """Specifies a clone of built-in control.
    Control type is determined by source control.
    Only the most common attributes can be applied here; to set
    control-specific properties the actual control type must be specified.
    Custom controls can't be cloned by id."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_Control
    def __init__(self, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, enabled=None, getEnabled=None, label=None, getLabel=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, keytip=None, getKeytip=None, showLabel=None, getShowLabel=None, showImage=None, getShowImage=None, id=None, idQ=None, tag=None, idMso=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_ControlCloneRegular, self).__init__(image, imageMso, getImage, screentip, getScreentip, supertip, getSupertip, enabled, getEnabled, label, getLabel, insertAfterMso, insertBeforeMso, insertAfterQ, insertBeforeQ, visible, getVisible, keytip, getKeytip, showLabel, getShowLabel, showImage, getShowImage, id, idQ, tag, idMso,  **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_ControlCloneRegular)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_ControlCloneRegular.subclass:
            return CT_ControlCloneRegular.subclass(*args_, **kwargs_)
        else:
            return CT_ControlCloneRegular(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def hasContent_(self):
        if (
            super(CT_ControlCloneRegular, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_ControlCloneRegular', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_ControlCloneRegular')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_ControlCloneRegular')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_ControlCloneRegular', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_ControlCloneRegular'):
        super(CT_ControlCloneRegular, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_ControlCloneRegular')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_ControlCloneRegular', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(CT_ControlCloneRegular, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CT_ControlCloneRegular


class CT_ControlCloneQat(CT_ControlBase):
    """Specifies a clone of built-in or custom control in QAT.
    Custom id to clone from.
    Can refer to a custom ID in same file.
    A qualified control ID."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_ControlBase
    def __init__(self, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, enabled=None, getEnabled=None, label=None, getLabel=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, keytip=None, getKeytip=None, showLabel=None, getShowLabel=None, showImage=None, getShowImage=None, id=None, idQ=None, idMso=None, description=None, getDescription=None, size=None, getSize=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_ControlCloneQat, self).__init__(image, imageMso, getImage, screentip, getScreentip, supertip, getSupertip, enabled, getEnabled, label, getLabel, insertAfterMso, insertBeforeMso, insertAfterQ, insertBeforeQ, visible, getVisible, keytip, getKeytip, showLabel, getShowLabel, showImage, getShowImage,  **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.idMso = _cast(None, idMso)
        self.idMso_nsprefix_ = None
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
        self.getDescription = _cast(None, getDescription)
        self.getDescription_nsprefix_ = None
        self.size = _cast(None, size)
        self.size_nsprefix_ = None
        self.getSize = _cast(None, getSize)
        self.getSize_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_ControlCloneQat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_ControlCloneQat.subclass:
            return CT_ControlCloneQat.subclass(*args_, **kwargs_)
        else:
            return CT_ControlCloneQat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_idMso(self):
        return self.idMso
    def set_idMso(self, idMso):
        self.idMso = idMso
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_getDescription(self):
        return self.getDescription
    def set_getDescription(self, getDescription):
        self.getDescription = getDescription
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    def get_getSize(self):
        return self.getSize
    def set_getSize(self, getSize):
        self.getSize = getSize
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_LongString(self, value):
        # Validate type ST_LongString, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_LongString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_LongString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Size(self, value):
        # Validate type ST_Size, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'large']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ST_Size' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(CT_ControlCloneQat, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_ControlCloneQat', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_ControlCloneQat')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_ControlCloneQat')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_ControlCloneQat', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_ControlCloneQat'):
        super(CT_ControlCloneQat, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_ControlCloneQat')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.idMso is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            outfile.write(' idMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idMso), input_name='idMso')), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.getDescription is not None and 'getDescription' not in already_processed:
            already_processed.add('getDescription')
            outfile.write(' getDescription=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getDescription), input_name='getDescription')), ))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.size), input_name='size')), ))
        if self.getSize is not None and 'getSize' not in already_processed:
            already_processed.add('getSize')
            outfile.write(' getSize=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getSize), input_name='getSize')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_ControlCloneQat', fromsubclass_=False, pretty_print=True):
        super(CT_ControlCloneQat, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_ID(self.id)    # validate type ST_ID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('idMso', node)
        if value is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            self.idMso = value
            self.validate_ST_ID(self.idMso)    # validate type ST_ID
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
            self.validate_ST_LongString(self.description)    # validate type ST_LongString
        value = find_attr_value_('getDescription', node)
        if value is not None and 'getDescription' not in already_processed:
            already_processed.add('getDescription')
            self.getDescription = value
            self.validate_ST_Delegate(self.getDescription)    # validate type ST_Delegate
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            self.size = value
            self.validate_ST_Size(self.size)    # validate type ST_Size
        value = find_attr_value_('getSize', node)
        if value is not None and 'getSize' not in already_processed:
            already_processed.add('getSize')
            self.getSize = value
            self.validate_ST_Delegate(self.getSize)    # validate type ST_Delegate
        super(CT_ControlCloneQat, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CT_ControlCloneQat, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CT_ControlCloneQat


class CT_LabelControl(CT_Control):
    """Shows text and/or icon but can't have any associated actions.
    "image" property is not applicable to labelControl.
    "imageMso" property is not applicable to labelControl.
    "getImage" callback is not applicable to labelControl.
    "keytip" property is not applicable to labelControl.
    "getKeytip" callback is not applicable to labelControl.
    "showImage" property is not applicable to labelControl.
    "getShowImage" callback is not applicable to labelControl."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_Control
    def __init__(self, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, enabled=None, getEnabled=None, label=None, getLabel=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, keytip=None, getKeytip=None, showLabel=None, getShowLabel=None, showImage=None, getShowImage=None, id=None, idQ=None, tag=None, idMso=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_LabelControl, self).__init__(image, imageMso, getImage, screentip, getScreentip, supertip, getSupertip, enabled, getEnabled, label, getLabel, insertAfterMso, insertBeforeMso, insertAfterQ, insertBeforeQ, visible, getVisible, keytip, getKeytip, showLabel, getShowLabel, showImage, getShowImage, id, idQ, tag, idMso,  **kwargs_)
        self.image = _cast(None, image)
        self.image_nsprefix_ = None
        self.imageMso = _cast(None, imageMso)
        self.imageMso_nsprefix_ = None
        self.getImage = _cast(None, getImage)
        self.getImage_nsprefix_ = None
        self.keytip = _cast(None, keytip)
        self.keytip_nsprefix_ = None
        self.getKeytip = _cast(None, getKeytip)
        self.getKeytip_nsprefix_ = None
        self.showImage = _cast(None, showImage)
        self.showImage_nsprefix_ = None
        self.getShowImage = _cast(None, getShowImage)
        self.getShowImage_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_LabelControl)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_LabelControl.subclass:
            return CT_LabelControl.subclass(*args_, **kwargs_)
        else:
            return CT_LabelControl(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def get_imageMso(self):
        return self.imageMso
    def set_imageMso(self, imageMso):
        self.imageMso = imageMso
    def get_getImage(self):
        return self.getImage
    def set_getImage(self, getImage):
        self.getImage = getImage
    def get_keytip(self):
        return self.keytip
    def set_keytip(self, keytip):
        self.keytip = keytip
    def get_getKeytip(self):
        return self.getKeytip
    def set_getKeytip(self, getKeytip):
        self.getKeytip = getKeytip
    def get_showImage(self):
        return self.showImage
    def set_showImage(self, showImage):
        self.showImage = showImage
    def get_getShowImage(self):
        return self.getShowImage
    def set_getShowImage(self, getShowImage):
        self.getShowImage = getShowImage
    def hasContent_(self):
        if (
            super(CT_LabelControl, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_LabelControl', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_LabelControl')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_LabelControl')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_LabelControl', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_LabelControl'):
        super(CT_LabelControl, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_LabelControl')
        if self.image is not None and 'image' not in already_processed:
            already_processed.add('image')
            outfile.write(' image=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.image), input_name='image')), ))
        if self.imageMso is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            outfile.write(' imageMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.imageMso), input_name='imageMso')), ))
        if self.getImage is not None and 'getImage' not in already_processed:
            already_processed.add('getImage')
            outfile.write(' getImage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getImage), input_name='getImage')), ))
        if self.keytip is not None and 'keytip' not in already_processed:
            already_processed.add('keytip')
            outfile.write(' keytip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.keytip), input_name='keytip')), ))
        if self.getKeytip is not None and 'getKeytip' not in already_processed:
            already_processed.add('getKeytip')
            outfile.write(' getKeytip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getKeytip), input_name='getKeytip')), ))
        if self.showImage is not None and 'showImage' not in already_processed:
            already_processed.add('showImage')
            outfile.write(' showImage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.showImage), input_name='showImage')), ))
        if self.getShowImage is not None and 'getShowImage' not in already_processed:
            already_processed.add('getShowImage')
            outfile.write(' getShowImage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getShowImage), input_name='getShowImage')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_LabelControl', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('image', node)
        if value is not None and 'image' not in already_processed:
            already_processed.add('image')
            self.image = value
        value = find_attr_value_('imageMso', node)
        if value is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            self.imageMso = value
        value = find_attr_value_('getImage', node)
        if value is not None and 'getImage' not in already_processed:
            already_processed.add('getImage')
            self.getImage = value
        value = find_attr_value_('keytip', node)
        if value is not None and 'keytip' not in already_processed:
            already_processed.add('keytip')
            self.keytip = value
        value = find_attr_value_('getKeytip', node)
        if value is not None and 'getKeytip' not in already_processed:
            already_processed.add('getKeytip')
            self.getKeytip = value
        value = find_attr_value_('showImage', node)
        if value is not None and 'showImage' not in already_processed:
            already_processed.add('showImage')
            self.showImage = value
        value = find_attr_value_('getShowImage', node)
        if value is not None and 'getShowImage' not in already_processed:
            already_processed.add('getShowImage')
            self.getShowImage = value
        super(CT_LabelControl, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CT_LabelControl


class CT_ButtonRegular(CT_Control):
    """Specifies a fixed-size button.
    Size of a button of this type is determined by its container such as a
    menu."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_Control
    def __init__(self, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, enabled=None, getEnabled=None, label=None, getLabel=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, keytip=None, getKeytip=None, showLabel=None, getShowLabel=None, showImage=None, getShowImage=None, id=None, idQ=None, tag=None, idMso=None, onAction=None, description=None, getDescription=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_ButtonRegular, self).__init__(image, imageMso, getImage, screentip, getScreentip, supertip, getSupertip, enabled, getEnabled, label, getLabel, insertAfterMso, insertBeforeMso, insertAfterQ, insertBeforeQ, visible, getVisible, keytip, getKeytip, showLabel, getShowLabel, showImage, getShowImage, id, idQ, tag, idMso, extensiontype_,  **kwargs_)
        self.onAction = _cast(None, onAction)
        self.onAction_nsprefix_ = None
        self.enabled = _cast(bool, enabled)
        self.enabled_nsprefix_ = None
        self.getEnabled = _cast(None, getEnabled)
        self.getEnabled_nsprefix_ = None
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
        self.getDescription = _cast(None, getDescription)
        self.getDescription_nsprefix_ = None
        self.image = _cast(None, image)
        self.image_nsprefix_ = None
        self.imageMso = _cast(None, imageMso)
        self.imageMso_nsprefix_ = None
        self.getImage = _cast(None, getImage)
        self.getImage_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_ButtonRegular)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_ButtonRegular.subclass:
            return CT_ButtonRegular.subclass(*args_, **kwargs_)
        else:
            return CT_ButtonRegular(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_onAction(self):
        return self.onAction
    def set_onAction(self, onAction):
        self.onAction = onAction
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    def get_getEnabled(self):
        return self.getEnabled
    def set_getEnabled(self, getEnabled):
        self.getEnabled = getEnabled
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_getDescription(self):
        return self.getDescription
    def set_getDescription(self, getDescription):
        self.getDescription = getDescription
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def get_imageMso(self):
        return self.imageMso
    def set_imageMso(self, imageMso):
        self.imageMso = imageMso
    def get_getImage(self):
        return self.getImage
    def set_getImage(self, getImage):
        self.getImage = getImage
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_LongString(self, value):
        # Validate type ST_LongString, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_LongString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_LongString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Uri(self, value):
        # Validate type ST_Uri, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Uri' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Uri' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(CT_ButtonRegular, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_ButtonRegular', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_ButtonRegular')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_ButtonRegular')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_ButtonRegular', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_ButtonRegular'):
        super(CT_ButtonRegular, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_ButtonRegular')
        if self.onAction is not None and 'onAction' not in already_processed:
            already_processed.add('onAction')
            outfile.write(' onAction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.onAction), input_name='onAction')), ))
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            outfile.write(' enabled="%s"' % self.gds_format_boolean(self.enabled, input_name='enabled'))
        if self.getEnabled is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            outfile.write(' getEnabled=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getEnabled), input_name='getEnabled')), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.getDescription is not None and 'getDescription' not in already_processed:
            already_processed.add('getDescription')
            outfile.write(' getDescription=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getDescription), input_name='getDescription')), ))
        if self.image is not None and 'image' not in already_processed:
            already_processed.add('image')
            outfile.write(' image=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.image), input_name='image')), ))
        if self.imageMso is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            outfile.write(' imageMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.imageMso), input_name='imageMso')), ))
        if self.getImage is not None and 'getImage' not in already_processed:
            already_processed.add('getImage')
            outfile.write(' getImage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getImage), input_name='getImage')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_ButtonRegular', fromsubclass_=False, pretty_print=True):
        super(CT_ButtonRegular, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('onAction', node)
        if value is not None and 'onAction' not in already_processed:
            already_processed.add('onAction')
            self.onAction = value
            self.validate_ST_Delegate(self.onAction)    # validate type ST_Delegate
        value = find_attr_value_('enabled', node)
        if value is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            if value in ('true', '1'):
                self.enabled = True
            elif value in ('false', '0'):
                self.enabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getEnabled', node)
        if value is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            self.getEnabled = value
            self.validate_ST_Delegate(self.getEnabled)    # validate type ST_Delegate
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
            self.validate_ST_LongString(self.description)    # validate type ST_LongString
        value = find_attr_value_('getDescription', node)
        if value is not None and 'getDescription' not in already_processed:
            already_processed.add('getDescription')
            self.getDescription = value
            self.validate_ST_Delegate(self.getDescription)    # validate type ST_Delegate
        value = find_attr_value_('image', node)
        if value is not None and 'image' not in already_processed:
            already_processed.add('image')
            self.image = value
            self.validate_ST_Uri(self.image)    # validate type ST_Uri
        value = find_attr_value_('imageMso', node)
        if value is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            self.imageMso = value
            self.validate_ST_ID(self.imageMso)    # validate type ST_ID
        value = find_attr_value_('getImage', node)
        if value is not None and 'getImage' not in already_processed:
            already_processed.add('getImage')
            self.getImage = value
            self.validate_ST_Delegate(self.getImage)    # validate type ST_Delegate
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CT_ButtonRegular, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CT_ButtonRegular, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CT_ButtonRegular


class CT_Button(CT_ButtonRegular):
    """Specifies a push-type button."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_ButtonRegular
    def __init__(self, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, enabled=None, getEnabled=None, label=None, getLabel=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, keytip=None, getKeytip=None, showLabel=None, getShowLabel=None, showImage=None, getShowImage=None, id=None, idQ=None, tag=None, idMso=None, onAction=None, description=None, getDescription=None, size=None, getSize=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_Button, self).__init__(image, imageMso, getImage, screentip, getScreentip, supertip, getSupertip, enabled, getEnabled, label, getLabel, insertAfterMso, insertBeforeMso, insertAfterQ, insertBeforeQ, visible, getVisible, keytip, getKeytip, showLabel, getShowLabel, showImage, getShowImage, id, idQ, tag, idMso, onAction, description, getDescription,  **kwargs_)
        self.size = _cast(None, size)
        self.size_nsprefix_ = None
        self.getSize = _cast(None, getSize)
        self.getSize_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_Button)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_Button.subclass:
            return CT_Button.subclass(*args_, **kwargs_)
        else:
            return CT_Button(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    def get_getSize(self):
        return self.getSize
    def set_getSize(self, getSize):
        self.getSize = getSize
    def validate_ST_Size(self, value):
        # Validate type ST_Size, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'large']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ST_Size' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(CT_Button, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_Button', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_Button')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_Button')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_Button', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_Button'):
        super(CT_Button, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_Button')
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.size), input_name='size')), ))
        if self.getSize is not None and 'getSize' not in already_processed:
            already_processed.add('getSize')
            outfile.write(' getSize=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getSize), input_name='getSize')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_Button', fromsubclass_=False, pretty_print=True):
        super(CT_Button, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            self.size = value
            self.validate_ST_Size(self.size)    # validate type ST_Size
        value = find_attr_value_('getSize', node)
        if value is not None and 'getSize' not in already_processed:
            already_processed.add('getSize')
            self.getSize = value
            self.validate_ST_Delegate(self.getSize)    # validate type ST_Delegate
        super(CT_Button, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CT_Button, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CT_Button


class CT_VisibleButton(CT_ButtonRegular):
    """Specifies a button which is always visible.
    "visible" property is not applicable to these types of buttons
    because they are always visible.
    "getVisible" property is not applicable to these types of buttons
    because they are always visible."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_ButtonRegular
    def __init__(self, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, enabled=None, getEnabled=None, label=None, getLabel=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, keytip=None, getKeytip=None, showLabel=None, getShowLabel=None, showImage=None, getShowImage=None, id=None, idQ=None, tag=None, idMso=None, onAction=None, description=None, getDescription=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_VisibleButton, self).__init__(image, imageMso, getImage, screentip, getScreentip, supertip, getSupertip, enabled, getEnabled, label, getLabel, insertAfterMso, insertBeforeMso, insertAfterQ, insertBeforeQ, visible, getVisible, keytip, getKeytip, showLabel, getShowLabel, showImage, getShowImage, id, idQ, tag, idMso, onAction, description, getDescription,  **kwargs_)
        self.visible = _cast(None, visible)
        self.visible_nsprefix_ = None
        self.getVisible = _cast(None, getVisible)
        self.getVisible_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_VisibleButton)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_VisibleButton.subclass:
            return CT_VisibleButton.subclass(*args_, **kwargs_)
        else:
            return CT_VisibleButton(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_visible(self):
        return self.visible
    def set_visible(self, visible):
        self.visible = visible
    def get_getVisible(self):
        return self.getVisible
    def set_getVisible(self, getVisible):
        self.getVisible = getVisible
    def hasContent_(self):
        if (
            super(CT_VisibleButton, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_VisibleButton', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_VisibleButton')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_VisibleButton')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_VisibleButton', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_VisibleButton'):
        super(CT_VisibleButton, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_VisibleButton')
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            outfile.write(' visible=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.visible), input_name='visible')), ))
        if self.getVisible is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            outfile.write(' getVisible=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getVisible), input_name='getVisible')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_VisibleButton', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            self.visible = value
        value = find_attr_value_('getVisible', node)
        if value is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            self.getVisible = value
        super(CT_VisibleButton, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CT_VisibleButton


class CT_ToggleButtonRegular(CT_ButtonRegular):
    """Specifies a fixed-size button type with an on/off state such as a Bold
    button."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_ButtonRegular
    def __init__(self, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, enabled=None, getEnabled=None, label=None, getLabel=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, keytip=None, getKeytip=None, showLabel=None, getShowLabel=None, showImage=None, getShowImage=None, id=None, idQ=None, tag=None, idMso=None, onAction=None, description=None, getDescription=None, getPressed=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_ToggleButtonRegular, self).__init__(image, imageMso, getImage, screentip, getScreentip, supertip, getSupertip, enabled, getEnabled, label, getLabel, insertAfterMso, insertBeforeMso, insertAfterQ, insertBeforeQ, visible, getVisible, keytip, getKeytip, showLabel, getShowLabel, showImage, getShowImage, id, idQ, tag, idMso, onAction, description, getDescription, extensiontype_,  **kwargs_)
        self.getPressed = _cast(None, getPressed)
        self.getPressed_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_ToggleButtonRegular)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_ToggleButtonRegular.subclass:
            return CT_ToggleButtonRegular.subclass(*args_, **kwargs_)
        else:
            return CT_ToggleButtonRegular(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_getPressed(self):
        return self.getPressed
    def set_getPressed(self, getPressed):
        self.getPressed = getPressed
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(CT_ToggleButtonRegular, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_ToggleButtonRegular', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_ToggleButtonRegular')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_ToggleButtonRegular')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_ToggleButtonRegular', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_ToggleButtonRegular'):
        super(CT_ToggleButtonRegular, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_ToggleButtonRegular')
        if self.getPressed is not None and 'getPressed' not in already_processed:
            already_processed.add('getPressed')
            outfile.write(' getPressed=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getPressed), input_name='getPressed')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_ToggleButtonRegular', fromsubclass_=False, pretty_print=True):
        super(CT_ToggleButtonRegular, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('getPressed', node)
        if value is not None and 'getPressed' not in already_processed:
            already_processed.add('getPressed')
            self.getPressed = value
            self.validate_ST_Delegate(self.getPressed)    # validate type ST_Delegate
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CT_ToggleButtonRegular, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CT_ToggleButtonRegular, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CT_ToggleButtonRegular


class CT_ToggleButton(CT_ToggleButtonRegular):
    """Specifies a button type with an on/off state that can be sized."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_ToggleButtonRegular
    def __init__(self, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, enabled=None, getEnabled=None, label=None, getLabel=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, keytip=None, getKeytip=None, showLabel=None, getShowLabel=None, showImage=None, getShowImage=None, id=None, idQ=None, tag=None, idMso=None, onAction=None, description=None, getDescription=None, getPressed=None, size=None, getSize=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_ToggleButton, self).__init__(image, imageMso, getImage, screentip, getScreentip, supertip, getSupertip, enabled, getEnabled, label, getLabel, insertAfterMso, insertBeforeMso, insertAfterQ, insertBeforeQ, visible, getVisible, keytip, getKeytip, showLabel, getShowLabel, showImage, getShowImage, id, idQ, tag, idMso, onAction, description, getDescription, getPressed,  **kwargs_)
        self.size = _cast(None, size)
        self.size_nsprefix_ = None
        self.getSize = _cast(None, getSize)
        self.getSize_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_ToggleButton)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_ToggleButton.subclass:
            return CT_ToggleButton.subclass(*args_, **kwargs_)
        else:
            return CT_ToggleButton(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    def get_getSize(self):
        return self.getSize
    def set_getSize(self, getSize):
        self.getSize = getSize
    def validate_ST_Size(self, value):
        # Validate type ST_Size, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'large']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ST_Size' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(CT_ToggleButton, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_ToggleButton', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_ToggleButton')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_ToggleButton')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_ToggleButton', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_ToggleButton'):
        super(CT_ToggleButton, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_ToggleButton')
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.size), input_name='size')), ))
        if self.getSize is not None and 'getSize' not in already_processed:
            already_processed.add('getSize')
            outfile.write(' getSize=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getSize), input_name='getSize')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_ToggleButton', fromsubclass_=False, pretty_print=True):
        super(CT_ToggleButton, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            self.size = value
            self.validate_ST_Size(self.size)    # validate type ST_Size
        value = find_attr_value_('getSize', node)
        if value is not None and 'getSize' not in already_processed:
            already_processed.add('getSize')
            self.getSize = value
            self.validate_ST_Delegate(self.getSize)    # validate type ST_Delegate
        super(CT_ToggleButton, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CT_ToggleButton, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CT_ToggleButton


class CT_VisibleToggleButton(CT_ToggleButtonRegular):
    """Specifies a toggleButton which is always visible.
    "visible" property is not applicable to these types of buttons
    because they are always visible.
    "getVisible" property is not applicable to these types of buttons
    because they are always visible."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_ToggleButtonRegular
    def __init__(self, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, enabled=None, getEnabled=None, label=None, getLabel=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, keytip=None, getKeytip=None, showLabel=None, getShowLabel=None, showImage=None, getShowImage=None, id=None, idQ=None, tag=None, idMso=None, onAction=None, description=None, getDescription=None, getPressed=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_VisibleToggleButton, self).__init__(image, imageMso, getImage, screentip, getScreentip, supertip, getSupertip, enabled, getEnabled, label, getLabel, insertAfterMso, insertBeforeMso, insertAfterQ, insertBeforeQ, visible, getVisible, keytip, getKeytip, showLabel, getShowLabel, showImage, getShowImage, id, idQ, tag, idMso, onAction, description, getDescription, getPressed,  **kwargs_)
        self.visible = _cast(None, visible)
        self.visible_nsprefix_ = None
        self.getVisible = _cast(None, getVisible)
        self.getVisible_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_VisibleToggleButton)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_VisibleToggleButton.subclass:
            return CT_VisibleToggleButton.subclass(*args_, **kwargs_)
        else:
            return CT_VisibleToggleButton(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_visible(self):
        return self.visible
    def set_visible(self, visible):
        self.visible = visible
    def get_getVisible(self):
        return self.getVisible
    def set_getVisible(self, getVisible):
        self.getVisible = getVisible
    def hasContent_(self):
        if (
            super(CT_VisibleToggleButton, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_VisibleToggleButton', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_VisibleToggleButton')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_VisibleToggleButton')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_VisibleToggleButton', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_VisibleToggleButton'):
        super(CT_VisibleToggleButton, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_VisibleToggleButton')
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            outfile.write(' visible=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.visible), input_name='visible')), ))
        if self.getVisible is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            outfile.write(' getVisible=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getVisible), input_name='getVisible')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_VisibleToggleButton', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            self.visible = value
        value = find_attr_value_('getVisible', node)
        if value is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            self.getVisible = value
        super(CT_VisibleToggleButton, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CT_VisibleToggleButton


class CT_CheckBox(CT_ToggleButtonRegular):
    """Specifies a check box.
    "image" property is not applicable to checkBox.
    "imageMso" property is not applicable to checkBox.
    "getImage" callback is not applicable to checkBox.
    "showImage" property is not applicable to checkBox.
    "getShowImage" callback is not applicable to checkBox.
    "showLabel" property is not applicable to checkBox.
    "getShowLabel" callback is not applicable to checkBox."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_ToggleButtonRegular
    def __init__(self, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, enabled=None, getEnabled=None, label=None, getLabel=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, keytip=None, getKeytip=None, showLabel=None, getShowLabel=None, showImage=None, getShowImage=None, id=None, idQ=None, tag=None, idMso=None, onAction=None, description=None, getDescription=None, getPressed=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_CheckBox, self).__init__(image, imageMso, getImage, screentip, getScreentip, supertip, getSupertip, enabled, getEnabled, label, getLabel, insertAfterMso, insertBeforeMso, insertAfterQ, insertBeforeQ, visible, getVisible, keytip, getKeytip, showLabel, getShowLabel, showImage, getShowImage, id, idQ, tag, idMso, onAction, description, getDescription, getPressed,  **kwargs_)
        self.image = _cast(None, image)
        self.image_nsprefix_ = None
        self.imageMso = _cast(None, imageMso)
        self.imageMso_nsprefix_ = None
        self.getImage = _cast(None, getImage)
        self.getImage_nsprefix_ = None
        self.showImage = _cast(None, showImage)
        self.showImage_nsprefix_ = None
        self.getShowImage = _cast(None, getShowImage)
        self.getShowImage_nsprefix_ = None
        self.showLabel = _cast(None, showLabel)
        self.showLabel_nsprefix_ = None
        self.getShowLabel = _cast(None, getShowLabel)
        self.getShowLabel_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_CheckBox)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_CheckBox.subclass:
            return CT_CheckBox.subclass(*args_, **kwargs_)
        else:
            return CT_CheckBox(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def get_imageMso(self):
        return self.imageMso
    def set_imageMso(self, imageMso):
        self.imageMso = imageMso
    def get_getImage(self):
        return self.getImage
    def set_getImage(self, getImage):
        self.getImage = getImage
    def get_showImage(self):
        return self.showImage
    def set_showImage(self, showImage):
        self.showImage = showImage
    def get_getShowImage(self):
        return self.getShowImage
    def set_getShowImage(self, getShowImage):
        self.getShowImage = getShowImage
    def get_showLabel(self):
        return self.showLabel
    def set_showLabel(self, showLabel):
        self.showLabel = showLabel
    def get_getShowLabel(self):
        return self.getShowLabel
    def set_getShowLabel(self, getShowLabel):
        self.getShowLabel = getShowLabel
    def hasContent_(self):
        if (
            super(CT_CheckBox, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_CheckBox', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_CheckBox')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_CheckBox')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_CheckBox', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_CheckBox'):
        super(CT_CheckBox, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_CheckBox')
        if self.image is not None and 'image' not in already_processed:
            already_processed.add('image')
            outfile.write(' image=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.image), input_name='image')), ))
        if self.imageMso is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            outfile.write(' imageMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.imageMso), input_name='imageMso')), ))
        if self.getImage is not None and 'getImage' not in already_processed:
            already_processed.add('getImage')
            outfile.write(' getImage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getImage), input_name='getImage')), ))
        if self.showImage is not None and 'showImage' not in already_processed:
            already_processed.add('showImage')
            outfile.write(' showImage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.showImage), input_name='showImage')), ))
        if self.getShowImage is not None and 'getShowImage' not in already_processed:
            already_processed.add('getShowImage')
            outfile.write(' getShowImage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getShowImage), input_name='getShowImage')), ))
        if self.showLabel is not None and 'showLabel' not in already_processed:
            already_processed.add('showLabel')
            outfile.write(' showLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.showLabel), input_name='showLabel')), ))
        if self.getShowLabel is not None and 'getShowLabel' not in already_processed:
            already_processed.add('getShowLabel')
            outfile.write(' getShowLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getShowLabel), input_name='getShowLabel')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_CheckBox', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('image', node)
        if value is not None and 'image' not in already_processed:
            already_processed.add('image')
            self.image = value
        value = find_attr_value_('imageMso', node)
        if value is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            self.imageMso = value
        value = find_attr_value_('getImage', node)
        if value is not None and 'getImage' not in already_processed:
            already_processed.add('getImage')
            self.getImage = value
        value = find_attr_value_('showImage', node)
        if value is not None and 'showImage' not in already_processed:
            already_processed.add('showImage')
            self.showImage = value
        value = find_attr_value_('getShowImage', node)
        if value is not None and 'getShowImage' not in already_processed:
            already_processed.add('getShowImage')
            self.getShowImage = value
        value = find_attr_value_('showLabel', node)
        if value is not None and 'showLabel' not in already_processed:
            already_processed.add('showLabel')
            self.showLabel = value
        value = find_attr_value_('getShowLabel', node)
        if value is not None and 'getShowLabel' not in already_processed:
            already_processed.add('getShowLabel')
            self.getShowLabel = value
        super(CT_CheckBox, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CT_CheckBox


class CT_EditBox(CT_Control):
    """Specifies an edit box control type.
    OnChange callback reports new text.
    Specifies maximum number of characters the user may input.
    Specifies a callback which returns text to be inserted in the edit box
    before begins editing.
    Specifies a callback which responds on change of selection.
    Specifies a representative string which should fit in the control.
    E.g. if the control is meant for a credit card number a string of 16 digits
    ensures appropriate control size."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_Control
    def __init__(self, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, enabled=None, getEnabled=None, label=None, getLabel=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, keytip=None, getKeytip=None, showLabel=None, getShowLabel=None, showImage=None, getShowImage=None, id=None, idQ=None, tag=None, idMso=None, maxLength=None, getText=None, onChange=None, sizeString=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_EditBox, self).__init__(image, imageMso, getImage, screentip, getScreentip, supertip, getSupertip, enabled, getEnabled, label, getLabel, insertAfterMso, insertBeforeMso, insertAfterQ, insertBeforeQ, visible, getVisible, keytip, getKeytip, showLabel, getShowLabel, showImage, getShowImage, id, idQ, tag, idMso, extensiontype_,  **kwargs_)
        self.maxLength = _cast(int, maxLength)
        self.maxLength_nsprefix_ = None
        self.getText = _cast(None, getText)
        self.getText_nsprefix_ = None
        self.onChange = _cast(None, onChange)
        self.onChange_nsprefix_ = None
        self.sizeString = _cast(None, sizeString)
        self.sizeString_nsprefix_ = None
        self.enabled = _cast(bool, enabled)
        self.enabled_nsprefix_ = None
        self.getEnabled = _cast(None, getEnabled)
        self.getEnabled_nsprefix_ = None
        self.image = _cast(None, image)
        self.image_nsprefix_ = None
        self.imageMso = _cast(None, imageMso)
        self.imageMso_nsprefix_ = None
        self.getImage = _cast(None, getImage)
        self.getImage_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_EditBox)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_EditBox.subclass:
            return CT_EditBox.subclass(*args_, **kwargs_)
        else:
            return CT_EditBox(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_maxLength(self):
        return self.maxLength
    def set_maxLength(self, maxLength):
        self.maxLength = maxLength
    def get_getText(self):
        return self.getText
    def set_getText(self, getText):
        self.getText = getText
    def get_onChange(self):
        return self.onChange
    def set_onChange(self, onChange):
        self.onChange = onChange
    def get_sizeString(self):
        return self.sizeString
    def set_sizeString(self, sizeString):
        self.sizeString = sizeString
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    def get_getEnabled(self):
        return self.getEnabled
    def set_getEnabled(self, getEnabled):
        self.getEnabled = getEnabled
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def get_imageMso(self):
        return self.imageMso
    def set_imageMso(self, imageMso):
        self.imageMso = imageMso
    def get_getImage(self):
        return self.getImage
    def set_getImage(self, getImage):
        self.getImage = getImage
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ST_StringLength(self, value):
        # Validate type ST_StringLength, a restriction on xsd:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ST_StringLength' % {"value": value, "lineno": lineno} )
                result = False
            if value > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ST_StringLength' % {"value": value, "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Uri(self, value):
        # Validate type ST_Uri, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Uri' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Uri' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(CT_EditBox, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_EditBox', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_EditBox')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_EditBox')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_EditBox', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_EditBox'):
        super(CT_EditBox, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_EditBox')
        if self.maxLength is not None and 'maxLength' not in already_processed:
            already_processed.add('maxLength')
            outfile.write(' maxLength="%s"' % self.gds_format_integer(self.maxLength, input_name='maxLength'))
        if self.getText is not None and 'getText' not in already_processed:
            already_processed.add('getText')
            outfile.write(' getText=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getText), input_name='getText')), ))
        if self.onChange is not None and 'onChange' not in already_processed:
            already_processed.add('onChange')
            outfile.write(' onChange=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.onChange), input_name='onChange')), ))
        if self.sizeString is not None and 'sizeString' not in already_processed:
            already_processed.add('sizeString')
            outfile.write(' sizeString=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sizeString), input_name='sizeString')), ))
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            outfile.write(' enabled="%s"' % self.gds_format_boolean(self.enabled, input_name='enabled'))
        if self.getEnabled is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            outfile.write(' getEnabled=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getEnabled), input_name='getEnabled')), ))
        if self.image is not None and 'image' not in already_processed:
            already_processed.add('image')
            outfile.write(' image=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.image), input_name='image')), ))
        if self.imageMso is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            outfile.write(' imageMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.imageMso), input_name='imageMso')), ))
        if self.getImage is not None and 'getImage' not in already_processed:
            already_processed.add('getImage')
            outfile.write(' getImage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getImage), input_name='getImage')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_EditBox', fromsubclass_=False, pretty_print=True):
        super(CT_EditBox, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('maxLength', node)
        if value is not None and 'maxLength' not in already_processed:
            already_processed.add('maxLength')
            self.maxLength = self.gds_parse_integer(value, node, 'maxLength')
            if self.maxLength <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_ST_StringLength(self.maxLength)    # validate type ST_StringLength
        value = find_attr_value_('getText', node)
        if value is not None and 'getText' not in already_processed:
            already_processed.add('getText')
            self.getText = value
            self.validate_ST_Delegate(self.getText)    # validate type ST_Delegate
        value = find_attr_value_('onChange', node)
        if value is not None and 'onChange' not in already_processed:
            already_processed.add('onChange')
            self.onChange = value
            self.validate_ST_Delegate(self.onChange)    # validate type ST_Delegate
        value = find_attr_value_('sizeString', node)
        if value is not None and 'sizeString' not in already_processed:
            already_processed.add('sizeString')
            self.sizeString = value
            self.validate_ST_String(self.sizeString)    # validate type ST_String
        value = find_attr_value_('enabled', node)
        if value is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            if value in ('true', '1'):
                self.enabled = True
            elif value in ('false', '0'):
                self.enabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getEnabled', node)
        if value is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            self.getEnabled = value
            self.validate_ST_Delegate(self.getEnabled)    # validate type ST_Delegate
        value = find_attr_value_('image', node)
        if value is not None and 'image' not in already_processed:
            already_processed.add('image')
            self.image = value
            self.validate_ST_Uri(self.image)    # validate type ST_Uri
        value = find_attr_value_('imageMso', node)
        if value is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            self.imageMso = value
            self.validate_ST_ID(self.imageMso)    # validate type ST_ID
        value = find_attr_value_('getImage', node)
        if value is not None and 'getImage' not in already_processed:
            already_processed.add('getImage')
            self.getImage = value
            self.validate_ST_Delegate(self.getImage)    # validate type ST_Delegate
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CT_EditBox, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CT_EditBox, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CT_EditBox


class CT_Item(GeneratedsSuper):
    """Represents a selection in a comboBox or dropDown control type.
    Specifies the ID of a gallery item. Gallery items cannot use idMso or idQ.
    Specifies text label.
    Specifies the image.
    Specifies a built-in image.
    Specifies the screentip.
    Specifies the SuperTip."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, label=None, image=None, imageMso=None, screentip=None, supertip=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.image = _cast(None, image)
        self.image_nsprefix_ = None
        self.imageMso = _cast(None, imageMso)
        self.imageMso_nsprefix_ = None
        self.screentip = _cast(None, screentip)
        self.screentip_nsprefix_ = None
        self.supertip = _cast(None, supertip)
        self.supertip_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_Item)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_Item.subclass:
            return CT_Item.subclass(*args_, **kwargs_)
        else:
            return CT_Item(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def get_imageMso(self):
        return self.imageMso
    def set_imageMso(self, imageMso):
        self.imageMso = imageMso
    def get_screentip(self):
        return self.screentip
    def set_screentip(self, screentip):
        self.screentip = screentip
    def get_supertip(self):
        return self.supertip
    def set_supertip(self, supertip):
        self.supertip = supertip
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Uri(self, value):
        # Validate type ST_Uri, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Uri' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Uri' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_Item', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_Item')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_Item')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_Item', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_Item'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.image is not None and 'image' not in already_processed:
            already_processed.add('image')
            outfile.write(' image=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.image), input_name='image')), ))
        if self.imageMso is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            outfile.write(' imageMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.imageMso), input_name='imageMso')), ))
        if self.screentip is not None and 'screentip' not in already_processed:
            already_processed.add('screentip')
            outfile.write(' screentip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.screentip), input_name='screentip')), ))
        if self.supertip is not None and 'supertip' not in already_processed:
            already_processed.add('supertip')
            outfile.write(' supertip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.supertip), input_name='supertip')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_Item', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
            self.validate_ST_String(self.label)    # validate type ST_String
        value = find_attr_value_('image', node)
        if value is not None and 'image' not in already_processed:
            already_processed.add('image')
            self.image = value
            self.validate_ST_Uri(self.image)    # validate type ST_Uri
        value = find_attr_value_('imageMso', node)
        if value is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            self.imageMso = value
            self.validate_ST_ID(self.imageMso)    # validate type ST_ID
        value = find_attr_value_('screentip', node)
        if value is not None and 'screentip' not in already_processed:
            already_processed.add('screentip')
            self.screentip = value
            self.validate_ST_String(self.screentip)    # validate type ST_String
        value = find_attr_value_('supertip', node)
        if value is not None and 'supertip' not in already_processed:
            already_processed.add('supertip')
            self.supertip = value
            self.validate_ST_String(self.supertip)    # validate type ST_String
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CT_Item


class CT_ComboBox(CT_EditBox):
    """Specifies a comboBox control type.
    Contains options (multiple-choice item)
    OnChange behavior is same as in EditBox (the text).
    Callback can't tell if the value is typed in or selected."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_EditBox
    def __init__(self, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, enabled=None, getEnabled=None, label=None, getLabel=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, keytip=None, getKeytip=None, showLabel=None, getShowLabel=None, showImage=None, getShowImage=None, id=None, idQ=None, tag=None, idMso=None, maxLength=None, getText=None, onChange=None, sizeString=None, showItemImage=None, getItemCount=None, getItemLabel=None, getItemScreentip=None, getItemSupertip=None, getItemImage=None, getItemID=None, invalidateContentOnDrop=None, item=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_ComboBox, self).__init__(image, imageMso, getImage, screentip, getScreentip, supertip, getSupertip, enabled, getEnabled, label, getLabel, insertAfterMso, insertBeforeMso, insertAfterQ, insertBeforeQ, visible, getVisible, keytip, getKeytip, showLabel, getShowLabel, showImage, getShowImage, id, idQ, tag, idMso, maxLength, getText, onChange, sizeString,  **kwargs_)
        self.showItemImage = _cast(bool, showItemImage)
        self.showItemImage_nsprefix_ = None
        self.getItemCount = _cast(None, getItemCount)
        self.getItemCount_nsprefix_ = None
        self.getItemLabel = _cast(None, getItemLabel)
        self.getItemLabel_nsprefix_ = None
        self.getItemScreentip = _cast(None, getItemScreentip)
        self.getItemScreentip_nsprefix_ = None
        self.getItemSupertip = _cast(None, getItemSupertip)
        self.getItemSupertip_nsprefix_ = None
        self.getItemImage = _cast(None, getItemImage)
        self.getItemImage_nsprefix_ = None
        self.getItemID = _cast(None, getItemID)
        self.getItemID_nsprefix_ = None
        self.sizeString = _cast(None, sizeString)
        self.sizeString_nsprefix_ = None
        self.invalidateContentOnDrop = _cast(bool, invalidateContentOnDrop)
        self.invalidateContentOnDrop_nsprefix_ = None
        if item is None:
            self.item = []
        else:
            self.item = item
        self.item_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_ComboBox)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_ComboBox.subclass:
            return CT_ComboBox.subclass(*args_, **kwargs_)
        else:
            return CT_ComboBox(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_item(self):
        return self.item
    def set_item(self, item):
        self.item = item
    def add_item(self, value):
        self.item.append(value)
    def insert_item_at(self, index, value):
        self.item.insert(index, value)
    def replace_item_at(self, index, value):
        self.item[index] = value
    def get_showItemImage(self):
        return self.showItemImage
    def set_showItemImage(self, showItemImage):
        self.showItemImage = showItemImage
    def get_getItemCount(self):
        return self.getItemCount
    def set_getItemCount(self, getItemCount):
        self.getItemCount = getItemCount
    def get_getItemLabel(self):
        return self.getItemLabel
    def set_getItemLabel(self, getItemLabel):
        self.getItemLabel = getItemLabel
    def get_getItemScreentip(self):
        return self.getItemScreentip
    def set_getItemScreentip(self, getItemScreentip):
        self.getItemScreentip = getItemScreentip
    def get_getItemSupertip(self):
        return self.getItemSupertip
    def set_getItemSupertip(self, getItemSupertip):
        self.getItemSupertip = getItemSupertip
    def get_getItemImage(self):
        return self.getItemImage
    def set_getItemImage(self, getItemImage):
        self.getItemImage = getItemImage
    def get_getItemID(self):
        return self.getItemID
    def set_getItemID(self, getItemID):
        self.getItemID = getItemID
    def get_sizeString(self):
        return self.sizeString
    def set_sizeString(self, sizeString):
        self.sizeString = sizeString
    def get_invalidateContentOnDrop(self):
        return self.invalidateContentOnDrop
    def set_invalidateContentOnDrop(self, invalidateContentOnDrop):
        self.invalidateContentOnDrop = invalidateContentOnDrop
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.item or
            super(CT_ComboBox, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_ComboBox', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_ComboBox')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_ComboBox')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_ComboBox', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_ComboBox'):
        super(CT_ComboBox, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_ComboBox')
        if self.showItemImage is not None and 'showItemImage' not in already_processed:
            already_processed.add('showItemImage')
            outfile.write(' showItemImage="%s"' % self.gds_format_boolean(self.showItemImage, input_name='showItemImage'))
        if self.getItemCount is not None and 'getItemCount' not in already_processed:
            already_processed.add('getItemCount')
            outfile.write(' getItemCount=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getItemCount), input_name='getItemCount')), ))
        if self.getItemLabel is not None and 'getItemLabel' not in already_processed:
            already_processed.add('getItemLabel')
            outfile.write(' getItemLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getItemLabel), input_name='getItemLabel')), ))
        if self.getItemScreentip is not None and 'getItemScreentip' not in already_processed:
            already_processed.add('getItemScreentip')
            outfile.write(' getItemScreentip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getItemScreentip), input_name='getItemScreentip')), ))
        if self.getItemSupertip is not None and 'getItemSupertip' not in already_processed:
            already_processed.add('getItemSupertip')
            outfile.write(' getItemSupertip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getItemSupertip), input_name='getItemSupertip')), ))
        if self.getItemImage is not None and 'getItemImage' not in already_processed:
            already_processed.add('getItemImage')
            outfile.write(' getItemImage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getItemImage), input_name='getItemImage')), ))
        if self.getItemID is not None and 'getItemID' not in already_processed:
            already_processed.add('getItemID')
            outfile.write(' getItemID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getItemID), input_name='getItemID')), ))
        if self.sizeString is not None and 'sizeString' not in already_processed:
            already_processed.add('sizeString')
            outfile.write(' sizeString=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sizeString), input_name='sizeString')), ))
        if self.invalidateContentOnDrop is not None and 'invalidateContentOnDrop' not in already_processed:
            already_processed.add('invalidateContentOnDrop')
            outfile.write(' invalidateContentOnDrop="%s"' % self.gds_format_boolean(self.invalidateContentOnDrop, input_name='invalidateContentOnDrop'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_ComboBox', fromsubclass_=False, pretty_print=True):
        super(CT_ComboBox, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for item_ in self.item:
            namespaceprefix_ = self.item_nsprefix_ + ':' if (UseCapturedNS_ and self.item_nsprefix_) else ''
            item_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='item', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('showItemImage', node)
        if value is not None and 'showItemImage' not in already_processed:
            already_processed.add('showItemImage')
            if value in ('true', '1'):
                self.showItemImage = True
            elif value in ('false', '0'):
                self.showItemImage = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getItemCount', node)
        if value is not None and 'getItemCount' not in already_processed:
            already_processed.add('getItemCount')
            self.getItemCount = value
            self.validate_ST_Delegate(self.getItemCount)    # validate type ST_Delegate
        value = find_attr_value_('getItemLabel', node)
        if value is not None and 'getItemLabel' not in already_processed:
            already_processed.add('getItemLabel')
            self.getItemLabel = value
            self.validate_ST_Delegate(self.getItemLabel)    # validate type ST_Delegate
        value = find_attr_value_('getItemScreentip', node)
        if value is not None and 'getItemScreentip' not in already_processed:
            already_processed.add('getItemScreentip')
            self.getItemScreentip = value
            self.validate_ST_Delegate(self.getItemScreentip)    # validate type ST_Delegate
        value = find_attr_value_('getItemSupertip', node)
        if value is not None and 'getItemSupertip' not in already_processed:
            already_processed.add('getItemSupertip')
            self.getItemSupertip = value
            self.validate_ST_Delegate(self.getItemSupertip)    # validate type ST_Delegate
        value = find_attr_value_('getItemImage', node)
        if value is not None and 'getItemImage' not in already_processed:
            already_processed.add('getItemImage')
            self.getItemImage = value
            self.validate_ST_Delegate(self.getItemImage)    # validate type ST_Delegate
        value = find_attr_value_('getItemID', node)
        if value is not None and 'getItemID' not in already_processed:
            already_processed.add('getItemID')
            self.getItemID = value
            self.validate_ST_Delegate(self.getItemID)    # validate type ST_Delegate
        value = find_attr_value_('sizeString', node)
        if value is not None and 'sizeString' not in already_processed:
            already_processed.add('sizeString')
            self.sizeString = value
            self.validate_ST_String(self.sizeString)    # validate type ST_String
        value = find_attr_value_('invalidateContentOnDrop', node)
        if value is not None and 'invalidateContentOnDrop' not in already_processed:
            already_processed.add('invalidateContentOnDrop')
            if value in ('true', '1'):
                self.invalidateContentOnDrop = True
            elif value in ('false', '0'):
                self.invalidateContentOnDrop = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(CT_ComboBox, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'item':
            obj_ = CT_Item.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'item'
        super(CT_ComboBox, self).buildChildren(child_, node, nodeName_, True)
# end class CT_ComboBox


class CT_DropDownRegular(CT_Control):
    """Specifies a drop-down control type with a fixed-size.
    Contains options followed by buttons. Order is important - buttons last.
    OnAction reports the selected option.
    Specifies a callback which returns the ID of currently selected item.
    Specifies a callback which returns the index of currently selected item.
    Specifies if the label is shown or hidden on dropdown items."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_Control
    def __init__(self, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, enabled=None, getEnabled=None, label=None, getLabel=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, keytip=None, getKeytip=None, showLabel=None, getShowLabel=None, showImage=None, getShowImage=None, id=None, idQ=None, tag=None, idMso=None, getSelectedItemID=None, getSelectedItemIndex=None, showItemLabel=None, onAction=None, showItemImage=None, getItemCount=None, getItemLabel=None, getItemScreentip=None, getItemSupertip=None, getItemImage=None, getItemID=None, sizeString=None, item=None, button=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_DropDownRegular, self).__init__(image, imageMso, getImage, screentip, getScreentip, supertip, getSupertip, enabled, getEnabled, label, getLabel, insertAfterMso, insertBeforeMso, insertAfterQ, insertBeforeQ, visible, getVisible, keytip, getKeytip, showLabel, getShowLabel, showImage, getShowImage, id, idQ, tag, idMso, extensiontype_,  **kwargs_)
        self.getSelectedItemID = _cast(None, getSelectedItemID)
        self.getSelectedItemID_nsprefix_ = None
        self.getSelectedItemIndex = _cast(None, getSelectedItemIndex)
        self.getSelectedItemIndex_nsprefix_ = None
        self.showItemLabel = _cast(bool, showItemLabel)
        self.showItemLabel_nsprefix_ = None
        self.onAction = _cast(None, onAction)
        self.onAction_nsprefix_ = None
        self.enabled = _cast(bool, enabled)
        self.enabled_nsprefix_ = None
        self.getEnabled = _cast(None, getEnabled)
        self.getEnabled_nsprefix_ = None
        self.image = _cast(None, image)
        self.image_nsprefix_ = None
        self.imageMso = _cast(None, imageMso)
        self.imageMso_nsprefix_ = None
        self.getImage = _cast(None, getImage)
        self.getImage_nsprefix_ = None
        self.showItemImage = _cast(bool, showItemImage)
        self.showItemImage_nsprefix_ = None
        self.getItemCount = _cast(None, getItemCount)
        self.getItemCount_nsprefix_ = None
        self.getItemLabel = _cast(None, getItemLabel)
        self.getItemLabel_nsprefix_ = None
        self.getItemScreentip = _cast(None, getItemScreentip)
        self.getItemScreentip_nsprefix_ = None
        self.getItemSupertip = _cast(None, getItemSupertip)
        self.getItemSupertip_nsprefix_ = None
        self.getItemImage = _cast(None, getItemImage)
        self.getItemImage_nsprefix_ = None
        self.getItemID = _cast(None, getItemID)
        self.getItemID_nsprefix_ = None
        self.sizeString = _cast(None, sizeString)
        self.sizeString_nsprefix_ = None
        if item is None:
            self.item = []
        else:
            self.item = item
        self.item_nsprefix_ = None
        if button is None:
            self.button = []
        else:
            self.button = button
        self.button_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_DropDownRegular)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_DropDownRegular.subclass:
            return CT_DropDownRegular.subclass(*args_, **kwargs_)
        else:
            return CT_DropDownRegular(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_item(self):
        return self.item
    def set_item(self, item):
        self.item = item
    def add_item(self, value):
        self.item.append(value)
    def insert_item_at(self, index, value):
        self.item.insert(index, value)
    def replace_item_at(self, index, value):
        self.item[index] = value
    def get_button(self):
        return self.button
    def set_button(self, button):
        self.button = button
    def add_button(self, value):
        self.button.append(value)
    def insert_button_at(self, index, value):
        self.button.insert(index, value)
    def replace_button_at(self, index, value):
        self.button[index] = value
    def get_getSelectedItemID(self):
        return self.getSelectedItemID
    def set_getSelectedItemID(self, getSelectedItemID):
        self.getSelectedItemID = getSelectedItemID
    def get_getSelectedItemIndex(self):
        return self.getSelectedItemIndex
    def set_getSelectedItemIndex(self, getSelectedItemIndex):
        self.getSelectedItemIndex = getSelectedItemIndex
    def get_showItemLabel(self):
        return self.showItemLabel
    def set_showItemLabel(self, showItemLabel):
        self.showItemLabel = showItemLabel
    def get_onAction(self):
        return self.onAction
    def set_onAction(self, onAction):
        self.onAction = onAction
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    def get_getEnabled(self):
        return self.getEnabled
    def set_getEnabled(self, getEnabled):
        self.getEnabled = getEnabled
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def get_imageMso(self):
        return self.imageMso
    def set_imageMso(self, imageMso):
        self.imageMso = imageMso
    def get_getImage(self):
        return self.getImage
    def set_getImage(self, getImage):
        self.getImage = getImage
    def get_showItemImage(self):
        return self.showItemImage
    def set_showItemImage(self, showItemImage):
        self.showItemImage = showItemImage
    def get_getItemCount(self):
        return self.getItemCount
    def set_getItemCount(self, getItemCount):
        self.getItemCount = getItemCount
    def get_getItemLabel(self):
        return self.getItemLabel
    def set_getItemLabel(self, getItemLabel):
        self.getItemLabel = getItemLabel
    def get_getItemScreentip(self):
        return self.getItemScreentip
    def set_getItemScreentip(self, getItemScreentip):
        self.getItemScreentip = getItemScreentip
    def get_getItemSupertip(self):
        return self.getItemSupertip
    def set_getItemSupertip(self, getItemSupertip):
        self.getItemSupertip = getItemSupertip
    def get_getItemImage(self):
        return self.getItemImage
    def set_getItemImage(self, getItemImage):
        self.getItemImage = getItemImage
    def get_getItemID(self):
        return self.getItemID
    def set_getItemID(self, getItemID):
        self.getItemID = getItemID
    def get_sizeString(self):
        return self.sizeString
    def set_sizeString(self, sizeString):
        self.sizeString = sizeString
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Uri(self, value):
        # Validate type ST_Uri, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Uri' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Uri' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.item or
            self.button or
            super(CT_DropDownRegular, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_DropDownRegular', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_DropDownRegular')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_DropDownRegular')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_DropDownRegular', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_DropDownRegular'):
        super(CT_DropDownRegular, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_DropDownRegular')
        if self.getSelectedItemID is not None and 'getSelectedItemID' not in already_processed:
            already_processed.add('getSelectedItemID')
            outfile.write(' getSelectedItemID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getSelectedItemID), input_name='getSelectedItemID')), ))
        if self.getSelectedItemIndex is not None and 'getSelectedItemIndex' not in already_processed:
            already_processed.add('getSelectedItemIndex')
            outfile.write(' getSelectedItemIndex=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getSelectedItemIndex), input_name='getSelectedItemIndex')), ))
        if self.showItemLabel is not None and 'showItemLabel' not in already_processed:
            already_processed.add('showItemLabel')
            outfile.write(' showItemLabel="%s"' % self.gds_format_boolean(self.showItemLabel, input_name='showItemLabel'))
        if self.onAction is not None and 'onAction' not in already_processed:
            already_processed.add('onAction')
            outfile.write(' onAction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.onAction), input_name='onAction')), ))
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            outfile.write(' enabled="%s"' % self.gds_format_boolean(self.enabled, input_name='enabled'))
        if self.getEnabled is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            outfile.write(' getEnabled=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getEnabled), input_name='getEnabled')), ))
        if self.image is not None and 'image' not in already_processed:
            already_processed.add('image')
            outfile.write(' image=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.image), input_name='image')), ))
        if self.imageMso is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            outfile.write(' imageMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.imageMso), input_name='imageMso')), ))
        if self.getImage is not None and 'getImage' not in already_processed:
            already_processed.add('getImage')
            outfile.write(' getImage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getImage), input_name='getImage')), ))
        if self.showItemImage is not None and 'showItemImage' not in already_processed:
            already_processed.add('showItemImage')
            outfile.write(' showItemImage="%s"' % self.gds_format_boolean(self.showItemImage, input_name='showItemImage'))
        if self.getItemCount is not None and 'getItemCount' not in already_processed:
            already_processed.add('getItemCount')
            outfile.write(' getItemCount=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getItemCount), input_name='getItemCount')), ))
        if self.getItemLabel is not None and 'getItemLabel' not in already_processed:
            already_processed.add('getItemLabel')
            outfile.write(' getItemLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getItemLabel), input_name='getItemLabel')), ))
        if self.getItemScreentip is not None and 'getItemScreentip' not in already_processed:
            already_processed.add('getItemScreentip')
            outfile.write(' getItemScreentip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getItemScreentip), input_name='getItemScreentip')), ))
        if self.getItemSupertip is not None and 'getItemSupertip' not in already_processed:
            already_processed.add('getItemSupertip')
            outfile.write(' getItemSupertip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getItemSupertip), input_name='getItemSupertip')), ))
        if self.getItemImage is not None and 'getItemImage' not in already_processed:
            already_processed.add('getItemImage')
            outfile.write(' getItemImage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getItemImage), input_name='getItemImage')), ))
        if self.getItemID is not None and 'getItemID' not in already_processed:
            already_processed.add('getItemID')
            outfile.write(' getItemID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getItemID), input_name='getItemID')), ))
        if self.sizeString is not None and 'sizeString' not in already_processed:
            already_processed.add('sizeString')
            outfile.write(' sizeString=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sizeString), input_name='sizeString')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_DropDownRegular', fromsubclass_=False, pretty_print=True):
        super(CT_DropDownRegular, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for item_ in self.item:
            namespaceprefix_ = self.item_nsprefix_ + ':' if (UseCapturedNS_ and self.item_nsprefix_) else ''
            item_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='item', pretty_print=pretty_print)
        for button_ in self.button:
            namespaceprefix_ = self.button_nsprefix_ + ':' if (UseCapturedNS_ and self.button_nsprefix_) else ''
            button_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='button', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('getSelectedItemID', node)
        if value is not None and 'getSelectedItemID' not in already_processed:
            already_processed.add('getSelectedItemID')
            self.getSelectedItemID = value
            self.validate_ST_Delegate(self.getSelectedItemID)    # validate type ST_Delegate
        value = find_attr_value_('getSelectedItemIndex', node)
        if value is not None and 'getSelectedItemIndex' not in already_processed:
            already_processed.add('getSelectedItemIndex')
            self.getSelectedItemIndex = value
            self.validate_ST_Delegate(self.getSelectedItemIndex)    # validate type ST_Delegate
        value = find_attr_value_('showItemLabel', node)
        if value is not None and 'showItemLabel' not in already_processed:
            already_processed.add('showItemLabel')
            if value in ('true', '1'):
                self.showItemLabel = True
            elif value in ('false', '0'):
                self.showItemLabel = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('onAction', node)
        if value is not None and 'onAction' not in already_processed:
            already_processed.add('onAction')
            self.onAction = value
            self.validate_ST_Delegate(self.onAction)    # validate type ST_Delegate
        value = find_attr_value_('enabled', node)
        if value is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            if value in ('true', '1'):
                self.enabled = True
            elif value in ('false', '0'):
                self.enabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getEnabled', node)
        if value is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            self.getEnabled = value
            self.validate_ST_Delegate(self.getEnabled)    # validate type ST_Delegate
        value = find_attr_value_('image', node)
        if value is not None and 'image' not in already_processed:
            already_processed.add('image')
            self.image = value
            self.validate_ST_Uri(self.image)    # validate type ST_Uri
        value = find_attr_value_('imageMso', node)
        if value is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            self.imageMso = value
            self.validate_ST_ID(self.imageMso)    # validate type ST_ID
        value = find_attr_value_('getImage', node)
        if value is not None and 'getImage' not in already_processed:
            already_processed.add('getImage')
            self.getImage = value
            self.validate_ST_Delegate(self.getImage)    # validate type ST_Delegate
        value = find_attr_value_('showItemImage', node)
        if value is not None and 'showItemImage' not in already_processed:
            already_processed.add('showItemImage')
            if value in ('true', '1'):
                self.showItemImage = True
            elif value in ('false', '0'):
                self.showItemImage = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getItemCount', node)
        if value is not None and 'getItemCount' not in already_processed:
            already_processed.add('getItemCount')
            self.getItemCount = value
            self.validate_ST_Delegate(self.getItemCount)    # validate type ST_Delegate
        value = find_attr_value_('getItemLabel', node)
        if value is not None and 'getItemLabel' not in already_processed:
            already_processed.add('getItemLabel')
            self.getItemLabel = value
            self.validate_ST_Delegate(self.getItemLabel)    # validate type ST_Delegate
        value = find_attr_value_('getItemScreentip', node)
        if value is not None and 'getItemScreentip' not in already_processed:
            already_processed.add('getItemScreentip')
            self.getItemScreentip = value
            self.validate_ST_Delegate(self.getItemScreentip)    # validate type ST_Delegate
        value = find_attr_value_('getItemSupertip', node)
        if value is not None and 'getItemSupertip' not in already_processed:
            already_processed.add('getItemSupertip')
            self.getItemSupertip = value
            self.validate_ST_Delegate(self.getItemSupertip)    # validate type ST_Delegate
        value = find_attr_value_('getItemImage', node)
        if value is not None and 'getItemImage' not in already_processed:
            already_processed.add('getItemImage')
            self.getItemImage = value
            self.validate_ST_Delegate(self.getItemImage)    # validate type ST_Delegate
        value = find_attr_value_('getItemID', node)
        if value is not None and 'getItemID' not in already_processed:
            already_processed.add('getItemID')
            self.getItemID = value
            self.validate_ST_Delegate(self.getItemID)    # validate type ST_Delegate
        value = find_attr_value_('sizeString', node)
        if value is not None and 'sizeString' not in already_processed:
            already_processed.add('sizeString')
            self.sizeString = value
            self.validate_ST_String(self.sizeString)    # validate type ST_String
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CT_DropDownRegular, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'item':
            obj_ = CT_Item.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'item'
        elif nodeName_ == 'button':
            class_obj_ = self.get_class_obj_(child_, CT_ButtonRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.button.append(obj_)
            obj_.original_tagname_ = 'button'
        super(CT_DropDownRegular, self).buildChildren(child_, node, nodeName_, True)
# end class CT_DropDownRegular


class CT_GalleryRegular(CT_DropDownRegular):
    """Specifies a drop-down grid control that can be sized.
    Specifies number of columns in dropdown gallery.
    Specifies number of rows in dropdown gallery.
    Specifies item width in pixels.
    Specifies item height in pixels.
    Specifies a callback which returns the item width.
    Specifies a callback which returns the item height.
    Specifies if the label is shown or hidden on gallery items.
    Specifies whether the gallery should be shown in-ribbon. This attribute
    is not supported in Ribbon Extensibility documents."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_DropDownRegular
    def __init__(self, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, enabled=None, getEnabled=None, label=None, getLabel=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, keytip=None, getKeytip=None, showLabel=None, getShowLabel=None, showImage=None, getShowImage=None, id=None, idQ=None, tag=None, idMso=None, getSelectedItemID=None, getSelectedItemIndex=None, showItemLabel=None, onAction=None, showItemImage=None, getItemCount=None, getItemLabel=None, getItemScreentip=None, getItemSupertip=None, getItemImage=None, getItemID=None, sizeString=None, item=None, button=None, columns=None, rows=None, itemWidth=None, itemHeight=None, getItemWidth=None, getItemHeight=None, showInRibbon=None, description=None, getDescription=None, invalidateContentOnDrop=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_GalleryRegular, self).__init__(image, imageMso, getImage, screentip, getScreentip, supertip, getSupertip, enabled, getEnabled, label, getLabel, insertAfterMso, insertBeforeMso, insertAfterQ, insertBeforeQ, visible, getVisible, keytip, getKeytip, showLabel, getShowLabel, showImage, getShowImage, id, idQ, tag, idMso, getSelectedItemID, getSelectedItemIndex, showItemLabel, onAction, showItemImage, getItemCount, getItemLabel, getItemScreentip, getItemSupertip, getItemImage, getItemID, sizeString, item, button, extensiontype_,  **kwargs_)
        self.columns = _cast(int, columns)
        self.columns_nsprefix_ = None
        self.rows = _cast(int, rows)
        self.rows_nsprefix_ = None
        self.itemWidth = _cast(int, itemWidth)
        self.itemWidth_nsprefix_ = None
        self.itemHeight = _cast(int, itemHeight)
        self.itemHeight_nsprefix_ = None
        self.getItemWidth = _cast(None, getItemWidth)
        self.getItemWidth_nsprefix_ = None
        self.getItemHeight = _cast(None, getItemHeight)
        self.getItemHeight_nsprefix_ = None
        self.showItemLabel = _cast(bool, showItemLabel)
        self.showItemLabel_nsprefix_ = None
        self.showInRibbon = _cast(None, showInRibbon)
        self.showInRibbon_nsprefix_ = None
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
        self.getDescription = _cast(None, getDescription)
        self.getDescription_nsprefix_ = None
        self.invalidateContentOnDrop = _cast(bool, invalidateContentOnDrop)
        self.invalidateContentOnDrop_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_GalleryRegular)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_GalleryRegular.subclass:
            return CT_GalleryRegular.subclass(*args_, **kwargs_)
        else:
            return CT_GalleryRegular(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_columns(self):
        return self.columns
    def set_columns(self, columns):
        self.columns = columns
    def get_rows(self):
        return self.rows
    def set_rows(self, rows):
        self.rows = rows
    def get_itemWidth(self):
        return self.itemWidth
    def set_itemWidth(self, itemWidth):
        self.itemWidth = itemWidth
    def get_itemHeight(self):
        return self.itemHeight
    def set_itemHeight(self, itemHeight):
        self.itemHeight = itemHeight
    def get_getItemWidth(self):
        return self.getItemWidth
    def set_getItemWidth(self, getItemWidth):
        self.getItemWidth = getItemWidth
    def get_getItemHeight(self):
        return self.getItemHeight
    def set_getItemHeight(self, getItemHeight):
        self.getItemHeight = getItemHeight
    def get_showItemLabel(self):
        return self.showItemLabel
    def set_showItemLabel(self, showItemLabel):
        self.showItemLabel = showItemLabel
    def get_showInRibbon(self):
        return self.showInRibbon
    def set_showInRibbon(self, showInRibbon):
        self.showInRibbon = showInRibbon
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_getDescription(self):
        return self.getDescription
    def set_getDescription(self, getDescription):
        self.getDescription = getDescription
    def get_invalidateContentOnDrop(self):
        return self.invalidateContentOnDrop
    def set_invalidateContentOnDrop(self, invalidateContentOnDrop):
        self.invalidateContentOnDrop = invalidateContentOnDrop
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ST_GalleryRowColumnCount(self, value):
        # Validate type ST_GalleryRowColumnCount, a restriction on xsd:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ST_GalleryRowColumnCount' % {"value": value, "lineno": lineno} )
                result = False
            if value > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ST_GalleryRowColumnCount' % {"value": value, "lineno": lineno} )
                result = False
    def validate_ST_GalleryItemWidthHeight(self, value):
        # Validate type ST_GalleryItemWidthHeight, a restriction on xsd:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ST_GalleryItemWidthHeight' % {"value": value, "lineno": lineno} )
                result = False
            if value > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ST_GalleryItemWidthHeight' % {"value": value, "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_GalleryShowInRibbon(self, value):
        # Validate type ST_GalleryShowInRibbon, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['false', '0']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ST_GalleryShowInRibbon' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_LongString(self, value):
        # Validate type ST_LongString, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_LongString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_LongString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(CT_GalleryRegular, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_GalleryRegular', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_GalleryRegular')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_GalleryRegular')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_GalleryRegular', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_GalleryRegular'):
        super(CT_GalleryRegular, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_GalleryRegular')
        if self.columns is not None and 'columns' not in already_processed:
            already_processed.add('columns')
            outfile.write(' columns="%s"' % self.gds_format_integer(self.columns, input_name='columns'))
        if self.rows is not None and 'rows' not in already_processed:
            already_processed.add('rows')
            outfile.write(' rows="%s"' % self.gds_format_integer(self.rows, input_name='rows'))
        if self.itemWidth is not None and 'itemWidth' not in already_processed:
            already_processed.add('itemWidth')
            outfile.write(' itemWidth="%s"' % self.gds_format_integer(self.itemWidth, input_name='itemWidth'))
        if self.itemHeight is not None and 'itemHeight' not in already_processed:
            already_processed.add('itemHeight')
            outfile.write(' itemHeight="%s"' % self.gds_format_integer(self.itemHeight, input_name='itemHeight'))
        if self.getItemWidth is not None and 'getItemWidth' not in already_processed:
            already_processed.add('getItemWidth')
            outfile.write(' getItemWidth=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getItemWidth), input_name='getItemWidth')), ))
        if self.getItemHeight is not None and 'getItemHeight' not in already_processed:
            already_processed.add('getItemHeight')
            outfile.write(' getItemHeight=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getItemHeight), input_name='getItemHeight')), ))
        if self.showItemLabel is not None and 'showItemLabel' not in already_processed:
            already_processed.add('showItemLabel')
            outfile.write(' showItemLabel="%s"' % self.gds_format_boolean(self.showItemLabel, input_name='showItemLabel'))
        if self.showInRibbon is not None and 'showInRibbon' not in already_processed:
            already_processed.add('showInRibbon')
            outfile.write(' showInRibbon=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.showInRibbon), input_name='showInRibbon')), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.getDescription is not None and 'getDescription' not in already_processed:
            already_processed.add('getDescription')
            outfile.write(' getDescription=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getDescription), input_name='getDescription')), ))
        if self.invalidateContentOnDrop is not None and 'invalidateContentOnDrop' not in already_processed:
            already_processed.add('invalidateContentOnDrop')
            outfile.write(' invalidateContentOnDrop="%s"' % self.gds_format_boolean(self.invalidateContentOnDrop, input_name='invalidateContentOnDrop'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_GalleryRegular', fromsubclass_=False, pretty_print=True):
        super(CT_GalleryRegular, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('columns', node)
        if value is not None and 'columns' not in already_processed:
            already_processed.add('columns')
            self.columns = self.gds_parse_integer(value, node, 'columns')
            if self.columns <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_ST_GalleryRowColumnCount(self.columns)    # validate type ST_GalleryRowColumnCount
        value = find_attr_value_('rows', node)
        if value is not None and 'rows' not in already_processed:
            already_processed.add('rows')
            self.rows = self.gds_parse_integer(value, node, 'rows')
            if self.rows <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_ST_GalleryRowColumnCount(self.rows)    # validate type ST_GalleryRowColumnCount
        value = find_attr_value_('itemWidth', node)
        if value is not None and 'itemWidth' not in already_processed:
            already_processed.add('itemWidth')
            self.itemWidth = self.gds_parse_integer(value, node, 'itemWidth')
            if self.itemWidth <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_ST_GalleryItemWidthHeight(self.itemWidth)    # validate type ST_GalleryItemWidthHeight
        value = find_attr_value_('itemHeight', node)
        if value is not None and 'itemHeight' not in already_processed:
            already_processed.add('itemHeight')
            self.itemHeight = self.gds_parse_integer(value, node, 'itemHeight')
            if self.itemHeight <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_ST_GalleryItemWidthHeight(self.itemHeight)    # validate type ST_GalleryItemWidthHeight
        value = find_attr_value_('getItemWidth', node)
        if value is not None and 'getItemWidth' not in already_processed:
            already_processed.add('getItemWidth')
            self.getItemWidth = value
            self.validate_ST_Delegate(self.getItemWidth)    # validate type ST_Delegate
        value = find_attr_value_('getItemHeight', node)
        if value is not None and 'getItemHeight' not in already_processed:
            already_processed.add('getItemHeight')
            self.getItemHeight = value
            self.validate_ST_Delegate(self.getItemHeight)    # validate type ST_Delegate
        value = find_attr_value_('showItemLabel', node)
        if value is not None and 'showItemLabel' not in already_processed:
            already_processed.add('showItemLabel')
            if value in ('true', '1'):
                self.showItemLabel = True
            elif value in ('false', '0'):
                self.showItemLabel = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('showInRibbon', node)
        if value is not None and 'showInRibbon' not in already_processed:
            already_processed.add('showInRibbon')
            self.showInRibbon = value
            self.validate_ST_GalleryShowInRibbon(self.showInRibbon)    # validate type ST_GalleryShowInRibbon
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
            self.validate_ST_LongString(self.description)    # validate type ST_LongString
        value = find_attr_value_('getDescription', node)
        if value is not None and 'getDescription' not in already_processed:
            already_processed.add('getDescription')
            self.getDescription = value
            self.validate_ST_Delegate(self.getDescription)    # validate type ST_Delegate
        value = find_attr_value_('invalidateContentOnDrop', node)
        if value is not None and 'invalidateContentOnDrop' not in already_processed:
            already_processed.add('invalidateContentOnDrop')
            if value in ('true', '1'):
                self.invalidateContentOnDrop = True
            elif value in ('false', '0'):
                self.invalidateContentOnDrop = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CT_GalleryRegular, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CT_GalleryRegular, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CT_GalleryRegular


class CT_Gallery(CT_GalleryRegular):
    """Gallery - choose one option from a grid of options."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_GalleryRegular
    def __init__(self, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, enabled=None, getEnabled=None, label=None, getLabel=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, keytip=None, getKeytip=None, showLabel=None, getShowLabel=None, showImage=None, getShowImage=None, id=None, idQ=None, tag=None, idMso=None, getSelectedItemID=None, getSelectedItemIndex=None, showItemLabel=None, onAction=None, showItemImage=None, getItemCount=None, getItemLabel=None, getItemScreentip=None, getItemSupertip=None, getItemImage=None, getItemID=None, sizeString=None, item=None, button=None, columns=None, rows=None, itemWidth=None, itemHeight=None, getItemWidth=None, getItemHeight=None, showInRibbon=None, description=None, getDescription=None, invalidateContentOnDrop=None, size=None, getSize=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_Gallery, self).__init__(image, imageMso, getImage, screentip, getScreentip, supertip, getSupertip, enabled, getEnabled, label, getLabel, insertAfterMso, insertBeforeMso, insertAfterQ, insertBeforeQ, visible, getVisible, keytip, getKeytip, showLabel, getShowLabel, showImage, getShowImage, id, idQ, tag, idMso, getSelectedItemID, getSelectedItemIndex, showItemLabel, onAction, showItemImage, getItemCount, getItemLabel, getItemScreentip, getItemSupertip, getItemImage, getItemID, sizeString, item, button, columns, rows, itemWidth, itemHeight, getItemWidth, getItemHeight, showInRibbon, description, getDescription, invalidateContentOnDrop,  **kwargs_)
        self.size = _cast(None, size)
        self.size_nsprefix_ = None
        self.getSize = _cast(None, getSize)
        self.getSize_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_Gallery)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_Gallery.subclass:
            return CT_Gallery.subclass(*args_, **kwargs_)
        else:
            return CT_Gallery(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    def get_getSize(self):
        return self.getSize
    def set_getSize(self, getSize):
        self.getSize = getSize
    def validate_ST_Size(self, value):
        # Validate type ST_Size, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'large']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ST_Size' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(CT_Gallery, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_Gallery', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_Gallery')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_Gallery')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_Gallery', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_Gallery'):
        super(CT_Gallery, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_Gallery')
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.size), input_name='size')), ))
        if self.getSize is not None and 'getSize' not in already_processed:
            already_processed.add('getSize')
            outfile.write(' getSize=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getSize), input_name='getSize')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_Gallery', fromsubclass_=False, pretty_print=True):
        super(CT_Gallery, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            self.size = value
            self.validate_ST_Size(self.size)    # validate type ST_Size
        value = find_attr_value_('getSize', node)
        if value is not None and 'getSize' not in already_processed:
            already_processed.add('getSize')
            self.getSize = value
            self.validate_ST_Delegate(self.getSize)    # validate type ST_Delegate
        super(CT_Gallery, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CT_Gallery, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CT_Gallery


class CT_MenuRegular(CT_ControlBase):
    """Specifies a menu with a fixed-size button.
    Contains one or more controls or other Menus.
    Specifies size of menu items."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_ControlBase
    def __init__(self, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, enabled=None, getEnabled=None, label=None, getLabel=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, keytip=None, getKeytip=None, showLabel=None, getShowLabel=None, showImage=None, getShowImage=None, itemSize=None, description=None, getDescription=None, id=None, idQ=None, tag=None, idMso=None, control=None, button=None, checkBox=None, gallery=None, toggleButton=None, menuSeparator=None, splitButton=None, menu=None, dynamicMenu=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_MenuRegular, self).__init__(image, imageMso, getImage, screentip, getScreentip, supertip, getSupertip, enabled, getEnabled, label, getLabel, insertAfterMso, insertBeforeMso, insertAfterQ, insertBeforeQ, visible, getVisible, keytip, getKeytip, showLabel, getShowLabel, showImage, getShowImage, extensiontype_,  **kwargs_)
        self.itemSize = _cast(None, itemSize)
        self.itemSize_nsprefix_ = None
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
        self.getDescription = _cast(None, getDescription)
        self.getDescription_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.idMso = _cast(None, idMso)
        self.idMso_nsprefix_ = None
        if control is None:
            self.control = []
        else:
            self.control = control
        self.control_nsprefix_ = None
        if button is None:
            self.button = []
        else:
            self.button = button
        self.button_nsprefix_ = None
        if checkBox is None:
            self.checkBox = []
        else:
            self.checkBox = checkBox
        self.checkBox_nsprefix_ = None
        if gallery is None:
            self.gallery = []
        else:
            self.gallery = gallery
        self.gallery_nsprefix_ = None
        if toggleButton is None:
            self.toggleButton = []
        else:
            self.toggleButton = toggleButton
        self.toggleButton_nsprefix_ = None
        if menuSeparator is None:
            self.menuSeparator = []
        else:
            self.menuSeparator = menuSeparator
        self.menuSeparator_nsprefix_ = None
        if splitButton is None:
            self.splitButton = []
        else:
            self.splitButton = splitButton
        self.splitButton_nsprefix_ = None
        if menu is None:
            self.menu = []
        else:
            self.menu = menu
        self.menu_nsprefix_ = None
        if dynamicMenu is None:
            self.dynamicMenu = []
        else:
            self.dynamicMenu = dynamicMenu
        self.dynamicMenu_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_MenuRegular)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_MenuRegular.subclass:
            return CT_MenuRegular.subclass(*args_, **kwargs_)
        else:
            return CT_MenuRegular(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_control(self):
        return self.control
    def set_control(self, control):
        self.control = control
    def add_control(self, value):
        self.control.append(value)
    def insert_control_at(self, index, value):
        self.control.insert(index, value)
    def replace_control_at(self, index, value):
        self.control[index] = value
    def get_button(self):
        return self.button
    def set_button(self, button):
        self.button = button
    def add_button(self, value):
        self.button.append(value)
    def insert_button_at(self, index, value):
        self.button.insert(index, value)
    def replace_button_at(self, index, value):
        self.button[index] = value
    def get_checkBox(self):
        return self.checkBox
    def set_checkBox(self, checkBox):
        self.checkBox = checkBox
    def add_checkBox(self, value):
        self.checkBox.append(value)
    def insert_checkBox_at(self, index, value):
        self.checkBox.insert(index, value)
    def replace_checkBox_at(self, index, value):
        self.checkBox[index] = value
    def get_gallery(self):
        return self.gallery
    def set_gallery(self, gallery):
        self.gallery = gallery
    def add_gallery(self, value):
        self.gallery.append(value)
    def insert_gallery_at(self, index, value):
        self.gallery.insert(index, value)
    def replace_gallery_at(self, index, value):
        self.gallery[index] = value
    def get_toggleButton(self):
        return self.toggleButton
    def set_toggleButton(self, toggleButton):
        self.toggleButton = toggleButton
    def add_toggleButton(self, value):
        self.toggleButton.append(value)
    def insert_toggleButton_at(self, index, value):
        self.toggleButton.insert(index, value)
    def replace_toggleButton_at(self, index, value):
        self.toggleButton[index] = value
    def get_menuSeparator(self):
        return self.menuSeparator
    def set_menuSeparator(self, menuSeparator):
        self.menuSeparator = menuSeparator
    def add_menuSeparator(self, value):
        self.menuSeparator.append(value)
    def insert_menuSeparator_at(self, index, value):
        self.menuSeparator.insert(index, value)
    def replace_menuSeparator_at(self, index, value):
        self.menuSeparator[index] = value
    def get_splitButton(self):
        return self.splitButton
    def set_splitButton(self, splitButton):
        self.splitButton = splitButton
    def add_splitButton(self, value):
        self.splitButton.append(value)
    def insert_splitButton_at(self, index, value):
        self.splitButton.insert(index, value)
    def replace_splitButton_at(self, index, value):
        self.splitButton[index] = value
    def get_menu(self):
        return self.menu
    def set_menu(self, menu):
        self.menu = menu
    def add_menu(self, value):
        self.menu.append(value)
    def insert_menu_at(self, index, value):
        self.menu.insert(index, value)
    def replace_menu_at(self, index, value):
        self.menu[index] = value
    def get_dynamicMenu(self):
        return self.dynamicMenu
    def set_dynamicMenu(self, dynamicMenu):
        self.dynamicMenu = dynamicMenu
    def add_dynamicMenu(self, value):
        self.dynamicMenu.append(value)
    def insert_dynamicMenu_at(self, index, value):
        self.dynamicMenu.insert(index, value)
    def replace_dynamicMenu_at(self, index, value):
        self.dynamicMenu[index] = value
    def get_itemSize(self):
        return self.itemSize
    def set_itemSize(self, itemSize):
        self.itemSize = itemSize
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_getDescription(self):
        return self.getDescription
    def set_getDescription(self, getDescription):
        self.getDescription = getDescription
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_idMso(self):
        return self.idMso
    def set_idMso(self, idMso):
        self.idMso = idMso
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ST_ItemSize(self, value):
        # Validate type ST_ItemSize, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'large']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ST_ItemSize' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_LongString(self, value):
        # Validate type ST_LongString, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_LongString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_LongString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.control or
            self.button or
            self.checkBox or
            self.gallery or
            self.toggleButton or
            self.menuSeparator or
            self.splitButton or
            self.menu or
            self.dynamicMenu or
            super(CT_MenuRegular, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_MenuRegular', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_MenuRegular')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_MenuRegular')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_MenuRegular', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_MenuRegular'):
        super(CT_MenuRegular, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_MenuRegular')
        if self.itemSize is not None and 'itemSize' not in already_processed:
            already_processed.add('itemSize')
            outfile.write(' itemSize=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.itemSize), input_name='itemSize')), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.getDescription is not None and 'getDescription' not in already_processed:
            already_processed.add('getDescription')
            outfile.write(' getDescription=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getDescription), input_name='getDescription')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.idMso is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            outfile.write(' idMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idMso), input_name='idMso')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_MenuRegular', fromsubclass_=False, pretty_print=True):
        super(CT_MenuRegular, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for control_ in self.control:
            namespaceprefix_ = self.control_nsprefix_ + ':' if (UseCapturedNS_ and self.control_nsprefix_) else ''
            control_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='control', pretty_print=pretty_print)
        for button_ in self.button:
            namespaceprefix_ = self.button_nsprefix_ + ':' if (UseCapturedNS_ and self.button_nsprefix_) else ''
            button_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='button', pretty_print=pretty_print)
        for checkBox_ in self.checkBox:
            namespaceprefix_ = self.checkBox_nsprefix_ + ':' if (UseCapturedNS_ and self.checkBox_nsprefix_) else ''
            checkBox_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='checkBox', pretty_print=pretty_print)
        for gallery_ in self.gallery:
            namespaceprefix_ = self.gallery_nsprefix_ + ':' if (UseCapturedNS_ and self.gallery_nsprefix_) else ''
            gallery_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='gallery', pretty_print=pretty_print)
        for toggleButton_ in self.toggleButton:
            namespaceprefix_ = self.toggleButton_nsprefix_ + ':' if (UseCapturedNS_ and self.toggleButton_nsprefix_) else ''
            toggleButton_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='toggleButton', pretty_print=pretty_print)
        for menuSeparator_ in self.menuSeparator:
            namespaceprefix_ = self.menuSeparator_nsprefix_ + ':' if (UseCapturedNS_ and self.menuSeparator_nsprefix_) else ''
            menuSeparator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='menuSeparator', pretty_print=pretty_print)
        for splitButton_ in self.splitButton:
            namespaceprefix_ = self.splitButton_nsprefix_ + ':' if (UseCapturedNS_ and self.splitButton_nsprefix_) else ''
            splitButton_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='splitButton', pretty_print=pretty_print)
        for menu_ in self.menu:
            namespaceprefix_ = self.menu_nsprefix_ + ':' if (UseCapturedNS_ and self.menu_nsprefix_) else ''
            menu_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='menu', pretty_print=pretty_print)
        for dynamicMenu_ in self.dynamicMenu:
            namespaceprefix_ = self.dynamicMenu_nsprefix_ + ':' if (UseCapturedNS_ and self.dynamicMenu_nsprefix_) else ''
            dynamicMenu_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dynamicMenu', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('itemSize', node)
        if value is not None and 'itemSize' not in already_processed:
            already_processed.add('itemSize')
            self.itemSize = value
            self.validate_ST_ItemSize(self.itemSize)    # validate type ST_ItemSize
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
            self.validate_ST_LongString(self.description)    # validate type ST_LongString
        value = find_attr_value_('getDescription', node)
        if value is not None and 'getDescription' not in already_processed:
            already_processed.add('getDescription')
            self.getDescription = value
            self.validate_ST_Delegate(self.getDescription)    # validate type ST_Delegate
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('idMso', node)
        if value is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            self.idMso = value
            self.validate_ST_ID(self.idMso)    # validate type ST_ID
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CT_MenuRegular, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'control':
            obj_ = CT_ControlCloneRegular.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.control.append(obj_)
            obj_.original_tagname_ = 'control'
        elif nodeName_ == 'button':
            class_obj_ = self.get_class_obj_(child_, CT_ButtonRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.button.append(obj_)
            obj_.original_tagname_ = 'button'
        elif nodeName_ == 'checkBox':
            obj_ = CT_CheckBox.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.checkBox.append(obj_)
            obj_.original_tagname_ = 'checkBox'
        elif nodeName_ == 'gallery':
            class_obj_ = self.get_class_obj_(child_, CT_GalleryRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gallery.append(obj_)
            obj_.original_tagname_ = 'gallery'
        elif nodeName_ == 'toggleButton':
            class_obj_ = self.get_class_obj_(child_, CT_ToggleButtonRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.toggleButton.append(obj_)
            obj_.original_tagname_ = 'toggleButton'
        elif nodeName_ == 'menuSeparator':
            obj_ = CT_MenuSeparator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.menuSeparator.append(obj_)
            obj_.original_tagname_ = 'menuSeparator'
        elif nodeName_ == 'splitButton':
            class_obj_ = self.get_class_obj_(child_, CT_SplitButtonRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.splitButton.append(obj_)
            obj_.original_tagname_ = 'splitButton'
        elif nodeName_ == 'menu':
            class_obj_ = self.get_class_obj_(child_, CT_MenuRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.menu.append(obj_)
            obj_.original_tagname_ = 'menu'
        elif nodeName_ == 'dynamicMenu':
            class_obj_ = self.get_class_obj_(child_, CT_DynamicMenuRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dynamicMenu.append(obj_)
            obj_.original_tagname_ = 'dynamicMenu'
        super(CT_MenuRegular, self).buildChildren(child_, node, nodeName_, True)
# end class CT_MenuRegular


class CT_DynamicMenuRegular(CT_ControlBase):
    """Specifies a dynamic menu with a fixed-size button."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_ControlBase
    def __init__(self, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, enabled=None, getEnabled=None, label=None, getLabel=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, keytip=None, getKeytip=None, showLabel=None, getShowLabel=None, showImage=None, getShowImage=None, description=None, getDescription=None, id=None, idQ=None, tag=None, idMso=None, getContent=None, invalidateContentOnDrop=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_DynamicMenuRegular, self).__init__(image, imageMso, getImage, screentip, getScreentip, supertip, getSupertip, enabled, getEnabled, label, getLabel, insertAfterMso, insertBeforeMso, insertAfterQ, insertBeforeQ, visible, getVisible, keytip, getKeytip, showLabel, getShowLabel, showImage, getShowImage, extensiontype_,  **kwargs_)
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
        self.getDescription = _cast(None, getDescription)
        self.getDescription_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.idMso = _cast(None, idMso)
        self.idMso_nsprefix_ = None
        self.getContent = _cast(None, getContent)
        self.getContent_nsprefix_ = None
        self.invalidateContentOnDrop = _cast(bool, invalidateContentOnDrop)
        self.invalidateContentOnDrop_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_DynamicMenuRegular)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_DynamicMenuRegular.subclass:
            return CT_DynamicMenuRegular.subclass(*args_, **kwargs_)
        else:
            return CT_DynamicMenuRegular(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_getDescription(self):
        return self.getDescription
    def set_getDescription(self, getDescription):
        self.getDescription = getDescription
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_idMso(self):
        return self.idMso
    def set_idMso(self, idMso):
        self.idMso = idMso
    def get_getContent(self):
        return self.getContent
    def set_getContent(self, getContent):
        self.getContent = getContent
    def get_invalidateContentOnDrop(self):
        return self.invalidateContentOnDrop
    def set_invalidateContentOnDrop(self, invalidateContentOnDrop):
        self.invalidateContentOnDrop = invalidateContentOnDrop
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ST_LongString(self, value):
        # Validate type ST_LongString, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_LongString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_LongString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(CT_DynamicMenuRegular, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_DynamicMenuRegular', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_DynamicMenuRegular')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_DynamicMenuRegular')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_DynamicMenuRegular', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_DynamicMenuRegular'):
        super(CT_DynamicMenuRegular, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_DynamicMenuRegular')
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.getDescription is not None and 'getDescription' not in already_processed:
            already_processed.add('getDescription')
            outfile.write(' getDescription=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getDescription), input_name='getDescription')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.idMso is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            outfile.write(' idMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idMso), input_name='idMso')), ))
        if self.getContent is not None and 'getContent' not in already_processed:
            already_processed.add('getContent')
            outfile.write(' getContent=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getContent), input_name='getContent')), ))
        if self.invalidateContentOnDrop is not None and 'invalidateContentOnDrop' not in already_processed:
            already_processed.add('invalidateContentOnDrop')
            outfile.write(' invalidateContentOnDrop="%s"' % self.gds_format_boolean(self.invalidateContentOnDrop, input_name='invalidateContentOnDrop'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_DynamicMenuRegular', fromsubclass_=False, pretty_print=True):
        super(CT_DynamicMenuRegular, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
            self.validate_ST_LongString(self.description)    # validate type ST_LongString
        value = find_attr_value_('getDescription', node)
        if value is not None and 'getDescription' not in already_processed:
            already_processed.add('getDescription')
            self.getDescription = value
            self.validate_ST_Delegate(self.getDescription)    # validate type ST_Delegate
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('idMso', node)
        if value is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            self.idMso = value
            self.validate_ST_ID(self.idMso)    # validate type ST_ID
        value = find_attr_value_('getContent', node)
        if value is not None and 'getContent' not in already_processed:
            already_processed.add('getContent')
            self.getContent = value
            self.validate_ST_Delegate(self.getContent)    # validate type ST_Delegate
        value = find_attr_value_('invalidateContentOnDrop', node)
        if value is not None and 'invalidateContentOnDrop' not in already_processed:
            already_processed.add('invalidateContentOnDrop')
            if value in ('true', '1'):
                self.invalidateContentOnDrop = True
            elif value in ('false', '0'):
                self.invalidateContentOnDrop = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CT_DynamicMenuRegular, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CT_DynamicMenuRegular, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CT_DynamicMenuRegular


class CT_MenuWithTitle(CT_ControlBase):
    """Specifies a menu with a fixed-size button.
    Contains one or more controls or other Menus.
    Implements "Title" property.
    Specifies size of menu items."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_ControlBase
    def __init__(self, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, enabled=None, getEnabled=None, label=None, getLabel=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, keytip=None, getKeytip=None, showLabel=None, getShowLabel=None, showImage=None, getShowImage=None, itemSize=None, id=None, idQ=None, tag=None, idMso=None, title=None, getTitle=None, control=None, button=None, checkBox=None, gallery=None, toggleButton=None, menuSeparator=None, splitButton=None, menu=None, dynamicMenu=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_MenuWithTitle, self).__init__(image, imageMso, getImage, screentip, getScreentip, supertip, getSupertip, enabled, getEnabled, label, getLabel, insertAfterMso, insertBeforeMso, insertAfterQ, insertBeforeQ, visible, getVisible, keytip, getKeytip, showLabel, getShowLabel, showImage, getShowImage,  **kwargs_)
        self.itemSize = _cast(None, itemSize)
        self.itemSize_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.idMso = _cast(None, idMso)
        self.idMso_nsprefix_ = None
        self.title = _cast(None, title)
        self.title_nsprefix_ = None
        self.getTitle = _cast(None, getTitle)
        self.getTitle_nsprefix_ = None
        if control is None:
            self.control = []
        else:
            self.control = control
        self.control_nsprefix_ = None
        if button is None:
            self.button = []
        else:
            self.button = button
        self.button_nsprefix_ = None
        if checkBox is None:
            self.checkBox = []
        else:
            self.checkBox = checkBox
        self.checkBox_nsprefix_ = None
        if gallery is None:
            self.gallery = []
        else:
            self.gallery = gallery
        self.gallery_nsprefix_ = None
        if toggleButton is None:
            self.toggleButton = []
        else:
            self.toggleButton = toggleButton
        self.toggleButton_nsprefix_ = None
        if menuSeparator is None:
            self.menuSeparator = []
        else:
            self.menuSeparator = menuSeparator
        self.menuSeparator_nsprefix_ = None
        if splitButton is None:
            self.splitButton = []
        else:
            self.splitButton = splitButton
        self.splitButton_nsprefix_ = None
        if menu is None:
            self.menu = []
        else:
            self.menu = menu
        self.menu_nsprefix_ = None
        if dynamicMenu is None:
            self.dynamicMenu = []
        else:
            self.dynamicMenu = dynamicMenu
        self.dynamicMenu_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_MenuWithTitle)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_MenuWithTitle.subclass:
            return CT_MenuWithTitle.subclass(*args_, **kwargs_)
        else:
            return CT_MenuWithTitle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_control(self):
        return self.control
    def set_control(self, control):
        self.control = control
    def add_control(self, value):
        self.control.append(value)
    def insert_control_at(self, index, value):
        self.control.insert(index, value)
    def replace_control_at(self, index, value):
        self.control[index] = value
    def get_button(self):
        return self.button
    def set_button(self, button):
        self.button = button
    def add_button(self, value):
        self.button.append(value)
    def insert_button_at(self, index, value):
        self.button.insert(index, value)
    def replace_button_at(self, index, value):
        self.button[index] = value
    def get_checkBox(self):
        return self.checkBox
    def set_checkBox(self, checkBox):
        self.checkBox = checkBox
    def add_checkBox(self, value):
        self.checkBox.append(value)
    def insert_checkBox_at(self, index, value):
        self.checkBox.insert(index, value)
    def replace_checkBox_at(self, index, value):
        self.checkBox[index] = value
    def get_gallery(self):
        return self.gallery
    def set_gallery(self, gallery):
        self.gallery = gallery
    def add_gallery(self, value):
        self.gallery.append(value)
    def insert_gallery_at(self, index, value):
        self.gallery.insert(index, value)
    def replace_gallery_at(self, index, value):
        self.gallery[index] = value
    def get_toggleButton(self):
        return self.toggleButton
    def set_toggleButton(self, toggleButton):
        self.toggleButton = toggleButton
    def add_toggleButton(self, value):
        self.toggleButton.append(value)
    def insert_toggleButton_at(self, index, value):
        self.toggleButton.insert(index, value)
    def replace_toggleButton_at(self, index, value):
        self.toggleButton[index] = value
    def get_menuSeparator(self):
        return self.menuSeparator
    def set_menuSeparator(self, menuSeparator):
        self.menuSeparator = menuSeparator
    def add_menuSeparator(self, value):
        self.menuSeparator.append(value)
    def insert_menuSeparator_at(self, index, value):
        self.menuSeparator.insert(index, value)
    def replace_menuSeparator_at(self, index, value):
        self.menuSeparator[index] = value
    def get_splitButton(self):
        return self.splitButton
    def set_splitButton(self, splitButton):
        self.splitButton = splitButton
    def add_splitButton(self, value):
        self.splitButton.append(value)
    def insert_splitButton_at(self, index, value):
        self.splitButton.insert(index, value)
    def replace_splitButton_at(self, index, value):
        self.splitButton[index] = value
    def get_menu(self):
        return self.menu
    def set_menu(self, menu):
        self.menu = menu
    def add_menu(self, value):
        self.menu.append(value)
    def insert_menu_at(self, index, value):
        self.menu.insert(index, value)
    def replace_menu_at(self, index, value):
        self.menu[index] = value
    def get_dynamicMenu(self):
        return self.dynamicMenu
    def set_dynamicMenu(self, dynamicMenu):
        self.dynamicMenu = dynamicMenu
    def add_dynamicMenu(self, value):
        self.dynamicMenu.append(value)
    def insert_dynamicMenu_at(self, index, value):
        self.dynamicMenu.insert(index, value)
    def replace_dynamicMenu_at(self, index, value):
        self.dynamicMenu[index] = value
    def get_itemSize(self):
        return self.itemSize
    def set_itemSize(self, itemSize):
        self.itemSize = itemSize
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_idMso(self):
        return self.idMso
    def set_idMso(self, idMso):
        self.idMso = idMso
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_getTitle(self):
        return self.getTitle
    def set_getTitle(self, getTitle):
        self.getTitle = getTitle
    def validate_ST_ItemSize(self, value):
        # Validate type ST_ItemSize, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'large']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ST_ItemSize' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.control or
            self.button or
            self.checkBox or
            self.gallery or
            self.toggleButton or
            self.menuSeparator or
            self.splitButton or
            self.menu or
            self.dynamicMenu or
            super(CT_MenuWithTitle, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_MenuWithTitle', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_MenuWithTitle')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_MenuWithTitle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_MenuWithTitle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_MenuWithTitle'):
        super(CT_MenuWithTitle, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_MenuWithTitle')
        if self.itemSize is not None and 'itemSize' not in already_processed:
            already_processed.add('itemSize')
            outfile.write(' itemSize=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.itemSize), input_name='itemSize')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.idMso is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            outfile.write(' idMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idMso), input_name='idMso')), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.title), input_name='title')), ))
        if self.getTitle is not None and 'getTitle' not in already_processed:
            already_processed.add('getTitle')
            outfile.write(' getTitle=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getTitle), input_name='getTitle')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_MenuWithTitle', fromsubclass_=False, pretty_print=True):
        super(CT_MenuWithTitle, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for control_ in self.control:
            namespaceprefix_ = self.control_nsprefix_ + ':' if (UseCapturedNS_ and self.control_nsprefix_) else ''
            control_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='control', pretty_print=pretty_print)
        for button_ in self.button:
            namespaceprefix_ = self.button_nsprefix_ + ':' if (UseCapturedNS_ and self.button_nsprefix_) else ''
            button_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='button', pretty_print=pretty_print)
        for checkBox_ in self.checkBox:
            namespaceprefix_ = self.checkBox_nsprefix_ + ':' if (UseCapturedNS_ and self.checkBox_nsprefix_) else ''
            checkBox_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='checkBox', pretty_print=pretty_print)
        for gallery_ in self.gallery:
            namespaceprefix_ = self.gallery_nsprefix_ + ':' if (UseCapturedNS_ and self.gallery_nsprefix_) else ''
            gallery_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='gallery', pretty_print=pretty_print)
        for toggleButton_ in self.toggleButton:
            namespaceprefix_ = self.toggleButton_nsprefix_ + ':' if (UseCapturedNS_ and self.toggleButton_nsprefix_) else ''
            toggleButton_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='toggleButton', pretty_print=pretty_print)
        for menuSeparator_ in self.menuSeparator:
            namespaceprefix_ = self.menuSeparator_nsprefix_ + ':' if (UseCapturedNS_ and self.menuSeparator_nsprefix_) else ''
            menuSeparator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='menuSeparator', pretty_print=pretty_print)
        for splitButton_ in self.splitButton:
            namespaceprefix_ = self.splitButton_nsprefix_ + ':' if (UseCapturedNS_ and self.splitButton_nsprefix_) else ''
            splitButton_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='splitButton', pretty_print=pretty_print)
        for menu_ in self.menu:
            namespaceprefix_ = self.menu_nsprefix_ + ':' if (UseCapturedNS_ and self.menu_nsprefix_) else ''
            menu_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='menu', pretty_print=pretty_print)
        for dynamicMenu_ in self.dynamicMenu:
            namespaceprefix_ = self.dynamicMenu_nsprefix_ + ':' if (UseCapturedNS_ and self.dynamicMenu_nsprefix_) else ''
            dynamicMenu_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dynamicMenu', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('itemSize', node)
        if value is not None and 'itemSize' not in already_processed:
            already_processed.add('itemSize')
            self.itemSize = value
            self.validate_ST_ItemSize(self.itemSize)    # validate type ST_ItemSize
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('idMso', node)
        if value is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            self.idMso = value
            self.validate_ST_ID(self.idMso)    # validate type ST_ID
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
            self.validate_ST_String(self.title)    # validate type ST_String
        value = find_attr_value_('getTitle', node)
        if value is not None and 'getTitle' not in already_processed:
            already_processed.add('getTitle')
            self.getTitle = value
            self.validate_ST_Delegate(self.getTitle)    # validate type ST_Delegate
        super(CT_MenuWithTitle, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'control':
            obj_ = CT_ControlCloneRegular.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.control.append(obj_)
            obj_.original_tagname_ = 'control'
        elif nodeName_ == 'button':
            class_obj_ = self.get_class_obj_(child_, CT_ButtonRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.button.append(obj_)
            obj_.original_tagname_ = 'button'
        elif nodeName_ == 'checkBox':
            obj_ = CT_CheckBox.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.checkBox.append(obj_)
            obj_.original_tagname_ = 'checkBox'
        elif nodeName_ == 'gallery':
            class_obj_ = self.get_class_obj_(child_, CT_GalleryRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gallery.append(obj_)
            obj_.original_tagname_ = 'gallery'
        elif nodeName_ == 'toggleButton':
            class_obj_ = self.get_class_obj_(child_, CT_ToggleButtonRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.toggleButton.append(obj_)
            obj_.original_tagname_ = 'toggleButton'
        elif nodeName_ == 'menuSeparator':
            obj_ = CT_MenuSeparator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.menuSeparator.append(obj_)
            obj_.original_tagname_ = 'menuSeparator'
        elif nodeName_ == 'splitButton':
            obj_ = CT_SplitButtonWithTitle.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.splitButton.append(obj_)
            obj_.original_tagname_ = 'splitButton'
        elif nodeName_ == 'menu':
            obj_ = CT_MenuWithTitle.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.menu.append(obj_)
            obj_.original_tagname_ = 'menu'
        elif nodeName_ == 'dynamicMenu':
            class_obj_ = self.get_class_obj_(child_, CT_DynamicMenuRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dynamicMenu.append(obj_)
            obj_.original_tagname_ = 'dynamicMenu'
        super(CT_MenuWithTitle, self).buildChildren(child_, node, nodeName_, True)
# end class CT_MenuWithTitle


class CT_Menu(CT_MenuRegular):
    """Specifies a menu with a button that can be sized.
    Contains one or more controls or other Menus.
    Specifies size of menu items. Large menu items show their description
    property."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_MenuRegular
    def __init__(self, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, enabled=None, getEnabled=None, label=None, getLabel=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, keytip=None, getKeytip=None, showLabel=None, getShowLabel=None, showImage=None, getShowImage=None, itemSize=None, description=None, getDescription=None, id=None, idQ=None, tag=None, idMso=None, control=None, button=None, checkBox=None, gallery=None, toggleButton=None, menuSeparator=None, splitButton=None, menu=None, dynamicMenu=None, size=None, getSize=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_Menu, self).__init__(image, imageMso, getImage, screentip, getScreentip, supertip, getSupertip, enabled, getEnabled, label, getLabel, insertAfterMso, insertBeforeMso, insertAfterQ, insertBeforeQ, visible, getVisible, keytip, getKeytip, showLabel, getShowLabel, showImage, getShowImage, itemSize, description, getDescription, id, idQ, tag, idMso, control, button, checkBox, gallery, toggleButton, menuSeparator, splitButton, menu, dynamicMenu,  **kwargs_)
        self.itemSize = _cast(None, itemSize)
        self.itemSize_nsprefix_ = None
        self.size = _cast(None, size)
        self.size_nsprefix_ = None
        self.getSize = _cast(None, getSize)
        self.getSize_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_Menu)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_Menu.subclass:
            return CT_Menu.subclass(*args_, **kwargs_)
        else:
            return CT_Menu(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_itemSize(self):
        return self.itemSize
    def set_itemSize(self, itemSize):
        self.itemSize = itemSize
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    def get_getSize(self):
        return self.getSize
    def set_getSize(self, getSize):
        self.getSize = getSize
    def validate_ST_ItemSize(self, value):
        # Validate type ST_ItemSize, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'large']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ST_ItemSize' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Size(self, value):
        # Validate type ST_Size, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'large']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ST_Size' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(CT_Menu, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_Menu', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_Menu')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_Menu')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_Menu', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_Menu'):
        super(CT_Menu, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_Menu')
        if self.itemSize is not None and 'itemSize' not in already_processed:
            already_processed.add('itemSize')
            outfile.write(' itemSize=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.itemSize), input_name='itemSize')), ))
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.size), input_name='size')), ))
        if self.getSize is not None and 'getSize' not in already_processed:
            already_processed.add('getSize')
            outfile.write(' getSize=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getSize), input_name='getSize')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_Menu', fromsubclass_=False, pretty_print=True):
        super(CT_Menu, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('itemSize', node)
        if value is not None and 'itemSize' not in already_processed:
            already_processed.add('itemSize')
            self.itemSize = value
            self.validate_ST_ItemSize(self.itemSize)    # validate type ST_ItemSize
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            self.size = value
            self.validate_ST_Size(self.size)    # validate type ST_Size
        value = find_attr_value_('getSize', node)
        if value is not None and 'getSize' not in already_processed:
            already_processed.add('getSize')
            self.getSize = value
            self.validate_ST_Delegate(self.getSize)    # validate type ST_Delegate
        super(CT_Menu, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CT_Menu, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CT_Menu


class CT_DynamicMenu(CT_DynamicMenuRegular):
    """Specifies a dynamic menu with a button that can be sized.
    Contains one or more controls or other Menus."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_DynamicMenuRegular
    def __init__(self, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, enabled=None, getEnabled=None, label=None, getLabel=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, keytip=None, getKeytip=None, showLabel=None, getShowLabel=None, showImage=None, getShowImage=None, description=None, getDescription=None, id=None, idQ=None, tag=None, idMso=None, getContent=None, invalidateContentOnDrop=None, size=None, getSize=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_DynamicMenu, self).__init__(image, imageMso, getImage, screentip, getScreentip, supertip, getSupertip, enabled, getEnabled, label, getLabel, insertAfterMso, insertBeforeMso, insertAfterQ, insertBeforeQ, visible, getVisible, keytip, getKeytip, showLabel, getShowLabel, showImage, getShowImage, description, getDescription, id, idQ, tag, idMso, getContent, invalidateContentOnDrop,  **kwargs_)
        self.size = _cast(None, size)
        self.size_nsprefix_ = None
        self.getSize = _cast(None, getSize)
        self.getSize_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_DynamicMenu)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_DynamicMenu.subclass:
            return CT_DynamicMenu.subclass(*args_, **kwargs_)
        else:
            return CT_DynamicMenu(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    def get_getSize(self):
        return self.getSize
    def set_getSize(self, getSize):
        self.getSize = getSize
    def validate_ST_Size(self, value):
        # Validate type ST_Size, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'large']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ST_Size' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(CT_DynamicMenu, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_DynamicMenu', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_DynamicMenu')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_DynamicMenu')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_DynamicMenu', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_DynamicMenu'):
        super(CT_DynamicMenu, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_DynamicMenu')
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.size), input_name='size')), ))
        if self.getSize is not None and 'getSize' not in already_processed:
            already_processed.add('getSize')
            outfile.write(' getSize=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getSize), input_name='getSize')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_DynamicMenu', fromsubclass_=False, pretty_print=True):
        super(CT_DynamicMenu, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            self.size = value
            self.validate_ST_Size(self.size)    # validate type ST_Size
        value = find_attr_value_('getSize', node)
        if value is not None and 'getSize' not in already_processed:
            already_processed.add('getSize')
            self.getSize = value
            self.validate_ST_Delegate(self.getSize)    # validate type ST_Delegate
        super(CT_DynamicMenu, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CT_DynamicMenu, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CT_DynamicMenu


class CT_SplitButtonBase(CT_Control):
    """Specifies a split button (button type or menu) with a fixed-size.
    Split button contains one button (or toggle button) and one menu.
    Abstract type."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_Control
    def __init__(self, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, enabled=None, getEnabled=None, label=None, getLabel=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, keytip=None, getKeytip=None, showLabel=None, getShowLabel=None, showImage=None, getShowImage=None, id=None, idQ=None, tag=None, idMso=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_SplitButtonBase, self).__init__(image, imageMso, getImage, screentip, getScreentip, supertip, getSupertip, enabled, getEnabled, label, getLabel, insertAfterMso, insertBeforeMso, insertAfterQ, insertBeforeQ, visible, getVisible, keytip, getKeytip, showLabel, getShowLabel, showImage, getShowImage, id, idQ, tag, idMso,  **kwargs_)
        self.enabled = _cast(bool, enabled)
        self.enabled_nsprefix_ = None
        self.getEnabled = _cast(None, getEnabled)
        self.getEnabled_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_SplitButtonBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_SplitButtonBase.subclass:
            return CT_SplitButtonBase.subclass(*args_, **kwargs_)
        else:
            return CT_SplitButtonBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    def get_getEnabled(self):
        return self.getEnabled
    def set_getEnabled(self, getEnabled):
        self.getEnabled = getEnabled
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(CT_SplitButtonBase, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_SplitButtonBase', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_SplitButtonBase')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_SplitButtonBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_SplitButtonBase', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_SplitButtonBase'):
        super(CT_SplitButtonBase, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_SplitButtonBase')
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            outfile.write(' enabled="%s"' % self.gds_format_boolean(self.enabled, input_name='enabled'))
        if self.getEnabled is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            outfile.write(' getEnabled=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getEnabled), input_name='getEnabled')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_SplitButtonBase', fromsubclass_=False, pretty_print=True):
        super(CT_SplitButtonBase, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('enabled', node)
        if value is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            if value in ('true', '1'):
                self.enabled = True
            elif value in ('false', '0'):
                self.enabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getEnabled', node)
        if value is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            self.getEnabled = value
            self.validate_ST_Delegate(self.getEnabled)    # validate type ST_Delegate
        super(CT_SplitButtonBase, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CT_SplitButtonBase, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CT_SplitButtonBase


class CT_SplitButtonRestricted(CT_SplitButtonBase):
    """Specifies the properties which are restricted from splitButtons
    because they are inherited from the button inside of the splitButton.
    This property is inherited from the button inside of the splitButton.
    This property is inherited from the button inside of the splitButton.
    This property is inherited from the button inside of the splitButton.
    This property is inherited from the button inside of the splitButton.
    This property is inherited from the button inside of the splitButton.
    This property is inherited from the button inside of the splitButton.
    This property is inherited from the button inside of the splitButton.
    This property is inherited from the button inside of the splitButton.
    This property is inherited from the button inside of the splitButton.
    This property is inherited from the button inside of the splitButton.
    This property is inherited from the button inside of the splitButton."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_SplitButtonBase
    def __init__(self, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, enabled=None, getEnabled=None, label=None, getLabel=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, keytip=None, getKeytip=None, showLabel=None, getShowLabel=None, showImage=None, getShowImage=None, id=None, idQ=None, tag=None, idMso=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_SplitButtonRestricted, self).__init__(image, imageMso, getImage, screentip, getScreentip, supertip, getSupertip, enabled, getEnabled, label, getLabel, insertAfterMso, insertBeforeMso, insertAfterQ, insertBeforeQ, visible, getVisible, keytip, getKeytip, showLabel, getShowLabel, showImage, getShowImage, id, idQ, tag, idMso, extensiontype_,  **kwargs_)
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.getLabel = _cast(None, getLabel)
        self.getLabel_nsprefix_ = None
        self.screentip = _cast(None, screentip)
        self.screentip_nsprefix_ = None
        self.getScreentip = _cast(None, getScreentip)
        self.getScreentip_nsprefix_ = None
        self.supertip = _cast(None, supertip)
        self.supertip_nsprefix_ = None
        self.getSupertip = _cast(None, getSupertip)
        self.getSupertip_nsprefix_ = None
        self.image = _cast(None, image)
        self.image_nsprefix_ = None
        self.imageMso = _cast(None, imageMso)
        self.imageMso_nsprefix_ = None
        self.getImage = _cast(None, getImage)
        self.getImage_nsprefix_ = None
        self.showImage = _cast(None, showImage)
        self.showImage_nsprefix_ = None
        self.getShowImage = _cast(None, getShowImage)
        self.getShowImage_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_SplitButtonRestricted)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_SplitButtonRestricted.subclass:
            return CT_SplitButtonRestricted.subclass(*args_, **kwargs_)
        else:
            return CT_SplitButtonRestricted(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_getLabel(self):
        return self.getLabel
    def set_getLabel(self, getLabel):
        self.getLabel = getLabel
    def get_screentip(self):
        return self.screentip
    def set_screentip(self, screentip):
        self.screentip = screentip
    def get_getScreentip(self):
        return self.getScreentip
    def set_getScreentip(self, getScreentip):
        self.getScreentip = getScreentip
    def get_supertip(self):
        return self.supertip
    def set_supertip(self, supertip):
        self.supertip = supertip
    def get_getSupertip(self):
        return self.getSupertip
    def set_getSupertip(self, getSupertip):
        self.getSupertip = getSupertip
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def get_imageMso(self):
        return self.imageMso
    def set_imageMso(self, imageMso):
        self.imageMso = imageMso
    def get_getImage(self):
        return self.getImage
    def set_getImage(self, getImage):
        self.getImage = getImage
    def get_showImage(self):
        return self.showImage
    def set_showImage(self, showImage):
        self.showImage = showImage
    def get_getShowImage(self):
        return self.getShowImage
    def set_getShowImage(self, getShowImage):
        self.getShowImage = getShowImage
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(CT_SplitButtonRestricted, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_SplitButtonRestricted', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_SplitButtonRestricted')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_SplitButtonRestricted')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_SplitButtonRestricted', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_SplitButtonRestricted'):
        super(CT_SplitButtonRestricted, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_SplitButtonRestricted')
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.getLabel is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            outfile.write(' getLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getLabel), input_name='getLabel')), ))
        if self.screentip is not None and 'screentip' not in already_processed:
            already_processed.add('screentip')
            outfile.write(' screentip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.screentip), input_name='screentip')), ))
        if self.getScreentip is not None and 'getScreentip' not in already_processed:
            already_processed.add('getScreentip')
            outfile.write(' getScreentip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getScreentip), input_name='getScreentip')), ))
        if self.supertip is not None and 'supertip' not in already_processed:
            already_processed.add('supertip')
            outfile.write(' supertip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.supertip), input_name='supertip')), ))
        if self.getSupertip is not None and 'getSupertip' not in already_processed:
            already_processed.add('getSupertip')
            outfile.write(' getSupertip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getSupertip), input_name='getSupertip')), ))
        if self.image is not None and 'image' not in already_processed:
            already_processed.add('image')
            outfile.write(' image=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.image), input_name='image')), ))
        if self.imageMso is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            outfile.write(' imageMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.imageMso), input_name='imageMso')), ))
        if self.getImage is not None and 'getImage' not in already_processed:
            already_processed.add('getImage')
            outfile.write(' getImage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getImage), input_name='getImage')), ))
        if self.showImage is not None and 'showImage' not in already_processed:
            already_processed.add('showImage')
            outfile.write(' showImage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.showImage), input_name='showImage')), ))
        if self.getShowImage is not None and 'getShowImage' not in already_processed:
            already_processed.add('getShowImage')
            outfile.write(' getShowImage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getShowImage), input_name='getShowImage')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_SplitButtonRestricted', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
        value = find_attr_value_('getLabel', node)
        if value is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            self.getLabel = value
        value = find_attr_value_('screentip', node)
        if value is not None and 'screentip' not in already_processed:
            already_processed.add('screentip')
            self.screentip = value
        value = find_attr_value_('getScreentip', node)
        if value is not None and 'getScreentip' not in already_processed:
            already_processed.add('getScreentip')
            self.getScreentip = value
        value = find_attr_value_('supertip', node)
        if value is not None and 'supertip' not in already_processed:
            already_processed.add('supertip')
            self.supertip = value
        value = find_attr_value_('getSupertip', node)
        if value is not None and 'getSupertip' not in already_processed:
            already_processed.add('getSupertip')
            self.getSupertip = value
        value = find_attr_value_('image', node)
        if value is not None and 'image' not in already_processed:
            already_processed.add('image')
            self.image = value
        value = find_attr_value_('imageMso', node)
        if value is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            self.imageMso = value
        value = find_attr_value_('getImage', node)
        if value is not None and 'getImage' not in already_processed:
            already_processed.add('getImage')
            self.getImage = value
        value = find_attr_value_('showImage', node)
        if value is not None and 'showImage' not in already_processed:
            already_processed.add('showImage')
            self.showImage = value
        value = find_attr_value_('getShowImage', node)
        if value is not None and 'getShowImage' not in already_processed:
            already_processed.add('getShowImage')
            self.getShowImage = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CT_SplitButtonRestricted, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CT_SplitButtonRestricted


class CT_SplitButtonRegular(CT_SplitButtonRestricted):
    """Specifies a split button (button type or menu) with a fixed-size.
    Split button contains one button (or toggle button) and one menu."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_SplitButtonRestricted
    def __init__(self, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, enabled=None, getEnabled=None, label=None, getLabel=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, keytip=None, getKeytip=None, showLabel=None, getShowLabel=None, showImage=None, getShowImage=None, id=None, idQ=None, tag=None, idMso=None, button=None, toggleButton=None, menu=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_SplitButtonRegular, self).__init__(image, imageMso, getImage, screentip, getScreentip, supertip, getSupertip, enabled, getEnabled, label, getLabel, insertAfterMso, insertBeforeMso, insertAfterQ, insertBeforeQ, visible, getVisible, keytip, getKeytip, showLabel, getShowLabel, showImage, getShowImage, id, idQ, tag, idMso, extensiontype_,  **kwargs_)
        self.button = button
        self.button_nsprefix_ = None
        self.toggleButton = toggleButton
        self.toggleButton_nsprefix_ = None
        self.menu = menu
        self.menu_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_SplitButtonRegular)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_SplitButtonRegular.subclass:
            return CT_SplitButtonRegular.subclass(*args_, **kwargs_)
        else:
            return CT_SplitButtonRegular(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_button(self):
        return self.button
    def set_button(self, button):
        self.button = button
    def get_toggleButton(self):
        return self.toggleButton
    def set_toggleButton(self, toggleButton):
        self.toggleButton = toggleButton
    def get_menu(self):
        return self.menu
    def set_menu(self, menu):
        self.menu = menu
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.button is not None or
            self.toggleButton is not None or
            self.menu is not None or
            super(CT_SplitButtonRegular, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_SplitButtonRegular', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_SplitButtonRegular')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_SplitButtonRegular')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_SplitButtonRegular', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_SplitButtonRegular'):
        super(CT_SplitButtonRegular, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_SplitButtonRegular')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_SplitButtonRegular', fromsubclass_=False, pretty_print=True):
        super(CT_SplitButtonRegular, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.button is not None:
            namespaceprefix_ = self.button_nsprefix_ + ':' if (UseCapturedNS_ and self.button_nsprefix_) else ''
            self.button.export(outfile, level, namespaceprefix_, namespacedef_='', name_='button', pretty_print=pretty_print)
        if self.toggleButton is not None:
            namespaceprefix_ = self.toggleButton_nsprefix_ + ':' if (UseCapturedNS_ and self.toggleButton_nsprefix_) else ''
            self.toggleButton.export(outfile, level, namespaceprefix_, namespacedef_='', name_='toggleButton', pretty_print=pretty_print)
        if self.menu is not None:
            namespaceprefix_ = self.menu_nsprefix_ + ':' if (UseCapturedNS_ and self.menu_nsprefix_) else ''
            self.menu.export(outfile, level, namespaceprefix_, namespacedef_='', name_='menu', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CT_SplitButtonRegular, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'button':
            obj_ = CT_VisibleButton.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.button = obj_
            obj_.original_tagname_ = 'button'
        elif nodeName_ == 'toggleButton':
            obj_ = CT_VisibleToggleButton.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.toggleButton = obj_
            obj_.original_tagname_ = 'toggleButton'
        elif nodeName_ == 'menu':
            class_obj_ = self.get_class_obj_(child_, CT_MenuRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.menu = obj_
            obj_.original_tagname_ = 'menu'
        super(CT_SplitButtonRegular, self).buildChildren(child_, node, nodeName_, True)
# end class CT_SplitButtonRegular


class CT_SplitButtonWithTitle(CT_SplitButtonRestricted):
    """Specifies a split button (button type or menu) with a fixed-size.
    Split button contains one button (or toggle button) and one menu."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_SplitButtonRestricted
    def __init__(self, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, enabled=None, getEnabled=None, label=None, getLabel=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, keytip=None, getKeytip=None, showLabel=None, getShowLabel=None, showImage=None, getShowImage=None, id=None, idQ=None, tag=None, idMso=None, button=None, toggleButton=None, menu=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_SplitButtonWithTitle, self).__init__(image, imageMso, getImage, screentip, getScreentip, supertip, getSupertip, enabled, getEnabled, label, getLabel, insertAfterMso, insertBeforeMso, insertAfterQ, insertBeforeQ, visible, getVisible, keytip, getKeytip, showLabel, getShowLabel, showImage, getShowImage, id, idQ, tag, idMso,  **kwargs_)
        self.button = button
        self.button_nsprefix_ = None
        self.toggleButton = toggleButton
        self.toggleButton_nsprefix_ = None
        self.menu = menu
        self.menu_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_SplitButtonWithTitle)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_SplitButtonWithTitle.subclass:
            return CT_SplitButtonWithTitle.subclass(*args_, **kwargs_)
        else:
            return CT_SplitButtonWithTitle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_button(self):
        return self.button
    def set_button(self, button):
        self.button = button
    def get_toggleButton(self):
        return self.toggleButton
    def set_toggleButton(self, toggleButton):
        self.toggleButton = toggleButton
    def get_menu(self):
        return self.menu
    def set_menu(self, menu):
        self.menu = menu
    def hasContent_(self):
        if (
            self.button is not None or
            self.toggleButton is not None or
            self.menu is not None or
            super(CT_SplitButtonWithTitle, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_SplitButtonWithTitle', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_SplitButtonWithTitle')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_SplitButtonWithTitle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_SplitButtonWithTitle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_SplitButtonWithTitle'):
        super(CT_SplitButtonWithTitle, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_SplitButtonWithTitle')
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_SplitButtonWithTitle', fromsubclass_=False, pretty_print=True):
        super(CT_SplitButtonWithTitle, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.button is not None:
            namespaceprefix_ = self.button_nsprefix_ + ':' if (UseCapturedNS_ and self.button_nsprefix_) else ''
            self.button.export(outfile, level, namespaceprefix_, namespacedef_='', name_='button', pretty_print=pretty_print)
        if self.toggleButton is not None:
            namespaceprefix_ = self.toggleButton_nsprefix_ + ':' if (UseCapturedNS_ and self.toggleButton_nsprefix_) else ''
            self.toggleButton.export(outfile, level, namespaceprefix_, namespacedef_='', name_='toggleButton', pretty_print=pretty_print)
        if self.menu is not None:
            namespaceprefix_ = self.menu_nsprefix_ + ':' if (UseCapturedNS_ and self.menu_nsprefix_) else ''
            self.menu.export(outfile, level, namespaceprefix_, namespacedef_='', name_='menu', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CT_SplitButtonWithTitle, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'button':
            obj_ = CT_VisibleButton.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.button = obj_
            obj_.original_tagname_ = 'button'
        elif nodeName_ == 'toggleButton':
            obj_ = CT_VisibleToggleButton.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.toggleButton = obj_
            obj_.original_tagname_ = 'toggleButton'
        elif nodeName_ == 'menu':
            obj_ = CT_MenuWithTitle.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.menu = obj_
            obj_.original_tagname_ = 'menu'
        super(CT_SplitButtonWithTitle, self).buildChildren(child_, node, nodeName_, True)
# end class CT_SplitButtonWithTitle


class CT_SplitButton(CT_SplitButtonRegular):
    """Specifies a split button (button type or menu) that can be sized."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_SplitButtonRegular
    def __init__(self, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, enabled=None, getEnabled=None, label=None, getLabel=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, keytip=None, getKeytip=None, showLabel=None, getShowLabel=None, showImage=None, getShowImage=None, id=None, idQ=None, tag=None, idMso=None, button=None, toggleButton=None, menu=None, size=None, getSize=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_SplitButton, self).__init__(image, imageMso, getImage, screentip, getScreentip, supertip, getSupertip, enabled, getEnabled, label, getLabel, insertAfterMso, insertBeforeMso, insertAfterQ, insertBeforeQ, visible, getVisible, keytip, getKeytip, showLabel, getShowLabel, showImage, getShowImage, id, idQ, tag, idMso, button, toggleButton, menu,  **kwargs_)
        self.size = _cast(None, size)
        self.size_nsprefix_ = None
        self.getSize = _cast(None, getSize)
        self.getSize_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_SplitButton)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_SplitButton.subclass:
            return CT_SplitButton.subclass(*args_, **kwargs_)
        else:
            return CT_SplitButton(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    def get_getSize(self):
        return self.getSize
    def set_getSize(self, getSize):
        self.getSize = getSize
    def validate_ST_Size(self, value):
        # Validate type ST_Size, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'large']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ST_Size' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(CT_SplitButton, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_SplitButton', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_SplitButton')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_SplitButton')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_SplitButton', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_SplitButton'):
        super(CT_SplitButton, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_SplitButton')
        if self.size is not None and 'size' not in already_processed:
            already_processed.add('size')
            outfile.write(' size=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.size), input_name='size')), ))
        if self.getSize is not None and 'getSize' not in already_processed:
            already_processed.add('getSize')
            outfile.write(' getSize=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getSize), input_name='getSize')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_SplitButton', fromsubclass_=False, pretty_print=True):
        super(CT_SplitButton, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('size', node)
        if value is not None and 'size' not in already_processed:
            already_processed.add('size')
            self.size = value
            self.validate_ST_Size(self.size)    # validate type ST_Size
        value = find_attr_value_('getSize', node)
        if value is not None and 'getSize' not in already_processed:
            already_processed.add('getSize')
            self.getSize = value
            self.validate_ST_Delegate(self.getSize)    # validate type ST_Delegate
        super(CT_SplitButton, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CT_SplitButton, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CT_SplitButton


class CT_DialogLauncher(GeneratedsSuper):
    """Specifies a dialog launcher with options for the associated group."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, button=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.button = button
        self.button_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_DialogLauncher)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_DialogLauncher.subclass:
            return CT_DialogLauncher.subclass(*args_, **kwargs_)
        else:
            return CT_DialogLauncher(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_button(self):
        return self.button
    def set_button(self, button):
        self.button = button
    def hasContent_(self):
        if (
            self.button is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_DialogLauncher', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_DialogLauncher')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_DialogLauncher')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_DialogLauncher', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_DialogLauncher'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_DialogLauncher', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.button is not None:
            namespaceprefix_ = self.button_nsprefix_ + ':' if (UseCapturedNS_ and self.button_nsprefix_) else ''
            self.button.export(outfile, level, namespaceprefix_, namespacedef_='', name_='button', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'button':
            class_obj_ = self.get_class_obj_(child_, CT_ButtonRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.button = obj_
            obj_.original_tagname_ = 'button'
# end class CT_DialogLauncher


class CT_Box(GeneratedsSuper):
    """Specifies a Box control - a horizontal grouping container.
    Specifies how controls are displayed within the box."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, boxStyle=None, id=None, idQ=None, tag=None, visible=None, getVisible=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, control=None, labelControl=None, button=None, toggleButton=None, checkBox=None, editBox=None, comboBox=None, dropDown=None, gallery=None, menu=None, dynamicMenu=None, splitButton=None, box=None, buttonGroup=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.boxStyle = _cast(None, boxStyle)
        self.boxStyle_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.visible = _cast(bool, visible)
        self.visible_nsprefix_ = None
        self.getVisible = _cast(None, getVisible)
        self.getVisible_nsprefix_ = None
        self.insertAfterMso = _cast(None, insertAfterMso)
        self.insertAfterMso_nsprefix_ = None
        self.insertBeforeMso = _cast(None, insertBeforeMso)
        self.insertBeforeMso_nsprefix_ = None
        self.insertAfterQ = _cast(None, insertAfterQ)
        self.insertAfterQ_nsprefix_ = None
        self.insertBeforeQ = _cast(None, insertBeforeQ)
        self.insertBeforeQ_nsprefix_ = None
        if control is None:
            self.control = []
        else:
            self.control = control
        self.control_nsprefix_ = None
        if labelControl is None:
            self.labelControl = []
        else:
            self.labelControl = labelControl
        self.labelControl_nsprefix_ = None
        if button is None:
            self.button = []
        else:
            self.button = button
        self.button_nsprefix_ = None
        if toggleButton is None:
            self.toggleButton = []
        else:
            self.toggleButton = toggleButton
        self.toggleButton_nsprefix_ = None
        if checkBox is None:
            self.checkBox = []
        else:
            self.checkBox = checkBox
        self.checkBox_nsprefix_ = None
        if editBox is None:
            self.editBox = []
        else:
            self.editBox = editBox
        self.editBox_nsprefix_ = None
        if comboBox is None:
            self.comboBox = []
        else:
            self.comboBox = comboBox
        self.comboBox_nsprefix_ = None
        if dropDown is None:
            self.dropDown = []
        else:
            self.dropDown = dropDown
        self.dropDown_nsprefix_ = None
        if gallery is None:
            self.gallery = []
        else:
            self.gallery = gallery
        self.gallery_nsprefix_ = None
        if menu is None:
            self.menu = []
        else:
            self.menu = menu
        self.menu_nsprefix_ = None
        if dynamicMenu is None:
            self.dynamicMenu = []
        else:
            self.dynamicMenu = dynamicMenu
        self.dynamicMenu_nsprefix_ = None
        if splitButton is None:
            self.splitButton = []
        else:
            self.splitButton = splitButton
        self.splitButton_nsprefix_ = None
        if box is None:
            self.box = []
        else:
            self.box = box
        self.box_nsprefix_ = None
        if buttonGroup is None:
            self.buttonGroup = []
        else:
            self.buttonGroup = buttonGroup
        self.buttonGroup_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_Box)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_Box.subclass:
            return CT_Box.subclass(*args_, **kwargs_)
        else:
            return CT_Box(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_control(self):
        return self.control
    def set_control(self, control):
        self.control = control
    def add_control(self, value):
        self.control.append(value)
    def insert_control_at(self, index, value):
        self.control.insert(index, value)
    def replace_control_at(self, index, value):
        self.control[index] = value
    def get_labelControl(self):
        return self.labelControl
    def set_labelControl(self, labelControl):
        self.labelControl = labelControl
    def add_labelControl(self, value):
        self.labelControl.append(value)
    def insert_labelControl_at(self, index, value):
        self.labelControl.insert(index, value)
    def replace_labelControl_at(self, index, value):
        self.labelControl[index] = value
    def get_button(self):
        return self.button
    def set_button(self, button):
        self.button = button
    def add_button(self, value):
        self.button.append(value)
    def insert_button_at(self, index, value):
        self.button.insert(index, value)
    def replace_button_at(self, index, value):
        self.button[index] = value
    def get_toggleButton(self):
        return self.toggleButton
    def set_toggleButton(self, toggleButton):
        self.toggleButton = toggleButton
    def add_toggleButton(self, value):
        self.toggleButton.append(value)
    def insert_toggleButton_at(self, index, value):
        self.toggleButton.insert(index, value)
    def replace_toggleButton_at(self, index, value):
        self.toggleButton[index] = value
    def get_checkBox(self):
        return self.checkBox
    def set_checkBox(self, checkBox):
        self.checkBox = checkBox
    def add_checkBox(self, value):
        self.checkBox.append(value)
    def insert_checkBox_at(self, index, value):
        self.checkBox.insert(index, value)
    def replace_checkBox_at(self, index, value):
        self.checkBox[index] = value
    def get_editBox(self):
        return self.editBox
    def set_editBox(self, editBox):
        self.editBox = editBox
    def add_editBox(self, value):
        self.editBox.append(value)
    def insert_editBox_at(self, index, value):
        self.editBox.insert(index, value)
    def replace_editBox_at(self, index, value):
        self.editBox[index] = value
    def get_comboBox(self):
        return self.comboBox
    def set_comboBox(self, comboBox):
        self.comboBox = comboBox
    def add_comboBox(self, value):
        self.comboBox.append(value)
    def insert_comboBox_at(self, index, value):
        self.comboBox.insert(index, value)
    def replace_comboBox_at(self, index, value):
        self.comboBox[index] = value
    def get_dropDown(self):
        return self.dropDown
    def set_dropDown(self, dropDown):
        self.dropDown = dropDown
    def add_dropDown(self, value):
        self.dropDown.append(value)
    def insert_dropDown_at(self, index, value):
        self.dropDown.insert(index, value)
    def replace_dropDown_at(self, index, value):
        self.dropDown[index] = value
    def get_gallery(self):
        return self.gallery
    def set_gallery(self, gallery):
        self.gallery = gallery
    def add_gallery(self, value):
        self.gallery.append(value)
    def insert_gallery_at(self, index, value):
        self.gallery.insert(index, value)
    def replace_gallery_at(self, index, value):
        self.gallery[index] = value
    def get_menu(self):
        return self.menu
    def set_menu(self, menu):
        self.menu = menu
    def add_menu(self, value):
        self.menu.append(value)
    def insert_menu_at(self, index, value):
        self.menu.insert(index, value)
    def replace_menu_at(self, index, value):
        self.menu[index] = value
    def get_dynamicMenu(self):
        return self.dynamicMenu
    def set_dynamicMenu(self, dynamicMenu):
        self.dynamicMenu = dynamicMenu
    def add_dynamicMenu(self, value):
        self.dynamicMenu.append(value)
    def insert_dynamicMenu_at(self, index, value):
        self.dynamicMenu.insert(index, value)
    def replace_dynamicMenu_at(self, index, value):
        self.dynamicMenu[index] = value
    def get_splitButton(self):
        return self.splitButton
    def set_splitButton(self, splitButton):
        self.splitButton = splitButton
    def add_splitButton(self, value):
        self.splitButton.append(value)
    def insert_splitButton_at(self, index, value):
        self.splitButton.insert(index, value)
    def replace_splitButton_at(self, index, value):
        self.splitButton[index] = value
    def get_box(self):
        return self.box
    def set_box(self, box):
        self.box = box
    def add_box(self, value):
        self.box.append(value)
    def insert_box_at(self, index, value):
        self.box.insert(index, value)
    def replace_box_at(self, index, value):
        self.box[index] = value
    def get_buttonGroup(self):
        return self.buttonGroup
    def set_buttonGroup(self, buttonGroup):
        self.buttonGroup = buttonGroup
    def add_buttonGroup(self, value):
        self.buttonGroup.append(value)
    def insert_buttonGroup_at(self, index, value):
        self.buttonGroup.insert(index, value)
    def replace_buttonGroup_at(self, index, value):
        self.buttonGroup[index] = value
    def get_boxStyle(self):
        return self.boxStyle
    def set_boxStyle(self, boxStyle):
        self.boxStyle = boxStyle
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_visible(self):
        return self.visible
    def set_visible(self, visible):
        self.visible = visible
    def get_getVisible(self):
        return self.getVisible
    def set_getVisible(self, getVisible):
        self.getVisible = getVisible
    def get_insertAfterMso(self):
        return self.insertAfterMso
    def set_insertAfterMso(self, insertAfterMso):
        self.insertAfterMso = insertAfterMso
    def get_insertBeforeMso(self):
        return self.insertBeforeMso
    def set_insertBeforeMso(self, insertBeforeMso):
        self.insertBeforeMso = insertBeforeMso
    def get_insertAfterQ(self):
        return self.insertAfterQ
    def set_insertAfterQ(self, insertAfterQ):
        self.insertAfterQ = insertAfterQ
    def get_insertBeforeQ(self):
        return self.insertBeforeQ
    def set_insertBeforeQ(self, insertBeforeQ):
        self.insertBeforeQ = insertBeforeQ
    def validate_ST_BoxStyle(self, value):
        # Validate type ST_BoxStyle, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['horizontal', 'vertical']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ST_BoxStyle' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.control or
            self.labelControl or
            self.button or
            self.toggleButton or
            self.checkBox or
            self.editBox or
            self.comboBox or
            self.dropDown or
            self.gallery or
            self.menu or
            self.dynamicMenu or
            self.splitButton or
            self.box or
            self.buttonGroup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_Box', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_Box')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_Box')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_Box', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_Box'):
        if self.boxStyle is not None and 'boxStyle' not in already_processed:
            already_processed.add('boxStyle')
            outfile.write(' boxStyle=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.boxStyle), input_name='boxStyle')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            outfile.write(' visible="%s"' % self.gds_format_boolean(self.visible, input_name='visible'))
        if self.getVisible is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            outfile.write(' getVisible=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getVisible), input_name='getVisible')), ))
        if self.insertAfterMso is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            outfile.write(' insertAfterMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterMso), input_name='insertAfterMso')), ))
        if self.insertBeforeMso is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            outfile.write(' insertBeforeMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeMso), input_name='insertBeforeMso')), ))
        if self.insertAfterQ is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            outfile.write(' insertAfterQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterQ), input_name='insertAfterQ')), ))
        if self.insertBeforeQ is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            outfile.write(' insertBeforeQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeQ), input_name='insertBeforeQ')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_Box', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for control_ in self.control:
            namespaceprefix_ = self.control_nsprefix_ + ':' if (UseCapturedNS_ and self.control_nsprefix_) else ''
            control_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='control', pretty_print=pretty_print)
        for labelControl_ in self.labelControl:
            namespaceprefix_ = self.labelControl_nsprefix_ + ':' if (UseCapturedNS_ and self.labelControl_nsprefix_) else ''
            labelControl_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='labelControl', pretty_print=pretty_print)
        for button_ in self.button:
            namespaceprefix_ = self.button_nsprefix_ + ':' if (UseCapturedNS_ and self.button_nsprefix_) else ''
            button_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='button', pretty_print=pretty_print)
        for toggleButton_ in self.toggleButton:
            namespaceprefix_ = self.toggleButton_nsprefix_ + ':' if (UseCapturedNS_ and self.toggleButton_nsprefix_) else ''
            toggleButton_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='toggleButton', pretty_print=pretty_print)
        for checkBox_ in self.checkBox:
            namespaceprefix_ = self.checkBox_nsprefix_ + ':' if (UseCapturedNS_ and self.checkBox_nsprefix_) else ''
            checkBox_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='checkBox', pretty_print=pretty_print)
        for editBox_ in self.editBox:
            namespaceprefix_ = self.editBox_nsprefix_ + ':' if (UseCapturedNS_ and self.editBox_nsprefix_) else ''
            editBox_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='editBox', pretty_print=pretty_print)
        for comboBox_ in self.comboBox:
            namespaceprefix_ = self.comboBox_nsprefix_ + ':' if (UseCapturedNS_ and self.comboBox_nsprefix_) else ''
            comboBox_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='comboBox', pretty_print=pretty_print)
        for dropDown_ in self.dropDown:
            namespaceprefix_ = self.dropDown_nsprefix_ + ':' if (UseCapturedNS_ and self.dropDown_nsprefix_) else ''
            dropDown_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dropDown', pretty_print=pretty_print)
        for gallery_ in self.gallery:
            namespaceprefix_ = self.gallery_nsprefix_ + ':' if (UseCapturedNS_ and self.gallery_nsprefix_) else ''
            gallery_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='gallery', pretty_print=pretty_print)
        for menu_ in self.menu:
            namespaceprefix_ = self.menu_nsprefix_ + ':' if (UseCapturedNS_ and self.menu_nsprefix_) else ''
            menu_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='menu', pretty_print=pretty_print)
        for dynamicMenu_ in self.dynamicMenu:
            namespaceprefix_ = self.dynamicMenu_nsprefix_ + ':' if (UseCapturedNS_ and self.dynamicMenu_nsprefix_) else ''
            dynamicMenu_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dynamicMenu', pretty_print=pretty_print)
        for splitButton_ in self.splitButton:
            namespaceprefix_ = self.splitButton_nsprefix_ + ':' if (UseCapturedNS_ and self.splitButton_nsprefix_) else ''
            splitButton_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='splitButton', pretty_print=pretty_print)
        for box_ in self.box:
            namespaceprefix_ = self.box_nsprefix_ + ':' if (UseCapturedNS_ and self.box_nsprefix_) else ''
            box_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='box', pretty_print=pretty_print)
        for buttonGroup_ in self.buttonGroup:
            namespaceprefix_ = self.buttonGroup_nsprefix_ + ':' if (UseCapturedNS_ and self.buttonGroup_nsprefix_) else ''
            buttonGroup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='buttonGroup', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('boxStyle', node)
        if value is not None and 'boxStyle' not in already_processed:
            already_processed.add('boxStyle')
            self.boxStyle = value
            self.validate_ST_BoxStyle(self.boxStyle)    # validate type ST_BoxStyle
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            if value in ('true', '1'):
                self.visible = True
            elif value in ('false', '0'):
                self.visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getVisible', node)
        if value is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            self.getVisible = value
            self.validate_ST_Delegate(self.getVisible)    # validate type ST_Delegate
        value = find_attr_value_('insertAfterMso', node)
        if value is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            self.insertAfterMso = value
            self.validate_ST_ID(self.insertAfterMso)    # validate type ST_ID
        value = find_attr_value_('insertBeforeMso', node)
        if value is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            self.insertBeforeMso = value
            self.validate_ST_ID(self.insertBeforeMso)    # validate type ST_ID
        value = find_attr_value_('insertAfterQ', node)
        if value is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            self.insertAfterQ = value
            self.validate_ST_QID(self.insertAfterQ)    # validate type ST_QID
        value = find_attr_value_('insertBeforeQ', node)
        if value is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            self.insertBeforeQ = value
            self.validate_ST_QID(self.insertBeforeQ)    # validate type ST_QID
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'control':
            obj_ = CT_ControlClone.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.control.append(obj_)
            obj_.original_tagname_ = 'control'
        elif nodeName_ == 'labelControl':
            obj_ = CT_LabelControl.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.labelControl.append(obj_)
            obj_.original_tagname_ = 'labelControl'
        elif nodeName_ == 'button':
            obj_ = CT_Button.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.button.append(obj_)
            obj_.original_tagname_ = 'button'
        elif nodeName_ == 'toggleButton':
            obj_ = CT_ToggleButton.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.toggleButton.append(obj_)
            obj_.original_tagname_ = 'toggleButton'
        elif nodeName_ == 'checkBox':
            obj_ = CT_CheckBox.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.checkBox.append(obj_)
            obj_.original_tagname_ = 'checkBox'
        elif nodeName_ == 'editBox':
            class_obj_ = self.get_class_obj_(child_, CT_EditBox)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.editBox.append(obj_)
            obj_.original_tagname_ = 'editBox'
        elif nodeName_ == 'comboBox':
            obj_ = CT_ComboBox.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.comboBox.append(obj_)
            obj_.original_tagname_ = 'comboBox'
        elif nodeName_ == 'dropDown':
            class_obj_ = self.get_class_obj_(child_, CT_DropDownRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dropDown.append(obj_)
            obj_.original_tagname_ = 'dropDown'
        elif nodeName_ == 'gallery':
            obj_ = CT_Gallery.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gallery.append(obj_)
            obj_.original_tagname_ = 'gallery'
        elif nodeName_ == 'menu':
            obj_ = CT_Menu.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.menu.append(obj_)
            obj_.original_tagname_ = 'menu'
        elif nodeName_ == 'dynamicMenu':
            obj_ = CT_DynamicMenu.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dynamicMenu.append(obj_)
            obj_.original_tagname_ = 'dynamicMenu'
        elif nodeName_ == 'splitButton':
            obj_ = CT_SplitButton.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.splitButton.append(obj_)
            obj_.original_tagname_ = 'splitButton'
        elif nodeName_ == 'box':
            obj_ = CT_Box.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.box.append(obj_)
            obj_.original_tagname_ = 'box'
        elif nodeName_ == 'buttonGroup':
            obj_ = CT_ButtonGroup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.buttonGroup.append(obj_)
            obj_.original_tagname_ = 'buttonGroup'
# end class CT_Box


class CT_Separator(GeneratedsSuper):
    """Specifies a control group separator - a vertical bar."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, idQ=None, tag=None, visible=None, getVisible=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.visible = _cast(bool, visible)
        self.visible_nsprefix_ = None
        self.getVisible = _cast(None, getVisible)
        self.getVisible_nsprefix_ = None
        self.insertAfterMso = _cast(None, insertAfterMso)
        self.insertAfterMso_nsprefix_ = None
        self.insertBeforeMso = _cast(None, insertBeforeMso)
        self.insertBeforeMso_nsprefix_ = None
        self.insertAfterQ = _cast(None, insertAfterQ)
        self.insertAfterQ_nsprefix_ = None
        self.insertBeforeQ = _cast(None, insertBeforeQ)
        self.insertBeforeQ_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_Separator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_Separator.subclass:
            return CT_Separator.subclass(*args_, **kwargs_)
        else:
            return CT_Separator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_visible(self):
        return self.visible
    def set_visible(self, visible):
        self.visible = visible
    def get_getVisible(self):
        return self.getVisible
    def set_getVisible(self, getVisible):
        self.getVisible = getVisible
    def get_insertAfterMso(self):
        return self.insertAfterMso
    def set_insertAfterMso(self, insertAfterMso):
        self.insertAfterMso = insertAfterMso
    def get_insertBeforeMso(self):
        return self.insertBeforeMso
    def set_insertBeforeMso(self, insertBeforeMso):
        self.insertBeforeMso = insertBeforeMso
    def get_insertAfterQ(self):
        return self.insertAfterQ
    def set_insertAfterQ(self, insertAfterQ):
        self.insertAfterQ = insertAfterQ
    def get_insertBeforeQ(self):
        return self.insertBeforeQ
    def set_insertBeforeQ(self, insertBeforeQ):
        self.insertBeforeQ = insertBeforeQ
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_Separator', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_Separator')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_Separator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_Separator', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_Separator'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            outfile.write(' visible="%s"' % self.gds_format_boolean(self.visible, input_name='visible'))
        if self.getVisible is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            outfile.write(' getVisible=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getVisible), input_name='getVisible')), ))
        if self.insertAfterMso is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            outfile.write(' insertAfterMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterMso), input_name='insertAfterMso')), ))
        if self.insertBeforeMso is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            outfile.write(' insertBeforeMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeMso), input_name='insertBeforeMso')), ))
        if self.insertAfterQ is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            outfile.write(' insertAfterQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterQ), input_name='insertAfterQ')), ))
        if self.insertBeforeQ is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            outfile.write(' insertBeforeQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeQ), input_name='insertBeforeQ')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_Separator', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            if value in ('true', '1'):
                self.visible = True
            elif value in ('false', '0'):
                self.visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getVisible', node)
        if value is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            self.getVisible = value
            self.validate_ST_Delegate(self.getVisible)    # validate type ST_Delegate
        value = find_attr_value_('insertAfterMso', node)
        if value is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            self.insertAfterMso = value
            self.validate_ST_ID(self.insertAfterMso)    # validate type ST_ID
        value = find_attr_value_('insertBeforeMso', node)
        if value is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            self.insertBeforeMso = value
            self.validate_ST_ID(self.insertBeforeMso)    # validate type ST_ID
        value = find_attr_value_('insertAfterQ', node)
        if value is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            self.insertAfterQ = value
            self.validate_ST_QID(self.insertAfterQ)    # validate type ST_QID
        value = find_attr_value_('insertBeforeQ', node)
        if value is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            self.insertBeforeQ = value
            self.validate_ST_QID(self.insertBeforeQ)    # validate type ST_QID
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CT_Separator


class CT_MenuSeparator(GeneratedsSuper):
    """Specifies a menu separator - a horizontal bar that separates menu
    items."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, idQ=None, tag=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, title=None, getTitle=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.insertAfterMso = _cast(None, insertAfterMso)
        self.insertAfterMso_nsprefix_ = None
        self.insertBeforeMso = _cast(None, insertBeforeMso)
        self.insertBeforeMso_nsprefix_ = None
        self.insertAfterQ = _cast(None, insertAfterQ)
        self.insertAfterQ_nsprefix_ = None
        self.insertBeforeQ = _cast(None, insertBeforeQ)
        self.insertBeforeQ_nsprefix_ = None
        self.title = _cast(None, title)
        self.title_nsprefix_ = None
        self.getTitle = _cast(None, getTitle)
        self.getTitle_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_MenuSeparator)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_MenuSeparator.subclass:
            return CT_MenuSeparator.subclass(*args_, **kwargs_)
        else:
            return CT_MenuSeparator(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_insertAfterMso(self):
        return self.insertAfterMso
    def set_insertAfterMso(self, insertAfterMso):
        self.insertAfterMso = insertAfterMso
    def get_insertBeforeMso(self):
        return self.insertBeforeMso
    def set_insertBeforeMso(self, insertBeforeMso):
        self.insertBeforeMso = insertBeforeMso
    def get_insertAfterQ(self):
        return self.insertAfterQ
    def set_insertAfterQ(self, insertAfterQ):
        self.insertAfterQ = insertAfterQ
    def get_insertBeforeQ(self):
        return self.insertBeforeQ
    def set_insertBeforeQ(self, insertBeforeQ):
        self.insertBeforeQ = insertBeforeQ
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_getTitle(self):
        return self.getTitle
    def set_getTitle(self, getTitle):
        self.getTitle = getTitle
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_MenuSeparator', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_MenuSeparator')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_MenuSeparator')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_MenuSeparator', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_MenuSeparator'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.insertAfterMso is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            outfile.write(' insertAfterMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterMso), input_name='insertAfterMso')), ))
        if self.insertBeforeMso is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            outfile.write(' insertBeforeMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeMso), input_name='insertBeforeMso')), ))
        if self.insertAfterQ is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            outfile.write(' insertAfterQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterQ), input_name='insertAfterQ')), ))
        if self.insertBeforeQ is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            outfile.write(' insertBeforeQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeQ), input_name='insertBeforeQ')), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.title), input_name='title')), ))
        if self.getTitle is not None and 'getTitle' not in already_processed:
            already_processed.add('getTitle')
            outfile.write(' getTitle=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getTitle), input_name='getTitle')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_MenuSeparator', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('insertAfterMso', node)
        if value is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            self.insertAfterMso = value
            self.validate_ST_ID(self.insertAfterMso)    # validate type ST_ID
        value = find_attr_value_('insertBeforeMso', node)
        if value is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            self.insertBeforeMso = value
            self.validate_ST_ID(self.insertBeforeMso)    # validate type ST_ID
        value = find_attr_value_('insertAfterQ', node)
        if value is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            self.insertAfterQ = value
            self.validate_ST_QID(self.insertAfterQ)    # validate type ST_QID
        value = find_attr_value_('insertBeforeQ', node)
        if value is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            self.insertBeforeQ = value
            self.validate_ST_QID(self.insertBeforeQ)    # validate type ST_QID
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
            self.validate_ST_String(self.title)    # validate type ST_String
        value = find_attr_value_('getTitle', node)
        if value is not None and 'getTitle' not in already_processed:
            already_processed.add('getTitle')
            self.getTitle = value
            self.validate_ST_Delegate(self.getTitle)    # validate type ST_Delegate
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CT_MenuSeparator


class CT_MenuSeparatorNoTitle(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, idQ=None, tag=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.insertAfterMso = _cast(None, insertAfterMso)
        self.insertAfterMso_nsprefix_ = None
        self.insertBeforeMso = _cast(None, insertBeforeMso)
        self.insertBeforeMso_nsprefix_ = None
        self.insertAfterQ = _cast(None, insertAfterQ)
        self.insertAfterQ_nsprefix_ = None
        self.insertBeforeQ = _cast(None, insertBeforeQ)
        self.insertBeforeQ_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_MenuSeparatorNoTitle)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_MenuSeparatorNoTitle.subclass:
            return CT_MenuSeparatorNoTitle.subclass(*args_, **kwargs_)
        else:
            return CT_MenuSeparatorNoTitle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_insertAfterMso(self):
        return self.insertAfterMso
    def set_insertAfterMso(self, insertAfterMso):
        self.insertAfterMso = insertAfterMso
    def get_insertBeforeMso(self):
        return self.insertBeforeMso
    def set_insertBeforeMso(self, insertBeforeMso):
        self.insertBeforeMso = insertBeforeMso
    def get_insertAfterQ(self):
        return self.insertAfterQ
    def set_insertAfterQ(self, insertAfterQ):
        self.insertAfterQ = insertAfterQ
    def get_insertBeforeQ(self):
        return self.insertBeforeQ
    def set_insertBeforeQ(self, insertBeforeQ):
        self.insertBeforeQ = insertBeforeQ
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_MenuSeparatorNoTitle', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_MenuSeparatorNoTitle')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_MenuSeparatorNoTitle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_MenuSeparatorNoTitle', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_MenuSeparatorNoTitle'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.insertAfterMso is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            outfile.write(' insertAfterMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterMso), input_name='insertAfterMso')), ))
        if self.insertBeforeMso is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            outfile.write(' insertBeforeMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeMso), input_name='insertBeforeMso')), ))
        if self.insertAfterQ is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            outfile.write(' insertAfterQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterQ), input_name='insertAfterQ')), ))
        if self.insertBeforeQ is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            outfile.write(' insertBeforeQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeQ), input_name='insertBeforeQ')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_MenuSeparatorNoTitle', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('insertAfterMso', node)
        if value is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            self.insertAfterMso = value
            self.validate_ST_ID(self.insertAfterMso)    # validate type ST_ID
        value = find_attr_value_('insertBeforeMso', node)
        if value is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            self.insertBeforeMso = value
            self.validate_ST_ID(self.insertBeforeMso)    # validate type ST_ID
        value = find_attr_value_('insertAfterQ', node)
        if value is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            self.insertAfterQ = value
            self.validate_ST_QID(self.insertAfterQ)    # validate type ST_QID
        value = find_attr_value_('insertBeforeQ', node)
        if value is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            self.insertBeforeQ = value
            self.validate_ST_QID(self.insertBeforeQ)    # validate type ST_QID
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CT_MenuSeparatorNoTitle


class CT_ButtonGroup(GeneratedsSuper):
    """Specifies a ButtonGroup control - a horizontal container with an
    integrated look."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, idQ=None, tag=None, visible=None, getVisible=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, control=None, button=None, toggleButton=None, gallery=None, menu=None, dynamicMenu=None, splitButton=None, separator=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.visible = _cast(bool, visible)
        self.visible_nsprefix_ = None
        self.getVisible = _cast(None, getVisible)
        self.getVisible_nsprefix_ = None
        self.insertAfterMso = _cast(None, insertAfterMso)
        self.insertAfterMso_nsprefix_ = None
        self.insertBeforeMso = _cast(None, insertBeforeMso)
        self.insertBeforeMso_nsprefix_ = None
        self.insertAfterQ = _cast(None, insertAfterQ)
        self.insertAfterQ_nsprefix_ = None
        self.insertBeforeQ = _cast(None, insertBeforeQ)
        self.insertBeforeQ_nsprefix_ = None
        if control is None:
            self.control = []
        else:
            self.control = control
        self.control_nsprefix_ = None
        if button is None:
            self.button = []
        else:
            self.button = button
        self.button_nsprefix_ = None
        if toggleButton is None:
            self.toggleButton = []
        else:
            self.toggleButton = toggleButton
        self.toggleButton_nsprefix_ = None
        if gallery is None:
            self.gallery = []
        else:
            self.gallery = gallery
        self.gallery_nsprefix_ = None
        if menu is None:
            self.menu = []
        else:
            self.menu = menu
        self.menu_nsprefix_ = None
        if dynamicMenu is None:
            self.dynamicMenu = []
        else:
            self.dynamicMenu = dynamicMenu
        self.dynamicMenu_nsprefix_ = None
        if splitButton is None:
            self.splitButton = []
        else:
            self.splitButton = splitButton
        self.splitButton_nsprefix_ = None
        if separator is None:
            self.separator = []
        else:
            self.separator = separator
        self.separator_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_ButtonGroup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_ButtonGroup.subclass:
            return CT_ButtonGroup.subclass(*args_, **kwargs_)
        else:
            return CT_ButtonGroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_control(self):
        return self.control
    def set_control(self, control):
        self.control = control
    def add_control(self, value):
        self.control.append(value)
    def insert_control_at(self, index, value):
        self.control.insert(index, value)
    def replace_control_at(self, index, value):
        self.control[index] = value
    def get_button(self):
        return self.button
    def set_button(self, button):
        self.button = button
    def add_button(self, value):
        self.button.append(value)
    def insert_button_at(self, index, value):
        self.button.insert(index, value)
    def replace_button_at(self, index, value):
        self.button[index] = value
    def get_toggleButton(self):
        return self.toggleButton
    def set_toggleButton(self, toggleButton):
        self.toggleButton = toggleButton
    def add_toggleButton(self, value):
        self.toggleButton.append(value)
    def insert_toggleButton_at(self, index, value):
        self.toggleButton.insert(index, value)
    def replace_toggleButton_at(self, index, value):
        self.toggleButton[index] = value
    def get_gallery(self):
        return self.gallery
    def set_gallery(self, gallery):
        self.gallery = gallery
    def add_gallery(self, value):
        self.gallery.append(value)
    def insert_gallery_at(self, index, value):
        self.gallery.insert(index, value)
    def replace_gallery_at(self, index, value):
        self.gallery[index] = value
    def get_menu(self):
        return self.menu
    def set_menu(self, menu):
        self.menu = menu
    def add_menu(self, value):
        self.menu.append(value)
    def insert_menu_at(self, index, value):
        self.menu.insert(index, value)
    def replace_menu_at(self, index, value):
        self.menu[index] = value
    def get_dynamicMenu(self):
        return self.dynamicMenu
    def set_dynamicMenu(self, dynamicMenu):
        self.dynamicMenu = dynamicMenu
    def add_dynamicMenu(self, value):
        self.dynamicMenu.append(value)
    def insert_dynamicMenu_at(self, index, value):
        self.dynamicMenu.insert(index, value)
    def replace_dynamicMenu_at(self, index, value):
        self.dynamicMenu[index] = value
    def get_splitButton(self):
        return self.splitButton
    def set_splitButton(self, splitButton):
        self.splitButton = splitButton
    def add_splitButton(self, value):
        self.splitButton.append(value)
    def insert_splitButton_at(self, index, value):
        self.splitButton.insert(index, value)
    def replace_splitButton_at(self, index, value):
        self.splitButton[index] = value
    def get_separator(self):
        return self.separator
    def set_separator(self, separator):
        self.separator = separator
    def add_separator(self, value):
        self.separator.append(value)
    def insert_separator_at(self, index, value):
        self.separator.insert(index, value)
    def replace_separator_at(self, index, value):
        self.separator[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_visible(self):
        return self.visible
    def set_visible(self, visible):
        self.visible = visible
    def get_getVisible(self):
        return self.getVisible
    def set_getVisible(self, getVisible):
        self.getVisible = getVisible
    def get_insertAfterMso(self):
        return self.insertAfterMso
    def set_insertAfterMso(self, insertAfterMso):
        self.insertAfterMso = insertAfterMso
    def get_insertBeforeMso(self):
        return self.insertBeforeMso
    def set_insertBeforeMso(self, insertBeforeMso):
        self.insertBeforeMso = insertBeforeMso
    def get_insertAfterQ(self):
        return self.insertAfterQ
    def set_insertAfterQ(self, insertAfterQ):
        self.insertAfterQ = insertAfterQ
    def get_insertBeforeQ(self):
        return self.insertBeforeQ
    def set_insertBeforeQ(self, insertBeforeQ):
        self.insertBeforeQ = insertBeforeQ
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.control or
            self.button or
            self.toggleButton or
            self.gallery or
            self.menu or
            self.dynamicMenu or
            self.splitButton or
            self.separator
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_ButtonGroup', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_ButtonGroup')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_ButtonGroup')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_ButtonGroup', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_ButtonGroup'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            outfile.write(' visible="%s"' % self.gds_format_boolean(self.visible, input_name='visible'))
        if self.getVisible is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            outfile.write(' getVisible=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getVisible), input_name='getVisible')), ))
        if self.insertAfterMso is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            outfile.write(' insertAfterMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterMso), input_name='insertAfterMso')), ))
        if self.insertBeforeMso is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            outfile.write(' insertBeforeMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeMso), input_name='insertBeforeMso')), ))
        if self.insertAfterQ is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            outfile.write(' insertAfterQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterQ), input_name='insertAfterQ')), ))
        if self.insertBeforeQ is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            outfile.write(' insertBeforeQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeQ), input_name='insertBeforeQ')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_ButtonGroup', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for control_ in self.control:
            namespaceprefix_ = self.control_nsprefix_ + ':' if (UseCapturedNS_ and self.control_nsprefix_) else ''
            control_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='control', pretty_print=pretty_print)
        for button_ in self.button:
            namespaceprefix_ = self.button_nsprefix_ + ':' if (UseCapturedNS_ and self.button_nsprefix_) else ''
            button_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='button', pretty_print=pretty_print)
        for toggleButton_ in self.toggleButton:
            namespaceprefix_ = self.toggleButton_nsprefix_ + ':' if (UseCapturedNS_ and self.toggleButton_nsprefix_) else ''
            toggleButton_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='toggleButton', pretty_print=pretty_print)
        for gallery_ in self.gallery:
            namespaceprefix_ = self.gallery_nsprefix_ + ':' if (UseCapturedNS_ and self.gallery_nsprefix_) else ''
            gallery_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='gallery', pretty_print=pretty_print)
        for menu_ in self.menu:
            namespaceprefix_ = self.menu_nsprefix_ + ':' if (UseCapturedNS_ and self.menu_nsprefix_) else ''
            menu_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='menu', pretty_print=pretty_print)
        for dynamicMenu_ in self.dynamicMenu:
            namespaceprefix_ = self.dynamicMenu_nsprefix_ + ':' if (UseCapturedNS_ and self.dynamicMenu_nsprefix_) else ''
            dynamicMenu_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dynamicMenu', pretty_print=pretty_print)
        for splitButton_ in self.splitButton:
            namespaceprefix_ = self.splitButton_nsprefix_ + ':' if (UseCapturedNS_ and self.splitButton_nsprefix_) else ''
            splitButton_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='splitButton', pretty_print=pretty_print)
        for separator_ in self.separator:
            namespaceprefix_ = self.separator_nsprefix_ + ':' if (UseCapturedNS_ and self.separator_nsprefix_) else ''
            separator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='separator', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            if value in ('true', '1'):
                self.visible = True
            elif value in ('false', '0'):
                self.visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getVisible', node)
        if value is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            self.getVisible = value
            self.validate_ST_Delegate(self.getVisible)    # validate type ST_Delegate
        value = find_attr_value_('insertAfterMso', node)
        if value is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            self.insertAfterMso = value
            self.validate_ST_ID(self.insertAfterMso)    # validate type ST_ID
        value = find_attr_value_('insertBeforeMso', node)
        if value is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            self.insertBeforeMso = value
            self.validate_ST_ID(self.insertBeforeMso)    # validate type ST_ID
        value = find_attr_value_('insertAfterQ', node)
        if value is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            self.insertAfterQ = value
            self.validate_ST_QID(self.insertAfterQ)    # validate type ST_QID
        value = find_attr_value_('insertBeforeQ', node)
        if value is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            self.insertBeforeQ = value
            self.validate_ST_QID(self.insertBeforeQ)    # validate type ST_QID
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'control':
            obj_ = CT_ControlCloneRegular.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.control.append(obj_)
            obj_.original_tagname_ = 'control'
        elif nodeName_ == 'button':
            class_obj_ = self.get_class_obj_(child_, CT_ButtonRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.button.append(obj_)
            obj_.original_tagname_ = 'button'
        elif nodeName_ == 'toggleButton':
            class_obj_ = self.get_class_obj_(child_, CT_ToggleButtonRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.toggleButton.append(obj_)
            obj_.original_tagname_ = 'toggleButton'
        elif nodeName_ == 'gallery':
            class_obj_ = self.get_class_obj_(child_, CT_GalleryRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gallery.append(obj_)
            obj_.original_tagname_ = 'gallery'
        elif nodeName_ == 'menu':
            class_obj_ = self.get_class_obj_(child_, CT_MenuRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.menu.append(obj_)
            obj_.original_tagname_ = 'menu'
        elif nodeName_ == 'dynamicMenu':
            class_obj_ = self.get_class_obj_(child_, CT_DynamicMenuRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dynamicMenu.append(obj_)
            obj_.original_tagname_ = 'dynamicMenu'
        elif nodeName_ == 'splitButton':
            class_obj_ = self.get_class_obj_(child_, CT_SplitButtonRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.splitButton.append(obj_)
            obj_.original_tagname_ = 'splitButton'
        elif nodeName_ == 'separator':
            obj_ = CT_Separator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.separator.append(obj_)
            obj_.original_tagname_ = 'separator'
# end class CT_ButtonGroup


class CT_Group(GeneratedsSuper):
    """Specifies a group that contains other control types.
    Specifies whether the group should automatically scale its contents.
    Specifies whether the group's contents should be vertically centered"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, autoScale=None, centerVertically=None, id=None, idQ=None, tag=None, idMso=None, label=None, getLabel=None, image=None, imageMso=None, getImage=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, visible=None, getVisible=None, keytip=None, getKeytip=None, control=None, labelControl=None, button=None, toggleButton=None, checkBox=None, editBox=None, comboBox=None, dropDown=None, gallery=None, menu=None, dynamicMenu=None, splitButton=None, box=None, buttonGroup=None, separator=None, dialogBoxLauncher=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.autoScale = _cast(bool, autoScale)
        self.autoScale_nsprefix_ = None
        self.centerVertically = _cast(bool, centerVertically)
        self.centerVertically_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.idMso = _cast(None, idMso)
        self.idMso_nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.getLabel = _cast(None, getLabel)
        self.getLabel_nsprefix_ = None
        self.image = _cast(None, image)
        self.image_nsprefix_ = None
        self.imageMso = _cast(None, imageMso)
        self.imageMso_nsprefix_ = None
        self.getImage = _cast(None, getImage)
        self.getImage_nsprefix_ = None
        self.insertAfterMso = _cast(None, insertAfterMso)
        self.insertAfterMso_nsprefix_ = None
        self.insertBeforeMso = _cast(None, insertBeforeMso)
        self.insertBeforeMso_nsprefix_ = None
        self.insertAfterQ = _cast(None, insertAfterQ)
        self.insertAfterQ_nsprefix_ = None
        self.insertBeforeQ = _cast(None, insertBeforeQ)
        self.insertBeforeQ_nsprefix_ = None
        self.screentip = _cast(None, screentip)
        self.screentip_nsprefix_ = None
        self.getScreentip = _cast(None, getScreentip)
        self.getScreentip_nsprefix_ = None
        self.supertip = _cast(None, supertip)
        self.supertip_nsprefix_ = None
        self.getSupertip = _cast(None, getSupertip)
        self.getSupertip_nsprefix_ = None
        self.visible = _cast(bool, visible)
        self.visible_nsprefix_ = None
        self.getVisible = _cast(None, getVisible)
        self.getVisible_nsprefix_ = None
        self.keytip = _cast(None, keytip)
        self.keytip_nsprefix_ = None
        self.getKeytip = _cast(None, getKeytip)
        self.getKeytip_nsprefix_ = None
        if control is None:
            self.control = []
        else:
            self.control = control
        self.control_nsprefix_ = None
        if labelControl is None:
            self.labelControl = []
        else:
            self.labelControl = labelControl
        self.labelControl_nsprefix_ = None
        if button is None:
            self.button = []
        else:
            self.button = button
        self.button_nsprefix_ = None
        if toggleButton is None:
            self.toggleButton = []
        else:
            self.toggleButton = toggleButton
        self.toggleButton_nsprefix_ = None
        if checkBox is None:
            self.checkBox = []
        else:
            self.checkBox = checkBox
        self.checkBox_nsprefix_ = None
        if editBox is None:
            self.editBox = []
        else:
            self.editBox = editBox
        self.editBox_nsprefix_ = None
        if comboBox is None:
            self.comboBox = []
        else:
            self.comboBox = comboBox
        self.comboBox_nsprefix_ = None
        if dropDown is None:
            self.dropDown = []
        else:
            self.dropDown = dropDown
        self.dropDown_nsprefix_ = None
        if gallery is None:
            self.gallery = []
        else:
            self.gallery = gallery
        self.gallery_nsprefix_ = None
        if menu is None:
            self.menu = []
        else:
            self.menu = menu
        self.menu_nsprefix_ = None
        if dynamicMenu is None:
            self.dynamicMenu = []
        else:
            self.dynamicMenu = dynamicMenu
        self.dynamicMenu_nsprefix_ = None
        if splitButton is None:
            self.splitButton = []
        else:
            self.splitButton = splitButton
        self.splitButton_nsprefix_ = None
        if box is None:
            self.box = []
        else:
            self.box = box
        self.box_nsprefix_ = None
        if buttonGroup is None:
            self.buttonGroup = []
        else:
            self.buttonGroup = buttonGroup
        self.buttonGroup_nsprefix_ = None
        if separator is None:
            self.separator = []
        else:
            self.separator = separator
        self.separator_nsprefix_ = None
        self.dialogBoxLauncher = dialogBoxLauncher
        self.dialogBoxLauncher_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_Group)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_Group.subclass:
            return CT_Group.subclass(*args_, **kwargs_)
        else:
            return CT_Group(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_control(self):
        return self.control
    def set_control(self, control):
        self.control = control
    def add_control(self, value):
        self.control.append(value)
    def insert_control_at(self, index, value):
        self.control.insert(index, value)
    def replace_control_at(self, index, value):
        self.control[index] = value
    def get_labelControl(self):
        return self.labelControl
    def set_labelControl(self, labelControl):
        self.labelControl = labelControl
    def add_labelControl(self, value):
        self.labelControl.append(value)
    def insert_labelControl_at(self, index, value):
        self.labelControl.insert(index, value)
    def replace_labelControl_at(self, index, value):
        self.labelControl[index] = value
    def get_button(self):
        return self.button
    def set_button(self, button):
        self.button = button
    def add_button(self, value):
        self.button.append(value)
    def insert_button_at(self, index, value):
        self.button.insert(index, value)
    def replace_button_at(self, index, value):
        self.button[index] = value
    def get_toggleButton(self):
        return self.toggleButton
    def set_toggleButton(self, toggleButton):
        self.toggleButton = toggleButton
    def add_toggleButton(self, value):
        self.toggleButton.append(value)
    def insert_toggleButton_at(self, index, value):
        self.toggleButton.insert(index, value)
    def replace_toggleButton_at(self, index, value):
        self.toggleButton[index] = value
    def get_checkBox(self):
        return self.checkBox
    def set_checkBox(self, checkBox):
        self.checkBox = checkBox
    def add_checkBox(self, value):
        self.checkBox.append(value)
    def insert_checkBox_at(self, index, value):
        self.checkBox.insert(index, value)
    def replace_checkBox_at(self, index, value):
        self.checkBox[index] = value
    def get_editBox(self):
        return self.editBox
    def set_editBox(self, editBox):
        self.editBox = editBox
    def add_editBox(self, value):
        self.editBox.append(value)
    def insert_editBox_at(self, index, value):
        self.editBox.insert(index, value)
    def replace_editBox_at(self, index, value):
        self.editBox[index] = value
    def get_comboBox(self):
        return self.comboBox
    def set_comboBox(self, comboBox):
        self.comboBox = comboBox
    def add_comboBox(self, value):
        self.comboBox.append(value)
    def insert_comboBox_at(self, index, value):
        self.comboBox.insert(index, value)
    def replace_comboBox_at(self, index, value):
        self.comboBox[index] = value
    def get_dropDown(self):
        return self.dropDown
    def set_dropDown(self, dropDown):
        self.dropDown = dropDown
    def add_dropDown(self, value):
        self.dropDown.append(value)
    def insert_dropDown_at(self, index, value):
        self.dropDown.insert(index, value)
    def replace_dropDown_at(self, index, value):
        self.dropDown[index] = value
    def get_gallery(self):
        return self.gallery
    def set_gallery(self, gallery):
        self.gallery = gallery
    def add_gallery(self, value):
        self.gallery.append(value)
    def insert_gallery_at(self, index, value):
        self.gallery.insert(index, value)
    def replace_gallery_at(self, index, value):
        self.gallery[index] = value
    def get_menu(self):
        return self.menu
    def set_menu(self, menu):
        self.menu = menu
    def add_menu(self, value):
        self.menu.append(value)
    def insert_menu_at(self, index, value):
        self.menu.insert(index, value)
    def replace_menu_at(self, index, value):
        self.menu[index] = value
    def get_dynamicMenu(self):
        return self.dynamicMenu
    def set_dynamicMenu(self, dynamicMenu):
        self.dynamicMenu = dynamicMenu
    def add_dynamicMenu(self, value):
        self.dynamicMenu.append(value)
    def insert_dynamicMenu_at(self, index, value):
        self.dynamicMenu.insert(index, value)
    def replace_dynamicMenu_at(self, index, value):
        self.dynamicMenu[index] = value
    def get_splitButton(self):
        return self.splitButton
    def set_splitButton(self, splitButton):
        self.splitButton = splitButton
    def add_splitButton(self, value):
        self.splitButton.append(value)
    def insert_splitButton_at(self, index, value):
        self.splitButton.insert(index, value)
    def replace_splitButton_at(self, index, value):
        self.splitButton[index] = value
    def get_box(self):
        return self.box
    def set_box(self, box):
        self.box = box
    def add_box(self, value):
        self.box.append(value)
    def insert_box_at(self, index, value):
        self.box.insert(index, value)
    def replace_box_at(self, index, value):
        self.box[index] = value
    def get_buttonGroup(self):
        return self.buttonGroup
    def set_buttonGroup(self, buttonGroup):
        self.buttonGroup = buttonGroup
    def add_buttonGroup(self, value):
        self.buttonGroup.append(value)
    def insert_buttonGroup_at(self, index, value):
        self.buttonGroup.insert(index, value)
    def replace_buttonGroup_at(self, index, value):
        self.buttonGroup[index] = value
    def get_separator(self):
        return self.separator
    def set_separator(self, separator):
        self.separator = separator
    def add_separator(self, value):
        self.separator.append(value)
    def insert_separator_at(self, index, value):
        self.separator.insert(index, value)
    def replace_separator_at(self, index, value):
        self.separator[index] = value
    def get_dialogBoxLauncher(self):
        return self.dialogBoxLauncher
    def set_dialogBoxLauncher(self, dialogBoxLauncher):
        self.dialogBoxLauncher = dialogBoxLauncher
    def get_autoScale(self):
        return self.autoScale
    def set_autoScale(self, autoScale):
        self.autoScale = autoScale
    def get_centerVertically(self):
        return self.centerVertically
    def set_centerVertically(self, centerVertically):
        self.centerVertically = centerVertically
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_idMso(self):
        return self.idMso
    def set_idMso(self, idMso):
        self.idMso = idMso
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_getLabel(self):
        return self.getLabel
    def set_getLabel(self, getLabel):
        self.getLabel = getLabel
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def get_imageMso(self):
        return self.imageMso
    def set_imageMso(self, imageMso):
        self.imageMso = imageMso
    def get_getImage(self):
        return self.getImage
    def set_getImage(self, getImage):
        self.getImage = getImage
    def get_insertAfterMso(self):
        return self.insertAfterMso
    def set_insertAfterMso(self, insertAfterMso):
        self.insertAfterMso = insertAfterMso
    def get_insertBeforeMso(self):
        return self.insertBeforeMso
    def set_insertBeforeMso(self, insertBeforeMso):
        self.insertBeforeMso = insertBeforeMso
    def get_insertAfterQ(self):
        return self.insertAfterQ
    def set_insertAfterQ(self, insertAfterQ):
        self.insertAfterQ = insertAfterQ
    def get_insertBeforeQ(self):
        return self.insertBeforeQ
    def set_insertBeforeQ(self, insertBeforeQ):
        self.insertBeforeQ = insertBeforeQ
    def get_screentip(self):
        return self.screentip
    def set_screentip(self, screentip):
        self.screentip = screentip
    def get_getScreentip(self):
        return self.getScreentip
    def set_getScreentip(self, getScreentip):
        self.getScreentip = getScreentip
    def get_supertip(self):
        return self.supertip
    def set_supertip(self, supertip):
        self.supertip = supertip
    def get_getSupertip(self):
        return self.getSupertip
    def set_getSupertip(self, getSupertip):
        self.getSupertip = getSupertip
    def get_visible(self):
        return self.visible
    def set_visible(self, visible):
        self.visible = visible
    def get_getVisible(self):
        return self.getVisible
    def set_getVisible(self, getVisible):
        self.getVisible = getVisible
    def get_keytip(self):
        return self.keytip
    def set_keytip(self, keytip):
        self.keytip = keytip
    def get_getKeytip(self):
        return self.getKeytip
    def set_getKeytip(self, getKeytip):
        self.getKeytip = getKeytip
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Uri(self, value):
        # Validate type ST_Uri, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Uri' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Uri' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Keytip(self, value):
        # Validate type ST_Keytip, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Keytip' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Keytip' % {"value" : value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.control or
            self.labelControl or
            self.button or
            self.toggleButton or
            self.checkBox or
            self.editBox or
            self.comboBox or
            self.dropDown or
            self.gallery or
            self.menu or
            self.dynamicMenu or
            self.splitButton or
            self.box or
            self.buttonGroup or
            self.separator or
            self.dialogBoxLauncher is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_Group', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_Group')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_Group')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_Group', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_Group'):
        if self.autoScale is not None and 'autoScale' not in already_processed:
            already_processed.add('autoScale')
            outfile.write(' autoScale="%s"' % self.gds_format_boolean(self.autoScale, input_name='autoScale'))
        if self.centerVertically is not None and 'centerVertically' not in already_processed:
            already_processed.add('centerVertically')
            outfile.write(' centerVertically="%s"' % self.gds_format_boolean(self.centerVertically, input_name='centerVertically'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.idMso is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            outfile.write(' idMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idMso), input_name='idMso')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.getLabel is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            outfile.write(' getLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getLabel), input_name='getLabel')), ))
        if self.image is not None and 'image' not in already_processed:
            already_processed.add('image')
            outfile.write(' image=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.image), input_name='image')), ))
        if self.imageMso is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            outfile.write(' imageMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.imageMso), input_name='imageMso')), ))
        if self.getImage is not None and 'getImage' not in already_processed:
            already_processed.add('getImage')
            outfile.write(' getImage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getImage), input_name='getImage')), ))
        if self.insertAfterMso is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            outfile.write(' insertAfterMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterMso), input_name='insertAfterMso')), ))
        if self.insertBeforeMso is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            outfile.write(' insertBeforeMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeMso), input_name='insertBeforeMso')), ))
        if self.insertAfterQ is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            outfile.write(' insertAfterQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterQ), input_name='insertAfterQ')), ))
        if self.insertBeforeQ is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            outfile.write(' insertBeforeQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeQ), input_name='insertBeforeQ')), ))
        if self.screentip is not None and 'screentip' not in already_processed:
            already_processed.add('screentip')
            outfile.write(' screentip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.screentip), input_name='screentip')), ))
        if self.getScreentip is not None and 'getScreentip' not in already_processed:
            already_processed.add('getScreentip')
            outfile.write(' getScreentip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getScreentip), input_name='getScreentip')), ))
        if self.supertip is not None and 'supertip' not in already_processed:
            already_processed.add('supertip')
            outfile.write(' supertip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.supertip), input_name='supertip')), ))
        if self.getSupertip is not None and 'getSupertip' not in already_processed:
            already_processed.add('getSupertip')
            outfile.write(' getSupertip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getSupertip), input_name='getSupertip')), ))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            outfile.write(' visible="%s"' % self.gds_format_boolean(self.visible, input_name='visible'))
        if self.getVisible is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            outfile.write(' getVisible=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getVisible), input_name='getVisible')), ))
        if self.keytip is not None and 'keytip' not in already_processed:
            already_processed.add('keytip')
            outfile.write(' keytip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.keytip), input_name='keytip')), ))
        if self.getKeytip is not None and 'getKeytip' not in already_processed:
            already_processed.add('getKeytip')
            outfile.write(' getKeytip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getKeytip), input_name='getKeytip')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_Group', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for control_ in self.control:
            namespaceprefix_ = self.control_nsprefix_ + ':' if (UseCapturedNS_ and self.control_nsprefix_) else ''
            control_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='control', pretty_print=pretty_print)
        for labelControl_ in self.labelControl:
            namespaceprefix_ = self.labelControl_nsprefix_ + ':' if (UseCapturedNS_ and self.labelControl_nsprefix_) else ''
            labelControl_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='labelControl', pretty_print=pretty_print)
        for button_ in self.button:
            namespaceprefix_ = self.button_nsprefix_ + ':' if (UseCapturedNS_ and self.button_nsprefix_) else ''
            button_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='button', pretty_print=pretty_print)
        for toggleButton_ in self.toggleButton:
            namespaceprefix_ = self.toggleButton_nsprefix_ + ':' if (UseCapturedNS_ and self.toggleButton_nsprefix_) else ''
            toggleButton_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='toggleButton', pretty_print=pretty_print)
        for checkBox_ in self.checkBox:
            namespaceprefix_ = self.checkBox_nsprefix_ + ':' if (UseCapturedNS_ and self.checkBox_nsprefix_) else ''
            checkBox_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='checkBox', pretty_print=pretty_print)
        for editBox_ in self.editBox:
            namespaceprefix_ = self.editBox_nsprefix_ + ':' if (UseCapturedNS_ and self.editBox_nsprefix_) else ''
            editBox_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='editBox', pretty_print=pretty_print)
        for comboBox_ in self.comboBox:
            namespaceprefix_ = self.comboBox_nsprefix_ + ':' if (UseCapturedNS_ and self.comboBox_nsprefix_) else ''
            comboBox_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='comboBox', pretty_print=pretty_print)
        for dropDown_ in self.dropDown:
            namespaceprefix_ = self.dropDown_nsprefix_ + ':' if (UseCapturedNS_ and self.dropDown_nsprefix_) else ''
            dropDown_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dropDown', pretty_print=pretty_print)
        for gallery_ in self.gallery:
            namespaceprefix_ = self.gallery_nsprefix_ + ':' if (UseCapturedNS_ and self.gallery_nsprefix_) else ''
            gallery_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='gallery', pretty_print=pretty_print)
        for menu_ in self.menu:
            namespaceprefix_ = self.menu_nsprefix_ + ':' if (UseCapturedNS_ and self.menu_nsprefix_) else ''
            menu_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='menu', pretty_print=pretty_print)
        for dynamicMenu_ in self.dynamicMenu:
            namespaceprefix_ = self.dynamicMenu_nsprefix_ + ':' if (UseCapturedNS_ and self.dynamicMenu_nsprefix_) else ''
            dynamicMenu_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dynamicMenu', pretty_print=pretty_print)
        for splitButton_ in self.splitButton:
            namespaceprefix_ = self.splitButton_nsprefix_ + ':' if (UseCapturedNS_ and self.splitButton_nsprefix_) else ''
            splitButton_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='splitButton', pretty_print=pretty_print)
        for box_ in self.box:
            namespaceprefix_ = self.box_nsprefix_ + ':' if (UseCapturedNS_ and self.box_nsprefix_) else ''
            box_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='box', pretty_print=pretty_print)
        for buttonGroup_ in self.buttonGroup:
            namespaceprefix_ = self.buttonGroup_nsprefix_ + ':' if (UseCapturedNS_ and self.buttonGroup_nsprefix_) else ''
            buttonGroup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='buttonGroup', pretty_print=pretty_print)
        for separator_ in self.separator:
            namespaceprefix_ = self.separator_nsprefix_ + ':' if (UseCapturedNS_ and self.separator_nsprefix_) else ''
            separator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='separator', pretty_print=pretty_print)
        if self.dialogBoxLauncher is not None:
            namespaceprefix_ = self.dialogBoxLauncher_nsprefix_ + ':' if (UseCapturedNS_ and self.dialogBoxLauncher_nsprefix_) else ''
            self.dialogBoxLauncher.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dialogBoxLauncher', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('autoScale', node)
        if value is not None and 'autoScale' not in already_processed:
            already_processed.add('autoScale')
            if value in ('true', '1'):
                self.autoScale = True
            elif value in ('false', '0'):
                self.autoScale = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('centerVertically', node)
        if value is not None and 'centerVertically' not in already_processed:
            already_processed.add('centerVertically')
            if value in ('true', '1'):
                self.centerVertically = True
            elif value in ('false', '0'):
                self.centerVertically = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('idMso', node)
        if value is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            self.idMso = value
            self.validate_ST_ID(self.idMso)    # validate type ST_ID
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
            self.validate_ST_String(self.label)    # validate type ST_String
        value = find_attr_value_('getLabel', node)
        if value is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            self.getLabel = value
            self.validate_ST_Delegate(self.getLabel)    # validate type ST_Delegate
        value = find_attr_value_('image', node)
        if value is not None and 'image' not in already_processed:
            already_processed.add('image')
            self.image = value
            self.validate_ST_Uri(self.image)    # validate type ST_Uri
        value = find_attr_value_('imageMso', node)
        if value is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            self.imageMso = value
            self.validate_ST_ID(self.imageMso)    # validate type ST_ID
        value = find_attr_value_('getImage', node)
        if value is not None and 'getImage' not in already_processed:
            already_processed.add('getImage')
            self.getImage = value
            self.validate_ST_Delegate(self.getImage)    # validate type ST_Delegate
        value = find_attr_value_('insertAfterMso', node)
        if value is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            self.insertAfterMso = value
            self.validate_ST_ID(self.insertAfterMso)    # validate type ST_ID
        value = find_attr_value_('insertBeforeMso', node)
        if value is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            self.insertBeforeMso = value
            self.validate_ST_ID(self.insertBeforeMso)    # validate type ST_ID
        value = find_attr_value_('insertAfterQ', node)
        if value is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            self.insertAfterQ = value
            self.validate_ST_QID(self.insertAfterQ)    # validate type ST_QID
        value = find_attr_value_('insertBeforeQ', node)
        if value is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            self.insertBeforeQ = value
            self.validate_ST_QID(self.insertBeforeQ)    # validate type ST_QID
        value = find_attr_value_('screentip', node)
        if value is not None and 'screentip' not in already_processed:
            already_processed.add('screentip')
            self.screentip = value
            self.validate_ST_String(self.screentip)    # validate type ST_String
        value = find_attr_value_('getScreentip', node)
        if value is not None and 'getScreentip' not in already_processed:
            already_processed.add('getScreentip')
            self.getScreentip = value
            self.validate_ST_Delegate(self.getScreentip)    # validate type ST_Delegate
        value = find_attr_value_('supertip', node)
        if value is not None and 'supertip' not in already_processed:
            already_processed.add('supertip')
            self.supertip = value
            self.validate_ST_String(self.supertip)    # validate type ST_String
        value = find_attr_value_('getSupertip', node)
        if value is not None and 'getSupertip' not in already_processed:
            already_processed.add('getSupertip')
            self.getSupertip = value
            self.validate_ST_Delegate(self.getSupertip)    # validate type ST_Delegate
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            if value in ('true', '1'):
                self.visible = True
            elif value in ('false', '0'):
                self.visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getVisible', node)
        if value is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            self.getVisible = value
            self.validate_ST_Delegate(self.getVisible)    # validate type ST_Delegate
        value = find_attr_value_('keytip', node)
        if value is not None and 'keytip' not in already_processed:
            already_processed.add('keytip')
            self.keytip = value
            self.keytip = ' '.join(self.keytip.split())
            self.validate_ST_Keytip(self.keytip)    # validate type ST_Keytip
        value = find_attr_value_('getKeytip', node)
        if value is not None and 'getKeytip' not in already_processed:
            already_processed.add('getKeytip')
            self.getKeytip = value
            self.validate_ST_Delegate(self.getKeytip)    # validate type ST_Delegate
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'control':
            obj_ = CT_ControlClone.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.control.append(obj_)
            obj_.original_tagname_ = 'control'
        elif nodeName_ == 'labelControl':
            obj_ = CT_LabelControl.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.labelControl.append(obj_)
            obj_.original_tagname_ = 'labelControl'
        elif nodeName_ == 'button':
            obj_ = CT_Button.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.button.append(obj_)
            obj_.original_tagname_ = 'button'
        elif nodeName_ == 'toggleButton':
            obj_ = CT_ToggleButton.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.toggleButton.append(obj_)
            obj_.original_tagname_ = 'toggleButton'
        elif nodeName_ == 'checkBox':
            obj_ = CT_CheckBox.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.checkBox.append(obj_)
            obj_.original_tagname_ = 'checkBox'
        elif nodeName_ == 'editBox':
            class_obj_ = self.get_class_obj_(child_, CT_EditBox)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.editBox.append(obj_)
            obj_.original_tagname_ = 'editBox'
        elif nodeName_ == 'comboBox':
            obj_ = CT_ComboBox.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.comboBox.append(obj_)
            obj_.original_tagname_ = 'comboBox'
        elif nodeName_ == 'dropDown':
            class_obj_ = self.get_class_obj_(child_, CT_DropDownRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dropDown.append(obj_)
            obj_.original_tagname_ = 'dropDown'
        elif nodeName_ == 'gallery':
            obj_ = CT_Gallery.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gallery.append(obj_)
            obj_.original_tagname_ = 'gallery'
        elif nodeName_ == 'menu':
            obj_ = CT_Menu.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.menu.append(obj_)
            obj_.original_tagname_ = 'menu'
        elif nodeName_ == 'dynamicMenu':
            obj_ = CT_DynamicMenu.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dynamicMenu.append(obj_)
            obj_.original_tagname_ = 'dynamicMenu'
        elif nodeName_ == 'splitButton':
            obj_ = CT_SplitButton.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.splitButton.append(obj_)
            obj_.original_tagname_ = 'splitButton'
        elif nodeName_ == 'box':
            obj_ = CT_Box.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.box.append(obj_)
            obj_.original_tagname_ = 'box'
        elif nodeName_ == 'buttonGroup':
            obj_ = CT_ButtonGroup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.buttonGroup.append(obj_)
            obj_.original_tagname_ = 'buttonGroup'
        elif nodeName_ == 'separator':
            obj_ = CT_Separator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.separator.append(obj_)
            obj_.original_tagname_ = 'separator'
        elif nodeName_ == 'dialogBoxLauncher':
            obj_ = CT_DialogLauncher.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dialogBoxLauncher = obj_
            obj_.original_tagname_ = 'dialogBoxLauncher'
# end class CT_Group


class CT_Tab(GeneratedsSuper):
    """Specifies a tab that contains groups with other controls."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, idQ=None, tag=None, idMso=None, label=None, getLabel=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, keytip=None, getKeytip=None, group=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.idMso = _cast(None, idMso)
        self.idMso_nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.getLabel = _cast(None, getLabel)
        self.getLabel_nsprefix_ = None
        self.insertAfterMso = _cast(None, insertAfterMso)
        self.insertAfterMso_nsprefix_ = None
        self.insertBeforeMso = _cast(None, insertBeforeMso)
        self.insertBeforeMso_nsprefix_ = None
        self.insertAfterQ = _cast(None, insertAfterQ)
        self.insertAfterQ_nsprefix_ = None
        self.insertBeforeQ = _cast(None, insertBeforeQ)
        self.insertBeforeQ_nsprefix_ = None
        self.visible = _cast(bool, visible)
        self.visible_nsprefix_ = None
        self.getVisible = _cast(None, getVisible)
        self.getVisible_nsprefix_ = None
        self.keytip = _cast(None, keytip)
        self.keytip_nsprefix_ = None
        self.getKeytip = _cast(None, getKeytip)
        self.getKeytip_nsprefix_ = None
        if group is None:
            self.group = []
        else:
            self.group = group
        self.group_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_Tab)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_Tab.subclass:
            return CT_Tab.subclass(*args_, **kwargs_)
        else:
            return CT_Tab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_group(self):
        return self.group
    def set_group(self, group):
        self.group = group
    def add_group(self, value):
        self.group.append(value)
    def insert_group_at(self, index, value):
        self.group.insert(index, value)
    def replace_group_at(self, index, value):
        self.group[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_idMso(self):
        return self.idMso
    def set_idMso(self, idMso):
        self.idMso = idMso
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_getLabel(self):
        return self.getLabel
    def set_getLabel(self, getLabel):
        self.getLabel = getLabel
    def get_insertAfterMso(self):
        return self.insertAfterMso
    def set_insertAfterMso(self, insertAfterMso):
        self.insertAfterMso = insertAfterMso
    def get_insertBeforeMso(self):
        return self.insertBeforeMso
    def set_insertBeforeMso(self, insertBeforeMso):
        self.insertBeforeMso = insertBeforeMso
    def get_insertAfterQ(self):
        return self.insertAfterQ
    def set_insertAfterQ(self, insertAfterQ):
        self.insertAfterQ = insertAfterQ
    def get_insertBeforeQ(self):
        return self.insertBeforeQ
    def set_insertBeforeQ(self, insertBeforeQ):
        self.insertBeforeQ = insertBeforeQ
    def get_visible(self):
        return self.visible
    def set_visible(self, visible):
        self.visible = visible
    def get_getVisible(self):
        return self.getVisible
    def set_getVisible(self, getVisible):
        self.getVisible = getVisible
    def get_keytip(self):
        return self.keytip
    def set_keytip(self, keytip):
        self.keytip = keytip
    def get_getKeytip(self):
        return self.getKeytip
    def set_getKeytip(self, getKeytip):
        self.getKeytip = getKeytip
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Keytip(self, value):
        # Validate type ST_Keytip, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Keytip' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Keytip' % {"value" : value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.group
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_Tab', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_Tab')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_Tab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_Tab', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_Tab'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.idMso is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            outfile.write(' idMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idMso), input_name='idMso')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.getLabel is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            outfile.write(' getLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getLabel), input_name='getLabel')), ))
        if self.insertAfterMso is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            outfile.write(' insertAfterMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterMso), input_name='insertAfterMso')), ))
        if self.insertBeforeMso is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            outfile.write(' insertBeforeMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeMso), input_name='insertBeforeMso')), ))
        if self.insertAfterQ is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            outfile.write(' insertAfterQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterQ), input_name='insertAfterQ')), ))
        if self.insertBeforeQ is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            outfile.write(' insertBeforeQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeQ), input_name='insertBeforeQ')), ))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            outfile.write(' visible="%s"' % self.gds_format_boolean(self.visible, input_name='visible'))
        if self.getVisible is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            outfile.write(' getVisible=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getVisible), input_name='getVisible')), ))
        if self.keytip is not None and 'keytip' not in already_processed:
            already_processed.add('keytip')
            outfile.write(' keytip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.keytip), input_name='keytip')), ))
        if self.getKeytip is not None and 'getKeytip' not in already_processed:
            already_processed.add('getKeytip')
            outfile.write(' getKeytip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getKeytip), input_name='getKeytip')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_Tab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for group_ in self.group:
            namespaceprefix_ = self.group_nsprefix_ + ':' if (UseCapturedNS_ and self.group_nsprefix_) else ''
            group_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='group', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('idMso', node)
        if value is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            self.idMso = value
            self.validate_ST_ID(self.idMso)    # validate type ST_ID
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
            self.validate_ST_String(self.label)    # validate type ST_String
        value = find_attr_value_('getLabel', node)
        if value is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            self.getLabel = value
            self.validate_ST_Delegate(self.getLabel)    # validate type ST_Delegate
        value = find_attr_value_('insertAfterMso', node)
        if value is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            self.insertAfterMso = value
            self.validate_ST_ID(self.insertAfterMso)    # validate type ST_ID
        value = find_attr_value_('insertBeforeMso', node)
        if value is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            self.insertBeforeMso = value
            self.validate_ST_ID(self.insertBeforeMso)    # validate type ST_ID
        value = find_attr_value_('insertAfterQ', node)
        if value is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            self.insertAfterQ = value
            self.validate_ST_QID(self.insertAfterQ)    # validate type ST_QID
        value = find_attr_value_('insertBeforeQ', node)
        if value is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            self.insertBeforeQ = value
            self.validate_ST_QID(self.insertBeforeQ)    # validate type ST_QID
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            if value in ('true', '1'):
                self.visible = True
            elif value in ('false', '0'):
                self.visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getVisible', node)
        if value is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            self.getVisible = value
            self.validate_ST_Delegate(self.getVisible)    # validate type ST_Delegate
        value = find_attr_value_('keytip', node)
        if value is not None and 'keytip' not in already_processed:
            already_processed.add('keytip')
            self.keytip = value
            self.keytip = ' '.join(self.keytip.split())
            self.validate_ST_Keytip(self.keytip)    # validate type ST_Keytip
        value = find_attr_value_('getKeytip', node)
        if value is not None and 'getKeytip' not in already_processed:
            already_processed.add('getKeytip')
            self.getKeytip = value
            self.validate_ST_Delegate(self.getKeytip)    # validate type ST_Delegate
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'group':
            obj_ = CT_Group.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.group.append(obj_)
            obj_.original_tagname_ = 'group'
# end class CT_Tab


class CT_QatItems(GeneratedsSuper):
    """Specifies Quick Access Toolbar items (shared or document-specific)."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, control=None, button=None, separator=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if control is None:
            self.control = []
        else:
            self.control = control
        self.control_nsprefix_ = None
        if button is None:
            self.button = []
        else:
            self.button = button
        self.button_nsprefix_ = None
        if separator is None:
            self.separator = []
        else:
            self.separator = separator
        self.separator_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_QatItems)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_QatItems.subclass:
            return CT_QatItems.subclass(*args_, **kwargs_)
        else:
            return CT_QatItems(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_control(self):
        return self.control
    def set_control(self, control):
        self.control = control
    def add_control(self, value):
        self.control.append(value)
    def insert_control_at(self, index, value):
        self.control.insert(index, value)
    def replace_control_at(self, index, value):
        self.control[index] = value
    def get_button(self):
        return self.button
    def set_button(self, button):
        self.button = button
    def add_button(self, value):
        self.button.append(value)
    def insert_button_at(self, index, value):
        self.button.insert(index, value)
    def replace_button_at(self, index, value):
        self.button[index] = value
    def get_separator(self):
        return self.separator
    def set_separator(self, separator):
        self.separator = separator
    def add_separator(self, value):
        self.separator.append(value)
    def insert_separator_at(self, index, value):
        self.separator.insert(index, value)
    def replace_separator_at(self, index, value):
        self.separator[index] = value
    def hasContent_(self):
        if (
            self.control or
            self.button or
            self.separator
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_QatItems', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_QatItems')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_QatItems')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_QatItems', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_QatItems'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_QatItems', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for control_ in self.control:
            namespaceprefix_ = self.control_nsprefix_ + ':' if (UseCapturedNS_ and self.control_nsprefix_) else ''
            control_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='control', pretty_print=pretty_print)
        for button_ in self.button:
            namespaceprefix_ = self.button_nsprefix_ + ':' if (UseCapturedNS_ and self.button_nsprefix_) else ''
            button_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='button', pretty_print=pretty_print)
        for separator_ in self.separator:
            namespaceprefix_ = self.separator_nsprefix_ + ':' if (UseCapturedNS_ and self.separator_nsprefix_) else ''
            separator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='separator', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'control':
            obj_ = CT_ControlCloneQat.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.control.append(obj_)
            obj_.original_tagname_ = 'control'
        elif nodeName_ == 'button':
            class_obj_ = self.get_class_obj_(child_, CT_ButtonRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.button.append(obj_)
            obj_.original_tagname_ = 'button'
        elif nodeName_ == 'separator':
            obj_ = CT_Separator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.separator.append(obj_)
            obj_.original_tagname_ = 'separator'
# end class CT_QatItems


class CT_Qat(GeneratedsSuper):
    """Specifies Quick Access Toolbar.
    Contains two control collections:
    Shared (applied to all windows and documents) and
    Document (attached to a document)."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, sharedControls=None, documentControls=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.sharedControls = sharedControls
        self.sharedControls_nsprefix_ = None
        self.documentControls = documentControls
        self.documentControls_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_Qat)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_Qat.subclass:
            return CT_Qat.subclass(*args_, **kwargs_)
        else:
            return CT_Qat(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_sharedControls(self):
        return self.sharedControls
    def set_sharedControls(self, sharedControls):
        self.sharedControls = sharedControls
    def get_documentControls(self):
        return self.documentControls
    def set_documentControls(self, documentControls):
        self.documentControls = documentControls
    def hasContent_(self):
        if (
            self.sharedControls is not None or
            self.documentControls is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_Qat', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_Qat')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_Qat')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_Qat', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_Qat'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_Qat', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.sharedControls is not None:
            namespaceprefix_ = self.sharedControls_nsprefix_ + ':' if (UseCapturedNS_ and self.sharedControls_nsprefix_) else ''
            self.sharedControls.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sharedControls', pretty_print=pretty_print)
        if self.documentControls is not None:
            namespaceprefix_ = self.documentControls_nsprefix_ + ':' if (UseCapturedNS_ and self.documentControls_nsprefix_) else ''
            self.documentControls.export(outfile, level, namespaceprefix_, namespacedef_='', name_='documentControls', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'sharedControls':
            obj_ = CT_QatItems.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sharedControls = obj_
            obj_.original_tagname_ = 'sharedControls'
        elif nodeName_ == 'documentControls':
            obj_ = CT_QatItems.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.documentControls = obj_
            obj_.original_tagname_ = 'documentControls'
# end class CT_Qat


class CT_Tabs(GeneratedsSuper):
    """Specifies a collection of tabs."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, tab=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if tab is None:
            self.tab = []
        else:
            self.tab = tab
        self.tab_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_Tabs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_Tabs.subclass:
            return CT_Tabs.subclass(*args_, **kwargs_)
        else:
            return CT_Tabs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tab(self):
        return self.tab
    def set_tab(self, tab):
        self.tab = tab
    def add_tab(self, value):
        self.tab.append(value)
    def insert_tab_at(self, index, value):
        self.tab.insert(index, value)
    def replace_tab_at(self, index, value):
        self.tab[index] = value
    def hasContent_(self):
        if (
            self.tab
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_Tabs', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_Tabs')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_Tabs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_Tabs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_Tabs'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_Tabs', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tab_ in self.tab:
            namespaceprefix_ = self.tab_nsprefix_ + ':' if (UseCapturedNS_ and self.tab_nsprefix_) else ''
            tab_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tab', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tab':
            obj_ = CT_Tab.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tab.append(obj_)
            obj_.original_tagname_ = 'tab'
# end class CT_Tabs


class CT_TabSet(GeneratedsSuper):
    """Specifies a collection of contextual tab sets.
    Specifies ID of a built-in control."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, idMso=None, visible=None, getVisible=None, tab=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.idMso = _cast(None, idMso)
        self.idMso_nsprefix_ = None
        self.visible = _cast(bool, visible)
        self.visible_nsprefix_ = None
        self.getVisible = _cast(None, getVisible)
        self.getVisible_nsprefix_ = None
        if tab is None:
            self.tab = []
        else:
            self.tab = tab
        self.tab_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_TabSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_TabSet.subclass:
            return CT_TabSet.subclass(*args_, **kwargs_)
        else:
            return CT_TabSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tab(self):
        return self.tab
    def set_tab(self, tab):
        self.tab = tab
    def add_tab(self, value):
        self.tab.append(value)
    def insert_tab_at(self, index, value):
        self.tab.insert(index, value)
    def replace_tab_at(self, index, value):
        self.tab[index] = value
    def get_idMso(self):
        return self.idMso
    def set_idMso(self, idMso):
        self.idMso = idMso
    def get_visible(self):
        return self.visible
    def set_visible(self, visible):
        self.visible = visible
    def get_getVisible(self):
        return self.getVisible
    def set_getVisible(self, getVisible):
        self.getVisible = getVisible
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.tab
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_TabSet', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_TabSet')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_TabSet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_TabSet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_TabSet'):
        if self.idMso is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            outfile.write(' idMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idMso), input_name='idMso')), ))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            outfile.write(' visible="%s"' % self.gds_format_boolean(self.visible, input_name='visible'))
        if self.getVisible is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            outfile.write(' getVisible=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getVisible), input_name='getVisible')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_TabSet', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tab_ in self.tab:
            namespaceprefix_ = self.tab_nsprefix_ + ':' if (UseCapturedNS_ and self.tab_nsprefix_) else ''
            tab_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tab', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('idMso', node)
        if value is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            self.idMso = value
            self.validate_ST_ID(self.idMso)    # validate type ST_ID
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            if value in ('true', '1'):
                self.visible = True
            elif value in ('false', '0'):
                self.visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getVisible', node)
        if value is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            self.getVisible = value
            self.validate_ST_Delegate(self.getVisible)    # validate type ST_Delegate
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tab':
            obj_ = CT_Tab.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tab.append(obj_)
            obj_.original_tagname_ = 'tab'
# end class CT_TabSet


class CT_ContextualTabs(GeneratedsSuper):
    """Specifies a collection of contextual tab sets."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, tabSet=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if tabSet is None:
            self.tabSet = []
        else:
            self.tabSet = tabSet
        self.tabSet_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_ContextualTabs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_ContextualTabs.subclass:
            return CT_ContextualTabs.subclass(*args_, **kwargs_)
        else:
            return CT_ContextualTabs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tabSet(self):
        return self.tabSet
    def set_tabSet(self, tabSet):
        self.tabSet = tabSet
    def add_tabSet(self, value):
        self.tabSet.append(value)
    def insert_tabSet_at(self, index, value):
        self.tabSet.insert(index, value)
    def replace_tabSet_at(self, index, value):
        self.tabSet[index] = value
    def hasContent_(self):
        if (
            self.tabSet
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_ContextualTabs', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_ContextualTabs')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_ContextualTabs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_ContextualTabs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_ContextualTabs'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_ContextualTabs', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tabSet_ in self.tabSet:
            namespaceprefix_ = self.tabSet_nsprefix_ + ':' if (UseCapturedNS_ and self.tabSet_nsprefix_) else ''
            tabSet_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tabSet', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tabSet':
            obj_ = CT_TabSet.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tabSet.append(obj_)
            obj_.original_tagname_ = 'tabSet'
# end class CT_ContextualTabs


class CT_ContextMenu(GeneratedsSuper):
    """Specifies a ContextMenu.
    Contains one or more controls in sections divided by separators."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, idMso=None, control=None, button=None, checkBox=None, gallery=None, toggleButton=None, splitButton=None, menu=None, dynamicMenu=None, menuSeparator=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.idMso = _cast(None, idMso)
        self.idMso_nsprefix_ = None
        if control is None:
            self.control = []
        else:
            self.control = control
        self.control_nsprefix_ = None
        if button is None:
            self.button = []
        else:
            self.button = button
        self.button_nsprefix_ = None
        if checkBox is None:
            self.checkBox = []
        else:
            self.checkBox = checkBox
        self.checkBox_nsprefix_ = None
        if gallery is None:
            self.gallery = []
        else:
            self.gallery = gallery
        self.gallery_nsprefix_ = None
        if toggleButton is None:
            self.toggleButton = []
        else:
            self.toggleButton = toggleButton
        self.toggleButton_nsprefix_ = None
        if splitButton is None:
            self.splitButton = []
        else:
            self.splitButton = splitButton
        self.splitButton_nsprefix_ = None
        if menu is None:
            self.menu = []
        else:
            self.menu = menu
        self.menu_nsprefix_ = None
        if dynamicMenu is None:
            self.dynamicMenu = []
        else:
            self.dynamicMenu = dynamicMenu
        self.dynamicMenu_nsprefix_ = None
        if menuSeparator is None:
            self.menuSeparator = []
        else:
            self.menuSeparator = menuSeparator
        self.menuSeparator_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_ContextMenu)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_ContextMenu.subclass:
            return CT_ContextMenu.subclass(*args_, **kwargs_)
        else:
            return CT_ContextMenu(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_control(self):
        return self.control
    def set_control(self, control):
        self.control = control
    def add_control(self, value):
        self.control.append(value)
    def insert_control_at(self, index, value):
        self.control.insert(index, value)
    def replace_control_at(self, index, value):
        self.control[index] = value
    def get_button(self):
        return self.button
    def set_button(self, button):
        self.button = button
    def add_button(self, value):
        self.button.append(value)
    def insert_button_at(self, index, value):
        self.button.insert(index, value)
    def replace_button_at(self, index, value):
        self.button[index] = value
    def get_checkBox(self):
        return self.checkBox
    def set_checkBox(self, checkBox):
        self.checkBox = checkBox
    def add_checkBox(self, value):
        self.checkBox.append(value)
    def insert_checkBox_at(self, index, value):
        self.checkBox.insert(index, value)
    def replace_checkBox_at(self, index, value):
        self.checkBox[index] = value
    def get_gallery(self):
        return self.gallery
    def set_gallery(self, gallery):
        self.gallery = gallery
    def add_gallery(self, value):
        self.gallery.append(value)
    def insert_gallery_at(self, index, value):
        self.gallery.insert(index, value)
    def replace_gallery_at(self, index, value):
        self.gallery[index] = value
    def get_toggleButton(self):
        return self.toggleButton
    def set_toggleButton(self, toggleButton):
        self.toggleButton = toggleButton
    def add_toggleButton(self, value):
        self.toggleButton.append(value)
    def insert_toggleButton_at(self, index, value):
        self.toggleButton.insert(index, value)
    def replace_toggleButton_at(self, index, value):
        self.toggleButton[index] = value
    def get_splitButton(self):
        return self.splitButton
    def set_splitButton(self, splitButton):
        self.splitButton = splitButton
    def add_splitButton(self, value):
        self.splitButton.append(value)
    def insert_splitButton_at(self, index, value):
        self.splitButton.insert(index, value)
    def replace_splitButton_at(self, index, value):
        self.splitButton[index] = value
    def get_menu(self):
        return self.menu
    def set_menu(self, menu):
        self.menu = menu
    def add_menu(self, value):
        self.menu.append(value)
    def insert_menu_at(self, index, value):
        self.menu.insert(index, value)
    def replace_menu_at(self, index, value):
        self.menu[index] = value
    def get_dynamicMenu(self):
        return self.dynamicMenu
    def set_dynamicMenu(self, dynamicMenu):
        self.dynamicMenu = dynamicMenu
    def add_dynamicMenu(self, value):
        self.dynamicMenu.append(value)
    def insert_dynamicMenu_at(self, index, value):
        self.dynamicMenu.insert(index, value)
    def replace_dynamicMenu_at(self, index, value):
        self.dynamicMenu[index] = value
    def get_menuSeparator(self):
        return self.menuSeparator
    def set_menuSeparator(self, menuSeparator):
        self.menuSeparator = menuSeparator
    def add_menuSeparator(self, value):
        self.menuSeparator.append(value)
    def insert_menuSeparator_at(self, index, value):
        self.menuSeparator.insert(index, value)
    def replace_menuSeparator_at(self, index, value):
        self.menuSeparator[index] = value
    def get_idMso(self):
        return self.idMso
    def set_idMso(self, idMso):
        self.idMso = idMso
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.control or
            self.button or
            self.checkBox or
            self.gallery or
            self.toggleButton or
            self.splitButton or
            self.menu or
            self.dynamicMenu or
            self.menuSeparator
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_ContextMenu', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_ContextMenu')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_ContextMenu')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_ContextMenu', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_ContextMenu'):
        if self.idMso is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            outfile.write(' idMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idMso), input_name='idMso')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_ContextMenu', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for control_ in self.control:
            namespaceprefix_ = self.control_nsprefix_ + ':' if (UseCapturedNS_ and self.control_nsprefix_) else ''
            control_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='control', pretty_print=pretty_print)
        for button_ in self.button:
            namespaceprefix_ = self.button_nsprefix_ + ':' if (UseCapturedNS_ and self.button_nsprefix_) else ''
            button_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='button', pretty_print=pretty_print)
        for checkBox_ in self.checkBox:
            namespaceprefix_ = self.checkBox_nsprefix_ + ':' if (UseCapturedNS_ and self.checkBox_nsprefix_) else ''
            checkBox_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='checkBox', pretty_print=pretty_print)
        for gallery_ in self.gallery:
            namespaceprefix_ = self.gallery_nsprefix_ + ':' if (UseCapturedNS_ and self.gallery_nsprefix_) else ''
            gallery_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='gallery', pretty_print=pretty_print)
        for toggleButton_ in self.toggleButton:
            namespaceprefix_ = self.toggleButton_nsprefix_ + ':' if (UseCapturedNS_ and self.toggleButton_nsprefix_) else ''
            toggleButton_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='toggleButton', pretty_print=pretty_print)
        for splitButton_ in self.splitButton:
            namespaceprefix_ = self.splitButton_nsprefix_ + ':' if (UseCapturedNS_ and self.splitButton_nsprefix_) else ''
            splitButton_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='splitButton', pretty_print=pretty_print)
        for menu_ in self.menu:
            namespaceprefix_ = self.menu_nsprefix_ + ':' if (UseCapturedNS_ and self.menu_nsprefix_) else ''
            menu_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='menu', pretty_print=pretty_print)
        for dynamicMenu_ in self.dynamicMenu:
            namespaceprefix_ = self.dynamicMenu_nsprefix_ + ':' if (UseCapturedNS_ and self.dynamicMenu_nsprefix_) else ''
            dynamicMenu_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dynamicMenu', pretty_print=pretty_print)
        for menuSeparator_ in self.menuSeparator:
            namespaceprefix_ = self.menuSeparator_nsprefix_ + ':' if (UseCapturedNS_ and self.menuSeparator_nsprefix_) else ''
            menuSeparator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='menuSeparator', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('idMso', node)
        if value is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            self.idMso = value
            self.validate_ST_ID(self.idMso)    # validate type ST_ID
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'control':
            obj_ = CT_ControlCloneRegular.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.control.append(obj_)
            obj_.original_tagname_ = 'control'
        elif nodeName_ == 'button':
            class_obj_ = self.get_class_obj_(child_, CT_ButtonRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.button.append(obj_)
            obj_.original_tagname_ = 'button'
        elif nodeName_ == 'checkBox':
            obj_ = CT_CheckBox.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.checkBox.append(obj_)
            obj_.original_tagname_ = 'checkBox'
        elif nodeName_ == 'gallery':
            class_obj_ = self.get_class_obj_(child_, CT_GalleryRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gallery.append(obj_)
            obj_.original_tagname_ = 'gallery'
        elif nodeName_ == 'toggleButton':
            class_obj_ = self.get_class_obj_(child_, CT_ToggleButtonRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.toggleButton.append(obj_)
            obj_.original_tagname_ = 'toggleButton'
        elif nodeName_ == 'splitButton':
            class_obj_ = self.get_class_obj_(child_, CT_SplitButtonRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.splitButton.append(obj_)
            obj_.original_tagname_ = 'splitButton'
        elif nodeName_ == 'menu':
            class_obj_ = self.get_class_obj_(child_, CT_MenuRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.menu.append(obj_)
            obj_.original_tagname_ = 'menu'
        elif nodeName_ == 'dynamicMenu':
            class_obj_ = self.get_class_obj_(child_, CT_DynamicMenuRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dynamicMenu.append(obj_)
            obj_.original_tagname_ = 'dynamicMenu'
        elif nodeName_ == 'menuSeparator':
            obj_ = CT_MenuSeparatorNoTitle.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.menuSeparator.append(obj_)
            obj_.original_tagname_ = 'menuSeparator'
# end class CT_ContextMenu


class CT_Commands(GeneratedsSuper):
    """Specifies a collection of Command elements."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, command=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if command is None:
            self.command = []
        else:
            self.command = command
        self.command_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_Commands)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_Commands.subclass:
            return CT_Commands.subclass(*args_, **kwargs_)
        else:
            return CT_Commands(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_command(self):
        return self.command
    def set_command(self, command):
        self.command = command
    def add_command(self, value):
        self.command.append(value)
    def insert_command_at(self, index, value):
        self.command.insert(index, value)
    def replace_command_at(self, index, value):
        self.command[index] = value
    def hasContent_(self):
        if (
            self.command
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_Commands', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_Commands')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_Commands')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_Commands', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_Commands'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_Commands', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for command_ in self.command:
            namespaceprefix_ = self.command_nsprefix_ + ':' if (UseCapturedNS_ and self.command_nsprefix_) else ''
            command_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='command', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'command':
            obj_ = CT_Command.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.command.append(obj_)
            obj_.original_tagname_ = 'command'
# end class CT_Commands


class CT_Ribbon(GeneratedsSuper):
    """Specifies the Ribbon which contains the tabs, menu, Quick Access Toolbar
    control types.
    Specicies the mode where most of the standard UI is turned off and
    replaced with custom UI specified here."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, startFromScratch=None, qat=None, tabs=None, contextualTabs=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.startFromScratch = _cast(bool, startFromScratch)
        self.startFromScratch_nsprefix_ = None
        self.qat = qat
        self.qat_nsprefix_ = None
        self.tabs = tabs
        self.tabs_nsprefix_ = None
        self.contextualTabs = contextualTabs
        self.contextualTabs_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_Ribbon)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_Ribbon.subclass:
            return CT_Ribbon.subclass(*args_, **kwargs_)
        else:
            return CT_Ribbon(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_qat(self):
        return self.qat
    def set_qat(self, qat):
        self.qat = qat
    def get_tabs(self):
        return self.tabs
    def set_tabs(self, tabs):
        self.tabs = tabs
    def get_contextualTabs(self):
        return self.contextualTabs
    def set_contextualTabs(self, contextualTabs):
        self.contextualTabs = contextualTabs
    def get_startFromScratch(self):
        return self.startFromScratch
    def set_startFromScratch(self, startFromScratch):
        self.startFromScratch = startFromScratch
    def hasContent_(self):
        if (
            self.qat is not None or
            self.tabs is not None or
            self.contextualTabs is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_Ribbon', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_Ribbon')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_Ribbon')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_Ribbon', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_Ribbon'):
        if self.startFromScratch is not None and 'startFromScratch' not in already_processed:
            already_processed.add('startFromScratch')
            outfile.write(' startFromScratch="%s"' % self.gds_format_boolean(self.startFromScratch, input_name='startFromScratch'))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_Ribbon', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.qat is not None:
            namespaceprefix_ = self.qat_nsprefix_ + ':' if (UseCapturedNS_ and self.qat_nsprefix_) else ''
            self.qat.export(outfile, level, namespaceprefix_, namespacedef_='', name_='qat', pretty_print=pretty_print)
        if self.tabs is not None:
            namespaceprefix_ = self.tabs_nsprefix_ + ':' if (UseCapturedNS_ and self.tabs_nsprefix_) else ''
            self.tabs.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tabs', pretty_print=pretty_print)
        if self.contextualTabs is not None:
            namespaceprefix_ = self.contextualTabs_nsprefix_ + ':' if (UseCapturedNS_ and self.contextualTabs_nsprefix_) else ''
            self.contextualTabs.export(outfile, level, namespaceprefix_, namespacedef_='', name_='contextualTabs', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('startFromScratch', node)
        if value is not None and 'startFromScratch' not in already_processed:
            already_processed.add('startFromScratch')
            if value in ('true', '1'):
                self.startFromScratch = True
            elif value in ('false', '0'):
                self.startFromScratch = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'qat':
            obj_ = CT_Qat.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.qat = obj_
            obj_.original_tagname_ = 'qat'
        elif nodeName_ == 'tabs':
            obj_ = CT_Tabs.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tabs = obj_
            obj_.original_tagname_ = 'tabs'
        elif nodeName_ == 'contextualTabs':
            obj_ = CT_ContextualTabs.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contextualTabs = obj_
            obj_.original_tagname_ = 'contextualTabs'
# end class CT_Ribbon


class CT_ContextMenus(GeneratedsSuper):
    """Specifies a collection of ContextMenus."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, contextMenu=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if contextMenu is None:
            self.contextMenu = []
        else:
            self.contextMenu = contextMenu
        self.contextMenu_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_ContextMenus)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_ContextMenus.subclass:
            return CT_ContextMenus.subclass(*args_, **kwargs_)
        else:
            return CT_ContextMenus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_contextMenu(self):
        return self.contextMenu
    def set_contextMenu(self, contextMenu):
        self.contextMenu = contextMenu
    def add_contextMenu(self, value):
        self.contextMenu.append(value)
    def insert_contextMenu_at(self, index, value):
        self.contextMenu.insert(index, value)
    def replace_contextMenu_at(self, index, value):
        self.contextMenu[index] = value
    def hasContent_(self):
        if (
            self.contextMenu
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_ContextMenus', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_ContextMenus')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_ContextMenus')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_ContextMenus', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_ContextMenus'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_ContextMenus', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for contextMenu_ in self.contextMenu:
            namespaceprefix_ = self.contextMenu_nsprefix_ + ':' if (UseCapturedNS_ and self.contextMenu_nsprefix_) else ''
            contextMenu_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='contextMenu', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'contextMenu':
            obj_ = CT_ContextMenu.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contextMenu.append(obj_)
            obj_.original_tagname_ = 'contextMenu'
# end class CT_ContextMenus


class CT_MenuRoot(GeneratedsSuper):
    """Specifies the root element of the customization XML returned by
    dynamicMenus.
    Specifies size of menu items."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, itemSize=None, title=None, getTitle=None, control=None, button=None, checkBox=None, gallery=None, toggleButton=None, menuSeparator=None, splitButton=None, menu=None, dynamicMenu=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.itemSize = _cast(None, itemSize)
        self.itemSize_nsprefix_ = None
        self.title = _cast(None, title)
        self.title_nsprefix_ = None
        self.getTitle = _cast(None, getTitle)
        self.getTitle_nsprefix_ = None
        if control is None:
            self.control = []
        else:
            self.control = control
        self.control_nsprefix_ = None
        if button is None:
            self.button = []
        else:
            self.button = button
        self.button_nsprefix_ = None
        if checkBox is None:
            self.checkBox = []
        else:
            self.checkBox = checkBox
        self.checkBox_nsprefix_ = None
        if gallery is None:
            self.gallery = []
        else:
            self.gallery = gallery
        self.gallery_nsprefix_ = None
        if toggleButton is None:
            self.toggleButton = []
        else:
            self.toggleButton = toggleButton
        self.toggleButton_nsprefix_ = None
        if menuSeparator is None:
            self.menuSeparator = []
        else:
            self.menuSeparator = menuSeparator
        self.menuSeparator_nsprefix_ = None
        if splitButton is None:
            self.splitButton = []
        else:
            self.splitButton = splitButton
        self.splitButton_nsprefix_ = None
        if menu is None:
            self.menu = []
        else:
            self.menu = menu
        self.menu_nsprefix_ = None
        if dynamicMenu is None:
            self.dynamicMenu = []
        else:
            self.dynamicMenu = dynamicMenu
        self.dynamicMenu_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_MenuRoot)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_MenuRoot.subclass:
            return CT_MenuRoot.subclass(*args_, **kwargs_)
        else:
            return CT_MenuRoot(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_control(self):
        return self.control
    def set_control(self, control):
        self.control = control
    def add_control(self, value):
        self.control.append(value)
    def insert_control_at(self, index, value):
        self.control.insert(index, value)
    def replace_control_at(self, index, value):
        self.control[index] = value
    def get_button(self):
        return self.button
    def set_button(self, button):
        self.button = button
    def add_button(self, value):
        self.button.append(value)
    def insert_button_at(self, index, value):
        self.button.insert(index, value)
    def replace_button_at(self, index, value):
        self.button[index] = value
    def get_checkBox(self):
        return self.checkBox
    def set_checkBox(self, checkBox):
        self.checkBox = checkBox
    def add_checkBox(self, value):
        self.checkBox.append(value)
    def insert_checkBox_at(self, index, value):
        self.checkBox.insert(index, value)
    def replace_checkBox_at(self, index, value):
        self.checkBox[index] = value
    def get_gallery(self):
        return self.gallery
    def set_gallery(self, gallery):
        self.gallery = gallery
    def add_gallery(self, value):
        self.gallery.append(value)
    def insert_gallery_at(self, index, value):
        self.gallery.insert(index, value)
    def replace_gallery_at(self, index, value):
        self.gallery[index] = value
    def get_toggleButton(self):
        return self.toggleButton
    def set_toggleButton(self, toggleButton):
        self.toggleButton = toggleButton
    def add_toggleButton(self, value):
        self.toggleButton.append(value)
    def insert_toggleButton_at(self, index, value):
        self.toggleButton.insert(index, value)
    def replace_toggleButton_at(self, index, value):
        self.toggleButton[index] = value
    def get_menuSeparator(self):
        return self.menuSeparator
    def set_menuSeparator(self, menuSeparator):
        self.menuSeparator = menuSeparator
    def add_menuSeparator(self, value):
        self.menuSeparator.append(value)
    def insert_menuSeparator_at(self, index, value):
        self.menuSeparator.insert(index, value)
    def replace_menuSeparator_at(self, index, value):
        self.menuSeparator[index] = value
    def get_splitButton(self):
        return self.splitButton
    def set_splitButton(self, splitButton):
        self.splitButton = splitButton
    def add_splitButton(self, value):
        self.splitButton.append(value)
    def insert_splitButton_at(self, index, value):
        self.splitButton.insert(index, value)
    def replace_splitButton_at(self, index, value):
        self.splitButton[index] = value
    def get_menu(self):
        return self.menu
    def set_menu(self, menu):
        self.menu = menu
    def add_menu(self, value):
        self.menu.append(value)
    def insert_menu_at(self, index, value):
        self.menu.insert(index, value)
    def replace_menu_at(self, index, value):
        self.menu[index] = value
    def get_dynamicMenu(self):
        return self.dynamicMenu
    def set_dynamicMenu(self, dynamicMenu):
        self.dynamicMenu = dynamicMenu
    def add_dynamicMenu(self, value):
        self.dynamicMenu.append(value)
    def insert_dynamicMenu_at(self, index, value):
        self.dynamicMenu.insert(index, value)
    def replace_dynamicMenu_at(self, index, value):
        self.dynamicMenu[index] = value
    def get_itemSize(self):
        return self.itemSize
    def set_itemSize(self, itemSize):
        self.itemSize = itemSize
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_getTitle(self):
        return self.getTitle
    def set_getTitle(self, getTitle):
        self.getTitle = getTitle
    def validate_ST_ItemSize(self, value):
        # Validate type ST_ItemSize, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'large']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ST_ItemSize' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.control or
            self.button or
            self.checkBox or
            self.gallery or
            self.toggleButton or
            self.menuSeparator or
            self.splitButton or
            self.menu or
            self.dynamicMenu
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_MenuRoot', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_MenuRoot')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_MenuRoot')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_MenuRoot', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_MenuRoot'):
        if self.itemSize is not None and 'itemSize' not in already_processed:
            already_processed.add('itemSize')
            outfile.write(' itemSize=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.itemSize), input_name='itemSize')), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.title), input_name='title')), ))
        if self.getTitle is not None and 'getTitle' not in already_processed:
            already_processed.add('getTitle')
            outfile.write(' getTitle=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getTitle), input_name='getTitle')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_MenuRoot', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for control_ in self.control:
            namespaceprefix_ = self.control_nsprefix_ + ':' if (UseCapturedNS_ and self.control_nsprefix_) else ''
            control_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='control', pretty_print=pretty_print)
        for button_ in self.button:
            namespaceprefix_ = self.button_nsprefix_ + ':' if (UseCapturedNS_ and self.button_nsprefix_) else ''
            button_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='button', pretty_print=pretty_print)
        for checkBox_ in self.checkBox:
            namespaceprefix_ = self.checkBox_nsprefix_ + ':' if (UseCapturedNS_ and self.checkBox_nsprefix_) else ''
            checkBox_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='checkBox', pretty_print=pretty_print)
        for gallery_ in self.gallery:
            namespaceprefix_ = self.gallery_nsprefix_ + ':' if (UseCapturedNS_ and self.gallery_nsprefix_) else ''
            gallery_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='gallery', pretty_print=pretty_print)
        for toggleButton_ in self.toggleButton:
            namespaceprefix_ = self.toggleButton_nsprefix_ + ':' if (UseCapturedNS_ and self.toggleButton_nsprefix_) else ''
            toggleButton_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='toggleButton', pretty_print=pretty_print)
        for menuSeparator_ in self.menuSeparator:
            namespaceprefix_ = self.menuSeparator_nsprefix_ + ':' if (UseCapturedNS_ and self.menuSeparator_nsprefix_) else ''
            menuSeparator_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='menuSeparator', pretty_print=pretty_print)
        for splitButton_ in self.splitButton:
            namespaceprefix_ = self.splitButton_nsprefix_ + ':' if (UseCapturedNS_ and self.splitButton_nsprefix_) else ''
            splitButton_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='splitButton', pretty_print=pretty_print)
        for menu_ in self.menu:
            namespaceprefix_ = self.menu_nsprefix_ + ':' if (UseCapturedNS_ and self.menu_nsprefix_) else ''
            menu_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='menu', pretty_print=pretty_print)
        for dynamicMenu_ in self.dynamicMenu:
            namespaceprefix_ = self.dynamicMenu_nsprefix_ + ':' if (UseCapturedNS_ and self.dynamicMenu_nsprefix_) else ''
            dynamicMenu_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dynamicMenu', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('itemSize', node)
        if value is not None and 'itemSize' not in already_processed:
            already_processed.add('itemSize')
            self.itemSize = value
            self.validate_ST_ItemSize(self.itemSize)    # validate type ST_ItemSize
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
            self.validate_ST_String(self.title)    # validate type ST_String
        value = find_attr_value_('getTitle', node)
        if value is not None and 'getTitle' not in already_processed:
            already_processed.add('getTitle')
            self.getTitle = value
            self.validate_ST_Delegate(self.getTitle)    # validate type ST_Delegate
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'control':
            obj_ = CT_ControlCloneRegular.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.control.append(obj_)
            obj_.original_tagname_ = 'control'
        elif nodeName_ == 'button':
            class_obj_ = self.get_class_obj_(child_, CT_ButtonRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.button.append(obj_)
            obj_.original_tagname_ = 'button'
        elif nodeName_ == 'checkBox':
            obj_ = CT_CheckBox.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.checkBox.append(obj_)
            obj_.original_tagname_ = 'checkBox'
        elif nodeName_ == 'gallery':
            class_obj_ = self.get_class_obj_(child_, CT_GalleryRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gallery.append(obj_)
            obj_.original_tagname_ = 'gallery'
        elif nodeName_ == 'toggleButton':
            class_obj_ = self.get_class_obj_(child_, CT_ToggleButtonRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.toggleButton.append(obj_)
            obj_.original_tagname_ = 'toggleButton'
        elif nodeName_ == 'menuSeparator':
            obj_ = CT_MenuSeparator.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.menuSeparator.append(obj_)
            obj_.original_tagname_ = 'menuSeparator'
        elif nodeName_ == 'splitButton':
            class_obj_ = self.get_class_obj_(child_, CT_SplitButtonRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.splitButton.append(obj_)
            obj_.original_tagname_ = 'splitButton'
        elif nodeName_ == 'menu':
            class_obj_ = self.get_class_obj_(child_, CT_MenuRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.menu.append(obj_)
            obj_.original_tagname_ = 'menu'
        elif nodeName_ == 'dynamicMenu':
            class_obj_ = self.get_class_obj_(child_, CT_DynamicMenuRegular)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dynamicMenu.append(obj_)
            obj_.original_tagname_ = 'dynamicMenu'
# end class CT_MenuRoot


class CT_BackstageButtonBase(GeneratedsSuper):
    """Specifies a generic button in the Backstage"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, idQ=None, tag=None, onAction=None, isDefinitive=None, enabled=None, getEnabled=None, label=None, getLabel=None, visible=None, getVisible=None, keytip=None, getKeytip=None, image=None, imageMso=None, getImage=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.onAction = _cast(None, onAction)
        self.onAction_nsprefix_ = None
        self.isDefinitive = _cast(bool, isDefinitive)
        self.isDefinitive_nsprefix_ = None
        self.enabled = _cast(bool, enabled)
        self.enabled_nsprefix_ = None
        self.getEnabled = _cast(None, getEnabled)
        self.getEnabled_nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.getLabel = _cast(None, getLabel)
        self.getLabel_nsprefix_ = None
        self.visible = _cast(bool, visible)
        self.visible_nsprefix_ = None
        self.getVisible = _cast(None, getVisible)
        self.getVisible_nsprefix_ = None
        self.keytip = _cast(None, keytip)
        self.keytip_nsprefix_ = None
        self.getKeytip = _cast(None, getKeytip)
        self.getKeytip_nsprefix_ = None
        self.image = _cast(None, image)
        self.image_nsprefix_ = None
        self.imageMso = _cast(None, imageMso)
        self.imageMso_nsprefix_ = None
        self.getImage = _cast(None, getImage)
        self.getImage_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_BackstageButtonBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_BackstageButtonBase.subclass:
            return CT_BackstageButtonBase.subclass(*args_, **kwargs_)
        else:
            return CT_BackstageButtonBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_onAction(self):
        return self.onAction
    def set_onAction(self, onAction):
        self.onAction = onAction
    def get_isDefinitive(self):
        return self.isDefinitive
    def set_isDefinitive(self, isDefinitive):
        self.isDefinitive = isDefinitive
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    def get_getEnabled(self):
        return self.getEnabled
    def set_getEnabled(self, getEnabled):
        self.getEnabled = getEnabled
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_getLabel(self):
        return self.getLabel
    def set_getLabel(self, getLabel):
        self.getLabel = getLabel
    def get_visible(self):
        return self.visible
    def set_visible(self, visible):
        self.visible = visible
    def get_getVisible(self):
        return self.getVisible
    def set_getVisible(self, getVisible):
        self.getVisible = getVisible
    def get_keytip(self):
        return self.keytip
    def set_keytip(self, keytip):
        self.keytip = keytip
    def get_getKeytip(self):
        return self.getKeytip
    def set_getKeytip(self, getKeytip):
        self.getKeytip = getKeytip
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def get_imageMso(self):
        return self.imageMso
    def set_imageMso(self, imageMso):
        self.imageMso = imageMso
    def get_getImage(self):
        return self.getImage
    def set_getImage(self, getImage):
        self.getImage = getImage
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Keytip(self, value):
        # Validate type ST_Keytip, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Keytip' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Keytip' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_Uri(self, value):
        # Validate type ST_Uri, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Uri' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Uri' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_BackstageButtonBase', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_BackstageButtonBase')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_BackstageButtonBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_BackstageButtonBase', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_BackstageButtonBase'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.onAction is not None and 'onAction' not in already_processed:
            already_processed.add('onAction')
            outfile.write(' onAction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.onAction), input_name='onAction')), ))
        if self.isDefinitive is not None and 'isDefinitive' not in already_processed:
            already_processed.add('isDefinitive')
            outfile.write(' isDefinitive="%s"' % self.gds_format_boolean(self.isDefinitive, input_name='isDefinitive'))
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            outfile.write(' enabled="%s"' % self.gds_format_boolean(self.enabled, input_name='enabled'))
        if self.getEnabled is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            outfile.write(' getEnabled=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getEnabled), input_name='getEnabled')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.getLabel is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            outfile.write(' getLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getLabel), input_name='getLabel')), ))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            outfile.write(' visible="%s"' % self.gds_format_boolean(self.visible, input_name='visible'))
        if self.getVisible is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            outfile.write(' getVisible=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getVisible), input_name='getVisible')), ))
        if self.keytip is not None and 'keytip' not in already_processed:
            already_processed.add('keytip')
            outfile.write(' keytip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.keytip), input_name='keytip')), ))
        if self.getKeytip is not None and 'getKeytip' not in already_processed:
            already_processed.add('getKeytip')
            outfile.write(' getKeytip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getKeytip), input_name='getKeytip')), ))
        if self.image is not None and 'image' not in already_processed:
            already_processed.add('image')
            outfile.write(' image=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.image), input_name='image')), ))
        if self.imageMso is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            outfile.write(' imageMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.imageMso), input_name='imageMso')), ))
        if self.getImage is not None and 'getImage' not in already_processed:
            already_processed.add('getImage')
            outfile.write(' getImage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getImage), input_name='getImage')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_BackstageButtonBase', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('onAction', node)
        if value is not None and 'onAction' not in already_processed:
            already_processed.add('onAction')
            self.onAction = value
            self.validate_ST_Delegate(self.onAction)    # validate type ST_Delegate
        value = find_attr_value_('isDefinitive', node)
        if value is not None and 'isDefinitive' not in already_processed:
            already_processed.add('isDefinitive')
            if value in ('true', '1'):
                self.isDefinitive = True
            elif value in ('false', '0'):
                self.isDefinitive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('enabled', node)
        if value is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            if value in ('true', '1'):
                self.enabled = True
            elif value in ('false', '0'):
                self.enabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getEnabled', node)
        if value is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            self.getEnabled = value
            self.validate_ST_Delegate(self.getEnabled)    # validate type ST_Delegate
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
            self.validate_ST_String(self.label)    # validate type ST_String
        value = find_attr_value_('getLabel', node)
        if value is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            self.getLabel = value
            self.validate_ST_Delegate(self.getLabel)    # validate type ST_Delegate
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            if value in ('true', '1'):
                self.visible = True
            elif value in ('false', '0'):
                self.visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getVisible', node)
        if value is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            self.getVisible = value
            self.validate_ST_Delegate(self.getVisible)    # validate type ST_Delegate
        value = find_attr_value_('keytip', node)
        if value is not None and 'keytip' not in already_processed:
            already_processed.add('keytip')
            self.keytip = value
            self.keytip = ' '.join(self.keytip.split())
            self.validate_ST_Keytip(self.keytip)    # validate type ST_Keytip
        value = find_attr_value_('getKeytip', node)
        if value is not None and 'getKeytip' not in already_processed:
            already_processed.add('getKeytip')
            self.getKeytip = value
            self.validate_ST_Delegate(self.getKeytip)    # validate type ST_Delegate
        value = find_attr_value_('image', node)
        if value is not None and 'image' not in already_processed:
            already_processed.add('image')
            self.image = value
            self.validate_ST_Uri(self.image)    # validate type ST_Uri
        value = find_attr_value_('imageMso', node)
        if value is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            self.imageMso = value
            self.validate_ST_ID(self.imageMso)    # validate type ST_ID
        value = find_attr_value_('getImage', node)
        if value is not None and 'getImage' not in already_processed:
            already_processed.add('getImage')
            self.getImage = value
            self.validate_ST_Delegate(self.getImage)    # validate type ST_Delegate
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CT_BackstageButtonBase


class CT_BackstageRegularButton(CT_BackstageButtonBase):
    """A BackstageButtonBase which additionally has the screentip attributes"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_BackstageButtonBase
    def __init__(self, id=None, idQ=None, tag=None, onAction=None, isDefinitive=None, enabled=None, getEnabled=None, label=None, getLabel=None, visible=None, getVisible=None, keytip=None, getKeytip=None, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_BackstageRegularButton, self).__init__(id, idQ, tag, onAction, isDefinitive, enabled, getEnabled, label, getLabel, visible, getVisible, keytip, getKeytip, image, imageMso, getImage, extensiontype_,  **kwargs_)
        self.screentip = _cast(None, screentip)
        self.screentip_nsprefix_ = None
        self.getScreentip = _cast(None, getScreentip)
        self.getScreentip_nsprefix_ = None
        self.supertip = _cast(None, supertip)
        self.supertip_nsprefix_ = None
        self.getSupertip = _cast(None, getSupertip)
        self.getSupertip_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_BackstageRegularButton)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_BackstageRegularButton.subclass:
            return CT_BackstageRegularButton.subclass(*args_, **kwargs_)
        else:
            return CT_BackstageRegularButton(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_screentip(self):
        return self.screentip
    def set_screentip(self, screentip):
        self.screentip = screentip
    def get_getScreentip(self):
        return self.getScreentip
    def set_getScreentip(self, getScreentip):
        self.getScreentip = getScreentip
    def get_supertip(self):
        return self.supertip
    def set_supertip(self, supertip):
        self.supertip = supertip
    def get_getSupertip(self):
        return self.getSupertip
    def set_getSupertip(self, getSupertip):
        self.getSupertip = getSupertip
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(CT_BackstageRegularButton, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_BackstageRegularButton', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_BackstageRegularButton')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_BackstageRegularButton')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_BackstageRegularButton', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_BackstageRegularButton'):
        super(CT_BackstageRegularButton, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_BackstageRegularButton')
        if self.screentip is not None and 'screentip' not in already_processed:
            already_processed.add('screentip')
            outfile.write(' screentip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.screentip), input_name='screentip')), ))
        if self.getScreentip is not None and 'getScreentip' not in already_processed:
            already_processed.add('getScreentip')
            outfile.write(' getScreentip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getScreentip), input_name='getScreentip')), ))
        if self.supertip is not None and 'supertip' not in already_processed:
            already_processed.add('supertip')
            outfile.write(' supertip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.supertip), input_name='supertip')), ))
        if self.getSupertip is not None and 'getSupertip' not in already_processed:
            already_processed.add('getSupertip')
            outfile.write(' getSupertip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getSupertip), input_name='getSupertip')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_BackstageRegularButton', fromsubclass_=False, pretty_print=True):
        super(CT_BackstageRegularButton, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('screentip', node)
        if value is not None and 'screentip' not in already_processed:
            already_processed.add('screentip')
            self.screentip = value
            self.validate_ST_String(self.screentip)    # validate type ST_String
        value = find_attr_value_('getScreentip', node)
        if value is not None and 'getScreentip' not in already_processed:
            already_processed.add('getScreentip')
            self.getScreentip = value
            self.validate_ST_Delegate(self.getScreentip)    # validate type ST_Delegate
        value = find_attr_value_('supertip', node)
        if value is not None and 'supertip' not in already_processed:
            already_processed.add('supertip')
            self.supertip = value
            self.validate_ST_String(self.supertip)    # validate type ST_String
        value = find_attr_value_('getSupertip', node)
        if value is not None and 'getSupertip' not in already_processed:
            already_processed.add('getSupertip')
            self.getSupertip = value
            self.validate_ST_Delegate(self.getSupertip)    # validate type ST_Delegate
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CT_BackstageRegularButton, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CT_BackstageRegularButton, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CT_BackstageRegularButton


class CT_BackstageGroupButton(CT_BackstageRegularButton):
    """A BackstageRegularButton that additionally has the group layout
    attributes"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_BackstageRegularButton
    def __init__(self, id=None, idQ=None, tag=None, onAction=None, isDefinitive=None, enabled=None, getEnabled=None, label=None, getLabel=None, visible=None, getVisible=None, keytip=None, getKeytip=None, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, expand=None, style=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_BackstageGroupButton, self).__init__(id, idQ, tag, onAction, isDefinitive, enabled, getEnabled, label, getLabel, visible, getVisible, keytip, getKeytip, image, imageMso, getImage, screentip, getScreentip, supertip, getSupertip,  **kwargs_)
        self.expand = _cast(None, expand)
        self.expand_nsprefix_ = None
        self.style = _cast(None, style)
        self.style_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_BackstageGroupButton)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_BackstageGroupButton.subclass:
            return CT_BackstageGroupButton.subclass(*args_, **kwargs_)
        else:
            return CT_BackstageGroupButton(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_expand(self):
        return self.expand
    def set_expand(self, expand):
        self.expand = expand
    def get_style(self):
        return self.style
    def set_style(self, style):
        self.style = style
    def hasContent_(self):
        if (
            super(CT_BackstageGroupButton, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_BackstageGroupButton', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_BackstageGroupButton')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_BackstageGroupButton')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_BackstageGroupButton', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_BackstageGroupButton'):
        super(CT_BackstageGroupButton, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_BackstageGroupButton')
        if self.expand is not None and 'expand' not in already_processed:
            already_processed.add('expand')
            outfile.write(' expand=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.expand), input_name='expand')), ))
        if self.style is not None and 'style' not in already_processed:
            already_processed.add('style')
            outfile.write(' style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.style), input_name='style')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_BackstageGroupButton', fromsubclass_=False, pretty_print=True):
        super(CT_BackstageGroupButton, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('expand', node)
        if value is not None and 'expand' not in already_processed:
            already_processed.add('expand')
            self.expand = value
        value = find_attr_value_('style', node)
        if value is not None and 'style' not in already_processed:
            already_processed.add('style')
            self.style = value
        super(CT_BackstageGroupButton, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CT_BackstageGroupButton, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CT_BackstageGroupButton


class CT_BackstageMenuButton(CT_BackstageButtonBase):
    """A BackstageButtonBase which additionally has the description
    attributes"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_BackstageButtonBase
    def __init__(self, id=None, idQ=None, tag=None, onAction=None, isDefinitive=None, enabled=None, getEnabled=None, label=None, getLabel=None, visible=None, getVisible=None, keytip=None, getKeytip=None, image=None, imageMso=None, getImage=None, description=None, getDescription=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_BackstageMenuButton, self).__init__(id, idQ, tag, onAction, isDefinitive, enabled, getEnabled, label, getLabel, visible, getVisible, keytip, getKeytip, image, imageMso, getImage,  **kwargs_)
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
        self.getDescription = _cast(None, getDescription)
        self.getDescription_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_BackstageMenuButton)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_BackstageMenuButton.subclass:
            return CT_BackstageMenuButton.subclass(*args_, **kwargs_)
        else:
            return CT_BackstageMenuButton(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_getDescription(self):
        return self.getDescription
    def set_getDescription(self, getDescription):
        self.getDescription = getDescription
    def validate_ST_LongString(self, value):
        # Validate type ST_LongString, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_LongString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_LongString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(CT_BackstageMenuButton, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_BackstageMenuButton', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_BackstageMenuButton')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_BackstageMenuButton')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_BackstageMenuButton', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_BackstageMenuButton'):
        super(CT_BackstageMenuButton, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_BackstageMenuButton')
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.getDescription is not None and 'getDescription' not in already_processed:
            already_processed.add('getDescription')
            outfile.write(' getDescription=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getDescription), input_name='getDescription')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_BackstageMenuButton', fromsubclass_=False, pretty_print=True):
        super(CT_BackstageMenuButton, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
            self.validate_ST_LongString(self.description)    # validate type ST_LongString
        value = find_attr_value_('getDescription', node)
        if value is not None and 'getDescription' not in already_processed:
            already_processed.add('getDescription')
            self.getDescription = value
            self.validate_ST_Delegate(self.getDescription)    # validate type ST_Delegate
        super(CT_BackstageMenuButton, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CT_BackstageMenuButton, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CT_BackstageMenuButton


class CT_BackstageFastCommandButton(CT_BackstageButtonBase):
    """A BackstageRegularButton that also has FastCommand-related attributes"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_BackstageButtonBase
    def __init__(self, id=None, idQ=None, tag=None, onAction=None, isDefinitive=None, enabled=None, getEnabled=None, label=None, getLabel=None, visible=None, getVisible=None, keytip=None, getKeytip=None, image=None, imageMso=None, getImage=None, idMso=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_BackstageFastCommandButton, self).__init__(id, idQ, tag, onAction, isDefinitive, enabled, getEnabled, label, getLabel, visible, getVisible, keytip, getKeytip, image, imageMso, getImage,  **kwargs_)
        self.idMso = _cast(None, idMso)
        self.idMso_nsprefix_ = None
        self.insertAfterMso = _cast(None, insertAfterMso)
        self.insertAfterMso_nsprefix_ = None
        self.insertBeforeMso = _cast(None, insertBeforeMso)
        self.insertBeforeMso_nsprefix_ = None
        self.insertAfterQ = _cast(None, insertAfterQ)
        self.insertAfterQ_nsprefix_ = None
        self.insertBeforeQ = _cast(None, insertBeforeQ)
        self.insertBeforeQ_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_BackstageFastCommandButton)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_BackstageFastCommandButton.subclass:
            return CT_BackstageFastCommandButton.subclass(*args_, **kwargs_)
        else:
            return CT_BackstageFastCommandButton(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_idMso(self):
        return self.idMso
    def set_idMso(self, idMso):
        self.idMso = idMso
    def get_insertAfterMso(self):
        return self.insertAfterMso
    def set_insertAfterMso(self, insertAfterMso):
        self.insertAfterMso = insertAfterMso
    def get_insertBeforeMso(self):
        return self.insertBeforeMso
    def set_insertBeforeMso(self, insertBeforeMso):
        self.insertBeforeMso = insertBeforeMso
    def get_insertAfterQ(self):
        return self.insertAfterQ
    def set_insertAfterQ(self, insertAfterQ):
        self.insertAfterQ = insertAfterQ
    def get_insertBeforeQ(self):
        return self.insertBeforeQ
    def set_insertBeforeQ(self, insertBeforeQ):
        self.insertBeforeQ = insertBeforeQ
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(CT_BackstageFastCommandButton, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_BackstageFastCommandButton', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_BackstageFastCommandButton')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_BackstageFastCommandButton')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_BackstageFastCommandButton', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_BackstageFastCommandButton'):
        super(CT_BackstageFastCommandButton, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_BackstageFastCommandButton')
        if self.idMso is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            outfile.write(' idMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idMso), input_name='idMso')), ))
        if self.insertAfterMso is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            outfile.write(' insertAfterMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterMso), input_name='insertAfterMso')), ))
        if self.insertBeforeMso is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            outfile.write(' insertBeforeMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeMso), input_name='insertBeforeMso')), ))
        if self.insertAfterQ is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            outfile.write(' insertAfterQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterQ), input_name='insertAfterQ')), ))
        if self.insertBeforeQ is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            outfile.write(' insertBeforeQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeQ), input_name='insertBeforeQ')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_BackstageFastCommandButton', fromsubclass_=False, pretty_print=True):
        super(CT_BackstageFastCommandButton, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('idMso', node)
        if value is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            self.idMso = value
            self.validate_ST_ID(self.idMso)    # validate type ST_ID
        value = find_attr_value_('insertAfterMso', node)
        if value is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            self.insertAfterMso = value
            self.validate_ST_ID(self.insertAfterMso)    # validate type ST_ID
        value = find_attr_value_('insertBeforeMso', node)
        if value is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            self.insertBeforeMso = value
            self.validate_ST_ID(self.insertBeforeMso)    # validate type ST_ID
        value = find_attr_value_('insertAfterQ', node)
        if value is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            self.insertAfterQ = value
            self.validate_ST_QID(self.insertAfterQ)    # validate type ST_QID
        value = find_attr_value_('insertBeforeQ', node)
        if value is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            self.insertBeforeQ = value
            self.validate_ST_QID(self.insertBeforeQ)    # validate type ST_QID
        super(CT_BackstageFastCommandButton, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CT_BackstageFastCommandButton, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CT_BackstageFastCommandButton


class CT_BackstageCheckBoxBase(GeneratedsSuper):
    """Specifies a generic CheckBox in the Backstage"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, idQ=None, tag=None, onAction=None, getPressed=None, enabled=None, getEnabled=None, label=None, getLabel=None, visible=None, getVisible=None, keytip=None, getKeytip=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.onAction = _cast(None, onAction)
        self.onAction_nsprefix_ = None
        self.getPressed = _cast(None, getPressed)
        self.getPressed_nsprefix_ = None
        self.enabled = _cast(bool, enabled)
        self.enabled_nsprefix_ = None
        self.getEnabled = _cast(None, getEnabled)
        self.getEnabled_nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.getLabel = _cast(None, getLabel)
        self.getLabel_nsprefix_ = None
        self.visible = _cast(bool, visible)
        self.visible_nsprefix_ = None
        self.getVisible = _cast(None, getVisible)
        self.getVisible_nsprefix_ = None
        self.keytip = _cast(None, keytip)
        self.keytip_nsprefix_ = None
        self.getKeytip = _cast(None, getKeytip)
        self.getKeytip_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_BackstageCheckBoxBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_BackstageCheckBoxBase.subclass:
            return CT_BackstageCheckBoxBase.subclass(*args_, **kwargs_)
        else:
            return CT_BackstageCheckBoxBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_onAction(self):
        return self.onAction
    def set_onAction(self, onAction):
        self.onAction = onAction
    def get_getPressed(self):
        return self.getPressed
    def set_getPressed(self, getPressed):
        self.getPressed = getPressed
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    def get_getEnabled(self):
        return self.getEnabled
    def set_getEnabled(self, getEnabled):
        self.getEnabled = getEnabled
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_getLabel(self):
        return self.getLabel
    def set_getLabel(self, getLabel):
        self.getLabel = getLabel
    def get_visible(self):
        return self.visible
    def set_visible(self, visible):
        self.visible = visible
    def get_getVisible(self):
        return self.getVisible
    def set_getVisible(self, getVisible):
        self.getVisible = getVisible
    def get_keytip(self):
        return self.keytip
    def set_keytip(self, keytip):
        self.keytip = keytip
    def get_getKeytip(self):
        return self.getKeytip
    def set_getKeytip(self, getKeytip):
        self.getKeytip = getKeytip
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Keytip(self, value):
        # Validate type ST_Keytip, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Keytip' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Keytip' % {"value" : value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_BackstageCheckBoxBase', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_BackstageCheckBoxBase')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_BackstageCheckBoxBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_BackstageCheckBoxBase', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_BackstageCheckBoxBase'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.onAction is not None and 'onAction' not in already_processed:
            already_processed.add('onAction')
            outfile.write(' onAction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.onAction), input_name='onAction')), ))
        if self.getPressed is not None and 'getPressed' not in already_processed:
            already_processed.add('getPressed')
            outfile.write(' getPressed=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getPressed), input_name='getPressed')), ))
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            outfile.write(' enabled="%s"' % self.gds_format_boolean(self.enabled, input_name='enabled'))
        if self.getEnabled is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            outfile.write(' getEnabled=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getEnabled), input_name='getEnabled')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.getLabel is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            outfile.write(' getLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getLabel), input_name='getLabel')), ))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            outfile.write(' visible="%s"' % self.gds_format_boolean(self.visible, input_name='visible'))
        if self.getVisible is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            outfile.write(' getVisible=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getVisible), input_name='getVisible')), ))
        if self.keytip is not None and 'keytip' not in already_processed:
            already_processed.add('keytip')
            outfile.write(' keytip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.keytip), input_name='keytip')), ))
        if self.getKeytip is not None and 'getKeytip' not in already_processed:
            already_processed.add('getKeytip')
            outfile.write(' getKeytip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getKeytip), input_name='getKeytip')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_BackstageCheckBoxBase', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('onAction', node)
        if value is not None and 'onAction' not in already_processed:
            already_processed.add('onAction')
            self.onAction = value
            self.validate_ST_Delegate(self.onAction)    # validate type ST_Delegate
        value = find_attr_value_('getPressed', node)
        if value is not None and 'getPressed' not in already_processed:
            already_processed.add('getPressed')
            self.getPressed = value
            self.validate_ST_Delegate(self.getPressed)    # validate type ST_Delegate
        value = find_attr_value_('enabled', node)
        if value is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            if value in ('true', '1'):
                self.enabled = True
            elif value in ('false', '0'):
                self.enabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getEnabled', node)
        if value is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            self.getEnabled = value
            self.validate_ST_Delegate(self.getEnabled)    # validate type ST_Delegate
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
            self.validate_ST_String(self.label)    # validate type ST_String
        value = find_attr_value_('getLabel', node)
        if value is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            self.getLabel = value
            self.validate_ST_Delegate(self.getLabel)    # validate type ST_Delegate
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            if value in ('true', '1'):
                self.visible = True
            elif value in ('false', '0'):
                self.visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getVisible', node)
        if value is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            self.getVisible = value
            self.validate_ST_Delegate(self.getVisible)    # validate type ST_Delegate
        value = find_attr_value_('keytip', node)
        if value is not None and 'keytip' not in already_processed:
            already_processed.add('keytip')
            self.keytip = value
            self.keytip = ' '.join(self.keytip.split())
            self.validate_ST_Keytip(self.keytip)    # validate type ST_Keytip
        value = find_attr_value_('getKeytip', node)
        if value is not None and 'getKeytip' not in already_processed:
            already_processed.add('getKeytip')
            self.getKeytip = value
            self.validate_ST_Delegate(self.getKeytip)    # validate type ST_Delegate
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CT_BackstageCheckBoxBase


class CT_BackstageCheckBox(CT_BackstageCheckBoxBase):
    """A BackstageCheckBox which has the additional attributes for group
    controls"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_BackstageCheckBoxBase
    def __init__(self, id=None, idQ=None, tag=None, onAction=None, getPressed=None, enabled=None, getEnabled=None, label=None, getLabel=None, visible=None, getVisible=None, keytip=None, getKeytip=None, expand=None, description=None, getDescription=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_BackstageCheckBox, self).__init__(id, idQ, tag, onAction, getPressed, enabled, getEnabled, label, getLabel, visible, getVisible, keytip, getKeytip,  **kwargs_)
        self.expand = _cast(None, expand)
        self.expand_nsprefix_ = None
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
        self.getDescription = _cast(None, getDescription)
        self.getDescription_nsprefix_ = None
        self.screentip = _cast(None, screentip)
        self.screentip_nsprefix_ = None
        self.getScreentip = _cast(None, getScreentip)
        self.getScreentip_nsprefix_ = None
        self.supertip = _cast(None, supertip)
        self.supertip_nsprefix_ = None
        self.getSupertip = _cast(None, getSupertip)
        self.getSupertip_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_BackstageCheckBox)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_BackstageCheckBox.subclass:
            return CT_BackstageCheckBox.subclass(*args_, **kwargs_)
        else:
            return CT_BackstageCheckBox(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_expand(self):
        return self.expand
    def set_expand(self, expand):
        self.expand = expand
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_getDescription(self):
        return self.getDescription
    def set_getDescription(self, getDescription):
        self.getDescription = getDescription
    def get_screentip(self):
        return self.screentip
    def set_screentip(self, screentip):
        self.screentip = screentip
    def get_getScreentip(self):
        return self.getScreentip
    def set_getScreentip(self, getScreentip):
        self.getScreentip = getScreentip
    def get_supertip(self):
        return self.supertip
    def set_supertip(self, supertip):
        self.supertip = supertip
    def get_getSupertip(self):
        return self.getSupertip
    def set_getSupertip(self, getSupertip):
        self.getSupertip = getSupertip
    def validate_ST_LongString(self, value):
        # Validate type ST_LongString, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_LongString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_LongString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(CT_BackstageCheckBox, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_BackstageCheckBox', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_BackstageCheckBox')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_BackstageCheckBox')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_BackstageCheckBox', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_BackstageCheckBox'):
        super(CT_BackstageCheckBox, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_BackstageCheckBox')
        if self.expand is not None and 'expand' not in already_processed:
            already_processed.add('expand')
            outfile.write(' expand=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.expand), input_name='expand')), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.getDescription is not None and 'getDescription' not in already_processed:
            already_processed.add('getDescription')
            outfile.write(' getDescription=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getDescription), input_name='getDescription')), ))
        if self.screentip is not None and 'screentip' not in already_processed:
            already_processed.add('screentip')
            outfile.write(' screentip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.screentip), input_name='screentip')), ))
        if self.getScreentip is not None and 'getScreentip' not in already_processed:
            already_processed.add('getScreentip')
            outfile.write(' getScreentip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getScreentip), input_name='getScreentip')), ))
        if self.supertip is not None and 'supertip' not in already_processed:
            already_processed.add('supertip')
            outfile.write(' supertip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.supertip), input_name='supertip')), ))
        if self.getSupertip is not None and 'getSupertip' not in already_processed:
            already_processed.add('getSupertip')
            outfile.write(' getSupertip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getSupertip), input_name='getSupertip')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_BackstageCheckBox', fromsubclass_=False, pretty_print=True):
        super(CT_BackstageCheckBox, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('expand', node)
        if value is not None and 'expand' not in already_processed:
            already_processed.add('expand')
            self.expand = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
            self.validate_ST_LongString(self.description)    # validate type ST_LongString
        value = find_attr_value_('getDescription', node)
        if value is not None and 'getDescription' not in already_processed:
            already_processed.add('getDescription')
            self.getDescription = value
            self.validate_ST_Delegate(self.getDescription)    # validate type ST_Delegate
        value = find_attr_value_('screentip', node)
        if value is not None and 'screentip' not in already_processed:
            already_processed.add('screentip')
            self.screentip = value
            self.validate_ST_String(self.screentip)    # validate type ST_String
        value = find_attr_value_('getScreentip', node)
        if value is not None and 'getScreentip' not in already_processed:
            already_processed.add('getScreentip')
            self.getScreentip = value
            self.validate_ST_Delegate(self.getScreentip)    # validate type ST_Delegate
        value = find_attr_value_('supertip', node)
        if value is not None and 'supertip' not in already_processed:
            already_processed.add('supertip')
            self.supertip = value
            self.validate_ST_String(self.supertip)    # validate type ST_String
        value = find_attr_value_('getSupertip', node)
        if value is not None and 'getSupertip' not in already_processed:
            already_processed.add('getSupertip')
            self.getSupertip = value
            self.validate_ST_Delegate(self.getSupertip)    # validate type ST_Delegate
        super(CT_BackstageCheckBox, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CT_BackstageCheckBox, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CT_BackstageCheckBox


class CT_BackstageMenuCheckBox(CT_BackstageCheckBoxBase):
    """A BackstageCheckBox which exists in a primary menu"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_BackstageCheckBoxBase
    def __init__(self, id=None, idQ=None, tag=None, onAction=None, getPressed=None, enabled=None, getEnabled=None, label=None, getLabel=None, visible=None, getVisible=None, keytip=None, getKeytip=None, description=None, getDescription=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_BackstageMenuCheckBox, self).__init__(id, idQ, tag, onAction, getPressed, enabled, getEnabled, label, getLabel, visible, getVisible, keytip, getKeytip, extensiontype_,  **kwargs_)
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
        self.getDescription = _cast(None, getDescription)
        self.getDescription_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_BackstageMenuCheckBox)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_BackstageMenuCheckBox.subclass:
            return CT_BackstageMenuCheckBox.subclass(*args_, **kwargs_)
        else:
            return CT_BackstageMenuCheckBox(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_getDescription(self):
        return self.getDescription
    def set_getDescription(self, getDescription):
        self.getDescription = getDescription
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ST_LongString(self, value):
        # Validate type ST_LongString, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_LongString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_LongString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(CT_BackstageMenuCheckBox, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_BackstageMenuCheckBox', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_BackstageMenuCheckBox')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_BackstageMenuCheckBox')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_BackstageMenuCheckBox', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_BackstageMenuCheckBox'):
        super(CT_BackstageMenuCheckBox, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_BackstageMenuCheckBox')
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.getDescription is not None and 'getDescription' not in already_processed:
            already_processed.add('getDescription')
            outfile.write(' getDescription=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getDescription), input_name='getDescription')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_BackstageMenuCheckBox', fromsubclass_=False, pretty_print=True):
        super(CT_BackstageMenuCheckBox, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
            self.validate_ST_LongString(self.description)    # validate type ST_LongString
        value = find_attr_value_('getDescription', node)
        if value is not None and 'getDescription' not in already_processed:
            already_processed.add('getDescription')
            self.getDescription = value
            self.validate_ST_Delegate(self.getDescription)    # validate type ST_Delegate
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(CT_BackstageMenuCheckBox, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CT_BackstageMenuCheckBox, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CT_BackstageMenuCheckBox


class CT_BackstageMenuToggleButton(CT_BackstageMenuCheckBox):
    """An toggle button which exists in a primary menu"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_BackstageMenuCheckBox
    def __init__(self, id=None, idQ=None, tag=None, onAction=None, getPressed=None, enabled=None, getEnabled=None, label=None, getLabel=None, visible=None, getVisible=None, keytip=None, getKeytip=None, description=None, getDescription=None, image=None, imageMso=None, getImage=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_BackstageMenuToggleButton, self).__init__(id, idQ, tag, onAction, getPressed, enabled, getEnabled, label, getLabel, visible, getVisible, keytip, getKeytip, description, getDescription,  **kwargs_)
        self.image = _cast(None, image)
        self.image_nsprefix_ = None
        self.imageMso = _cast(None, imageMso)
        self.imageMso_nsprefix_ = None
        self.getImage = _cast(None, getImage)
        self.getImage_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_BackstageMenuToggleButton)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_BackstageMenuToggleButton.subclass:
            return CT_BackstageMenuToggleButton.subclass(*args_, **kwargs_)
        else:
            return CT_BackstageMenuToggleButton(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def get_imageMso(self):
        return self.imageMso
    def set_imageMso(self, imageMso):
        self.imageMso = imageMso
    def get_getImage(self):
        return self.getImage
    def set_getImage(self, getImage):
        self.getImage = getImage
    def validate_ST_Uri(self, value):
        # Validate type ST_Uri, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Uri' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Uri' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(CT_BackstageMenuToggleButton, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_BackstageMenuToggleButton', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_BackstageMenuToggleButton')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_BackstageMenuToggleButton')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_BackstageMenuToggleButton', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_BackstageMenuToggleButton'):
        super(CT_BackstageMenuToggleButton, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_BackstageMenuToggleButton')
        if self.image is not None and 'image' not in already_processed:
            already_processed.add('image')
            outfile.write(' image=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.image), input_name='image')), ))
        if self.imageMso is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            outfile.write(' imageMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.imageMso), input_name='imageMso')), ))
        if self.getImage is not None and 'getImage' not in already_processed:
            already_processed.add('getImage')
            outfile.write(' getImage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getImage), input_name='getImage')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_BackstageMenuToggleButton', fromsubclass_=False, pretty_print=True):
        super(CT_BackstageMenuToggleButton, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('image', node)
        if value is not None and 'image' not in already_processed:
            already_processed.add('image')
            self.image = value
            self.validate_ST_Uri(self.image)    # validate type ST_Uri
        value = find_attr_value_('imageMso', node)
        if value is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            self.imageMso = value
            self.validate_ST_ID(self.imageMso)    # validate type ST_ID
        value = find_attr_value_('getImage', node)
        if value is not None and 'getImage' not in already_processed:
            already_processed.add('getImage')
            self.getImage = value
            self.validate_ST_Delegate(self.getImage)    # validate type ST_Delegate
        super(CT_BackstageMenuToggleButton, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CT_BackstageMenuToggleButton, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CT_BackstageMenuToggleButton


class CT_BackstageEditBox(GeneratedsSuper):
    """Specifies an EditBox in the Backstage"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, getText=None, onChange=None, maxLength=None, sizeString=None, id=None, idQ=None, tag=None, alignLabel=None, expand=None, enabled=None, getEnabled=None, label=None, getLabel=None, visible=None, getVisible=None, keytip=None, getKeytip=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.getText = _cast(None, getText)
        self.getText_nsprefix_ = None
        self.onChange = _cast(None, onChange)
        self.onChange_nsprefix_ = None
        self.maxLength = _cast(int, maxLength)
        self.maxLength_nsprefix_ = None
        self.sizeString = _cast(None, sizeString)
        self.sizeString_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.alignLabel = _cast(None, alignLabel)
        self.alignLabel_nsprefix_ = None
        self.expand = _cast(None, expand)
        self.expand_nsprefix_ = None
        self.enabled = _cast(bool, enabled)
        self.enabled_nsprefix_ = None
        self.getEnabled = _cast(None, getEnabled)
        self.getEnabled_nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.getLabel = _cast(None, getLabel)
        self.getLabel_nsprefix_ = None
        self.visible = _cast(bool, visible)
        self.visible_nsprefix_ = None
        self.getVisible = _cast(None, getVisible)
        self.getVisible_nsprefix_ = None
        self.keytip = _cast(None, keytip)
        self.keytip_nsprefix_ = None
        self.getKeytip = _cast(None, getKeytip)
        self.getKeytip_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_BackstageEditBox)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_BackstageEditBox.subclass:
            return CT_BackstageEditBox.subclass(*args_, **kwargs_)
        else:
            return CT_BackstageEditBox(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_getText(self):
        return self.getText
    def set_getText(self, getText):
        self.getText = getText
    def get_onChange(self):
        return self.onChange
    def set_onChange(self, onChange):
        self.onChange = onChange
    def get_maxLength(self):
        return self.maxLength
    def set_maxLength(self, maxLength):
        self.maxLength = maxLength
    def get_sizeString(self):
        return self.sizeString
    def set_sizeString(self, sizeString):
        self.sizeString = sizeString
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_alignLabel(self):
        return self.alignLabel
    def set_alignLabel(self, alignLabel):
        self.alignLabel = alignLabel
    def get_expand(self):
        return self.expand
    def set_expand(self, expand):
        self.expand = expand
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    def get_getEnabled(self):
        return self.getEnabled
    def set_getEnabled(self, getEnabled):
        self.getEnabled = getEnabled
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_getLabel(self):
        return self.getLabel
    def set_getLabel(self, getLabel):
        self.getLabel = getLabel
    def get_visible(self):
        return self.visible
    def set_visible(self, visible):
        self.visible = visible
    def get_getVisible(self):
        return self.getVisible
    def set_getVisible(self, getVisible):
        self.getVisible = getVisible
    def get_keytip(self):
        return self.keytip
    def set_keytip(self, keytip):
        self.keytip = keytip
    def get_getKeytip(self):
        return self.getKeytip
    def set_getKeytip(self, getKeytip):
        self.getKeytip = getKeytip
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_StringLength(self, value):
        # Validate type ST_StringLength, a restriction on xsd:positiveInteger.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on ST_StringLength' % {"value": value, "lineno": lineno} )
                result = False
            if value > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on ST_StringLength' % {"value": value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_Keytip(self, value):
        # Validate type ST_Keytip, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Keytip' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Keytip' % {"value" : value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_BackstageEditBox', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_BackstageEditBox')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_BackstageEditBox')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_BackstageEditBox', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_BackstageEditBox'):
        if self.getText is not None and 'getText' not in already_processed:
            already_processed.add('getText')
            outfile.write(' getText=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getText), input_name='getText')), ))
        if self.onChange is not None and 'onChange' not in already_processed:
            already_processed.add('onChange')
            outfile.write(' onChange=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.onChange), input_name='onChange')), ))
        if self.maxLength is not None and 'maxLength' not in already_processed:
            already_processed.add('maxLength')
            outfile.write(' maxLength="%s"' % self.gds_format_integer(self.maxLength, input_name='maxLength'))
        if self.sizeString is not None and 'sizeString' not in already_processed:
            already_processed.add('sizeString')
            outfile.write(' sizeString=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sizeString), input_name='sizeString')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.alignLabel is not None and 'alignLabel' not in already_processed:
            already_processed.add('alignLabel')
            outfile.write(' alignLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.alignLabel), input_name='alignLabel')), ))
        if self.expand is not None and 'expand' not in already_processed:
            already_processed.add('expand')
            outfile.write(' expand=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.expand), input_name='expand')), ))
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            outfile.write(' enabled="%s"' % self.gds_format_boolean(self.enabled, input_name='enabled'))
        if self.getEnabled is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            outfile.write(' getEnabled=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getEnabled), input_name='getEnabled')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.getLabel is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            outfile.write(' getLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getLabel), input_name='getLabel')), ))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            outfile.write(' visible="%s"' % self.gds_format_boolean(self.visible, input_name='visible'))
        if self.getVisible is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            outfile.write(' getVisible=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getVisible), input_name='getVisible')), ))
        if self.keytip is not None and 'keytip' not in already_processed:
            already_processed.add('keytip')
            outfile.write(' keytip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.keytip), input_name='keytip')), ))
        if self.getKeytip is not None and 'getKeytip' not in already_processed:
            already_processed.add('getKeytip')
            outfile.write(' getKeytip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getKeytip), input_name='getKeytip')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_BackstageEditBox', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('getText', node)
        if value is not None and 'getText' not in already_processed:
            already_processed.add('getText')
            self.getText = value
            self.validate_ST_Delegate(self.getText)    # validate type ST_Delegate
        value = find_attr_value_('onChange', node)
        if value is not None and 'onChange' not in already_processed:
            already_processed.add('onChange')
            self.onChange = value
            self.validate_ST_Delegate(self.onChange)    # validate type ST_Delegate
        value = find_attr_value_('maxLength', node)
        if value is not None and 'maxLength' not in already_processed:
            already_processed.add('maxLength')
            self.maxLength = self.gds_parse_integer(value, node, 'maxLength')
            if self.maxLength <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
            self.validate_ST_StringLength(self.maxLength)    # validate type ST_StringLength
        value = find_attr_value_('sizeString', node)
        if value is not None and 'sizeString' not in already_processed:
            already_processed.add('sizeString')
            self.sizeString = value
            self.validate_ST_String(self.sizeString)    # validate type ST_String
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('alignLabel', node)
        if value is not None and 'alignLabel' not in already_processed:
            already_processed.add('alignLabel')
            self.alignLabel = value
        value = find_attr_value_('expand', node)
        if value is not None and 'expand' not in already_processed:
            already_processed.add('expand')
            self.expand = value
        value = find_attr_value_('enabled', node)
        if value is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            if value in ('true', '1'):
                self.enabled = True
            elif value in ('false', '0'):
                self.enabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getEnabled', node)
        if value is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            self.getEnabled = value
            self.validate_ST_Delegate(self.getEnabled)    # validate type ST_Delegate
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
            self.validate_ST_String(self.label)    # validate type ST_String
        value = find_attr_value_('getLabel', node)
        if value is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            self.getLabel = value
            self.validate_ST_Delegate(self.getLabel)    # validate type ST_Delegate
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            if value in ('true', '1'):
                self.visible = True
            elif value in ('false', '0'):
                self.visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getVisible', node)
        if value is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            self.getVisible = value
            self.validate_ST_Delegate(self.getVisible)    # validate type ST_Delegate
        value = find_attr_value_('keytip', node)
        if value is not None and 'keytip' not in already_processed:
            already_processed.add('keytip')
            self.keytip = value
            self.keytip = ' '.join(self.keytip.split())
            self.validate_ST_Keytip(self.keytip)    # validate type ST_Keytip
        value = find_attr_value_('getKeytip', node)
        if value is not None and 'getKeytip' not in already_processed:
            already_processed.add('getKeytip')
            self.getKeytip = value
            self.validate_ST_Delegate(self.getKeytip)    # validate type ST_Delegate
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CT_BackstageEditBox


class CT_BackstageDropDown(GeneratedsSuper):
    """Specifies a drop-down control"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, getSelectedItemIndex=None, sizeString=None, getItemCount=None, getItemLabel=None, getItemID=None, id=None, idQ=None, tag=None, alignLabel=None, expand=None, enabled=None, getEnabled=None, label=None, getLabel=None, visible=None, getVisible=None, onAction=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, keytip=None, getKeytip=None, item=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.getSelectedItemIndex = _cast(None, getSelectedItemIndex)
        self.getSelectedItemIndex_nsprefix_ = None
        self.sizeString = _cast(None, sizeString)
        self.sizeString_nsprefix_ = None
        self.getItemCount = _cast(None, getItemCount)
        self.getItemCount_nsprefix_ = None
        self.getItemLabel = _cast(None, getItemLabel)
        self.getItemLabel_nsprefix_ = None
        self.getItemID = _cast(None, getItemID)
        self.getItemID_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.alignLabel = _cast(None, alignLabel)
        self.alignLabel_nsprefix_ = None
        self.expand = _cast(None, expand)
        self.expand_nsprefix_ = None
        self.enabled = _cast(bool, enabled)
        self.enabled_nsprefix_ = None
        self.getEnabled = _cast(None, getEnabled)
        self.getEnabled_nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.getLabel = _cast(None, getLabel)
        self.getLabel_nsprefix_ = None
        self.visible = _cast(bool, visible)
        self.visible_nsprefix_ = None
        self.getVisible = _cast(None, getVisible)
        self.getVisible_nsprefix_ = None
        self.onAction = _cast(None, onAction)
        self.onAction_nsprefix_ = None
        self.screentip = _cast(None, screentip)
        self.screentip_nsprefix_ = None
        self.getScreentip = _cast(None, getScreentip)
        self.getScreentip_nsprefix_ = None
        self.supertip = _cast(None, supertip)
        self.supertip_nsprefix_ = None
        self.getSupertip = _cast(None, getSupertip)
        self.getSupertip_nsprefix_ = None
        self.keytip = _cast(None, keytip)
        self.keytip_nsprefix_ = None
        self.getKeytip = _cast(None, getKeytip)
        self.getKeytip_nsprefix_ = None
        if item is None:
            self.item = []
        else:
            self.item = item
        self.item_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_BackstageDropDown)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_BackstageDropDown.subclass:
            return CT_BackstageDropDown.subclass(*args_, **kwargs_)
        else:
            return CT_BackstageDropDown(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_item(self):
        return self.item
    def set_item(self, item):
        self.item = item
    def add_item(self, value):
        self.item.append(value)
    def insert_item_at(self, index, value):
        self.item.insert(index, value)
    def replace_item_at(self, index, value):
        self.item[index] = value
    def get_getSelectedItemIndex(self):
        return self.getSelectedItemIndex
    def set_getSelectedItemIndex(self, getSelectedItemIndex):
        self.getSelectedItemIndex = getSelectedItemIndex
    def get_sizeString(self):
        return self.sizeString
    def set_sizeString(self, sizeString):
        self.sizeString = sizeString
    def get_getItemCount(self):
        return self.getItemCount
    def set_getItemCount(self, getItemCount):
        self.getItemCount = getItemCount
    def get_getItemLabel(self):
        return self.getItemLabel
    def set_getItemLabel(self, getItemLabel):
        self.getItemLabel = getItemLabel
    def get_getItemID(self):
        return self.getItemID
    def set_getItemID(self, getItemID):
        self.getItemID = getItemID
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_alignLabel(self):
        return self.alignLabel
    def set_alignLabel(self, alignLabel):
        self.alignLabel = alignLabel
    def get_expand(self):
        return self.expand
    def set_expand(self, expand):
        self.expand = expand
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    def get_getEnabled(self):
        return self.getEnabled
    def set_getEnabled(self, getEnabled):
        self.getEnabled = getEnabled
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_getLabel(self):
        return self.getLabel
    def set_getLabel(self, getLabel):
        self.getLabel = getLabel
    def get_visible(self):
        return self.visible
    def set_visible(self, visible):
        self.visible = visible
    def get_getVisible(self):
        return self.getVisible
    def set_getVisible(self, getVisible):
        self.getVisible = getVisible
    def get_onAction(self):
        return self.onAction
    def set_onAction(self, onAction):
        self.onAction = onAction
    def get_screentip(self):
        return self.screentip
    def set_screentip(self, screentip):
        self.screentip = screentip
    def get_getScreentip(self):
        return self.getScreentip
    def set_getScreentip(self, getScreentip):
        self.getScreentip = getScreentip
    def get_supertip(self):
        return self.supertip
    def set_supertip(self, supertip):
        self.supertip = supertip
    def get_getSupertip(self):
        return self.getSupertip
    def set_getSupertip(self, getSupertip):
        self.getSupertip = getSupertip
    def get_keytip(self):
        return self.keytip
    def set_keytip(self, keytip):
        self.keytip = keytip
    def get_getKeytip(self):
        return self.getKeytip
    def set_getKeytip(self, getKeytip):
        self.getKeytip = getKeytip
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_Keytip(self, value):
        # Validate type ST_Keytip, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Keytip' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Keytip' % {"value" : value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.item
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_BackstageDropDown', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_BackstageDropDown')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_BackstageDropDown')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_BackstageDropDown', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_BackstageDropDown'):
        if self.getSelectedItemIndex is not None and 'getSelectedItemIndex' not in already_processed:
            already_processed.add('getSelectedItemIndex')
            outfile.write(' getSelectedItemIndex=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getSelectedItemIndex), input_name='getSelectedItemIndex')), ))
        if self.sizeString is not None and 'sizeString' not in already_processed:
            already_processed.add('sizeString')
            outfile.write(' sizeString=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sizeString), input_name='sizeString')), ))
        if self.getItemCount is not None and 'getItemCount' not in already_processed:
            already_processed.add('getItemCount')
            outfile.write(' getItemCount=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getItemCount), input_name='getItemCount')), ))
        if self.getItemLabel is not None and 'getItemLabel' not in already_processed:
            already_processed.add('getItemLabel')
            outfile.write(' getItemLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getItemLabel), input_name='getItemLabel')), ))
        if self.getItemID is not None and 'getItemID' not in already_processed:
            already_processed.add('getItemID')
            outfile.write(' getItemID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getItemID), input_name='getItemID')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.alignLabel is not None and 'alignLabel' not in already_processed:
            already_processed.add('alignLabel')
            outfile.write(' alignLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.alignLabel), input_name='alignLabel')), ))
        if self.expand is not None and 'expand' not in already_processed:
            already_processed.add('expand')
            outfile.write(' expand=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.expand), input_name='expand')), ))
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            outfile.write(' enabled="%s"' % self.gds_format_boolean(self.enabled, input_name='enabled'))
        if self.getEnabled is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            outfile.write(' getEnabled=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getEnabled), input_name='getEnabled')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.getLabel is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            outfile.write(' getLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getLabel), input_name='getLabel')), ))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            outfile.write(' visible="%s"' % self.gds_format_boolean(self.visible, input_name='visible'))
        if self.getVisible is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            outfile.write(' getVisible=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getVisible), input_name='getVisible')), ))
        if self.onAction is not None and 'onAction' not in already_processed:
            already_processed.add('onAction')
            outfile.write(' onAction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.onAction), input_name='onAction')), ))
        if self.screentip is not None and 'screentip' not in already_processed:
            already_processed.add('screentip')
            outfile.write(' screentip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.screentip), input_name='screentip')), ))
        if self.getScreentip is not None and 'getScreentip' not in already_processed:
            already_processed.add('getScreentip')
            outfile.write(' getScreentip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getScreentip), input_name='getScreentip')), ))
        if self.supertip is not None and 'supertip' not in already_processed:
            already_processed.add('supertip')
            outfile.write(' supertip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.supertip), input_name='supertip')), ))
        if self.getSupertip is not None and 'getSupertip' not in already_processed:
            already_processed.add('getSupertip')
            outfile.write(' getSupertip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getSupertip), input_name='getSupertip')), ))
        if self.keytip is not None and 'keytip' not in already_processed:
            already_processed.add('keytip')
            outfile.write(' keytip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.keytip), input_name='keytip')), ))
        if self.getKeytip is not None and 'getKeytip' not in already_processed:
            already_processed.add('getKeytip')
            outfile.write(' getKeytip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getKeytip), input_name='getKeytip')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_BackstageDropDown', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for item_ in self.item:
            namespaceprefix_ = self.item_nsprefix_ + ':' if (UseCapturedNS_ and self.item_nsprefix_) else ''
            item_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='item', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('getSelectedItemIndex', node)
        if value is not None and 'getSelectedItemIndex' not in already_processed:
            already_processed.add('getSelectedItemIndex')
            self.getSelectedItemIndex = value
            self.validate_ST_Delegate(self.getSelectedItemIndex)    # validate type ST_Delegate
        value = find_attr_value_('sizeString', node)
        if value is not None and 'sizeString' not in already_processed:
            already_processed.add('sizeString')
            self.sizeString = value
            self.validate_ST_String(self.sizeString)    # validate type ST_String
        value = find_attr_value_('getItemCount', node)
        if value is not None and 'getItemCount' not in already_processed:
            already_processed.add('getItemCount')
            self.getItemCount = value
            self.validate_ST_Delegate(self.getItemCount)    # validate type ST_Delegate
        value = find_attr_value_('getItemLabel', node)
        if value is not None and 'getItemLabel' not in already_processed:
            already_processed.add('getItemLabel')
            self.getItemLabel = value
            self.validate_ST_Delegate(self.getItemLabel)    # validate type ST_Delegate
        value = find_attr_value_('getItemID', node)
        if value is not None and 'getItemID' not in already_processed:
            already_processed.add('getItemID')
            self.getItemID = value
            self.validate_ST_Delegate(self.getItemID)    # validate type ST_Delegate
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('alignLabel', node)
        if value is not None and 'alignLabel' not in already_processed:
            already_processed.add('alignLabel')
            self.alignLabel = value
        value = find_attr_value_('expand', node)
        if value is not None and 'expand' not in already_processed:
            already_processed.add('expand')
            self.expand = value
        value = find_attr_value_('enabled', node)
        if value is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            if value in ('true', '1'):
                self.enabled = True
            elif value in ('false', '0'):
                self.enabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getEnabled', node)
        if value is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            self.getEnabled = value
            self.validate_ST_Delegate(self.getEnabled)    # validate type ST_Delegate
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
            self.validate_ST_String(self.label)    # validate type ST_String
        value = find_attr_value_('getLabel', node)
        if value is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            self.getLabel = value
            self.validate_ST_Delegate(self.getLabel)    # validate type ST_Delegate
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            if value in ('true', '1'):
                self.visible = True
            elif value in ('false', '0'):
                self.visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getVisible', node)
        if value is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            self.getVisible = value
            self.validate_ST_Delegate(self.getVisible)    # validate type ST_Delegate
        value = find_attr_value_('onAction', node)
        if value is not None and 'onAction' not in already_processed:
            already_processed.add('onAction')
            self.onAction = value
            self.validate_ST_Delegate(self.onAction)    # validate type ST_Delegate
        value = find_attr_value_('screentip', node)
        if value is not None and 'screentip' not in already_processed:
            already_processed.add('screentip')
            self.screentip = value
            self.validate_ST_String(self.screentip)    # validate type ST_String
        value = find_attr_value_('getScreentip', node)
        if value is not None and 'getScreentip' not in already_processed:
            already_processed.add('getScreentip')
            self.getScreentip = value
            self.validate_ST_Delegate(self.getScreentip)    # validate type ST_Delegate
        value = find_attr_value_('supertip', node)
        if value is not None and 'supertip' not in already_processed:
            already_processed.add('supertip')
            self.supertip = value
            self.validate_ST_String(self.supertip)    # validate type ST_String
        value = find_attr_value_('getSupertip', node)
        if value is not None and 'getSupertip' not in already_processed:
            already_processed.add('getSupertip')
            self.getSupertip = value
            self.validate_ST_Delegate(self.getSupertip)    # validate type ST_Delegate
        value = find_attr_value_('keytip', node)
        if value is not None and 'keytip' not in already_processed:
            already_processed.add('keytip')
            self.keytip = value
            self.keytip = ' '.join(self.keytip.split())
            self.validate_ST_Keytip(self.keytip)    # validate type ST_Keytip
        value = find_attr_value_('getKeytip', node)
        if value is not None and 'getKeytip' not in already_processed:
            already_processed.add('getKeytip')
            self.getKeytip = value
            self.validate_ST_Delegate(self.getKeytip)    # validate type ST_Delegate
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'item':
            obj_ = CT_BackstageItem.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'item'
# end class CT_BackstageDropDown


class CT_RadioGroup(GeneratedsSuper):
    """Specifies a group of radio buttons"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, getSelectedItemIndex=None, getItemCount=None, getItemLabel=None, getItemID=None, id=None, idQ=None, tag=None, alignLabel=None, expand=None, enabled=None, getEnabled=None, label=None, getLabel=None, visible=None, getVisible=None, onAction=None, keytip=None, getKeytip=None, radioButton=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.getSelectedItemIndex = _cast(None, getSelectedItemIndex)
        self.getSelectedItemIndex_nsprefix_ = None
        self.getItemCount = _cast(None, getItemCount)
        self.getItemCount_nsprefix_ = None
        self.getItemLabel = _cast(None, getItemLabel)
        self.getItemLabel_nsprefix_ = None
        self.getItemID = _cast(None, getItemID)
        self.getItemID_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.alignLabel = _cast(None, alignLabel)
        self.alignLabel_nsprefix_ = None
        self.expand = _cast(None, expand)
        self.expand_nsprefix_ = None
        self.enabled = _cast(bool, enabled)
        self.enabled_nsprefix_ = None
        self.getEnabled = _cast(None, getEnabled)
        self.getEnabled_nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.getLabel = _cast(None, getLabel)
        self.getLabel_nsprefix_ = None
        self.visible = _cast(bool, visible)
        self.visible_nsprefix_ = None
        self.getVisible = _cast(None, getVisible)
        self.getVisible_nsprefix_ = None
        self.onAction = _cast(None, onAction)
        self.onAction_nsprefix_ = None
        self.keytip = _cast(None, keytip)
        self.keytip_nsprefix_ = None
        self.getKeytip = _cast(None, getKeytip)
        self.getKeytip_nsprefix_ = None
        if radioButton is None:
            self.radioButton = []
        else:
            self.radioButton = radioButton
        self.radioButton_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_RadioGroup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_RadioGroup.subclass:
            return CT_RadioGroup.subclass(*args_, **kwargs_)
        else:
            return CT_RadioGroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_radioButton(self):
        return self.radioButton
    def set_radioButton(self, radioButton):
        self.radioButton = radioButton
    def add_radioButton(self, value):
        self.radioButton.append(value)
    def insert_radioButton_at(self, index, value):
        self.radioButton.insert(index, value)
    def replace_radioButton_at(self, index, value):
        self.radioButton[index] = value
    def get_getSelectedItemIndex(self):
        return self.getSelectedItemIndex
    def set_getSelectedItemIndex(self, getSelectedItemIndex):
        self.getSelectedItemIndex = getSelectedItemIndex
    def get_getItemCount(self):
        return self.getItemCount
    def set_getItemCount(self, getItemCount):
        self.getItemCount = getItemCount
    def get_getItemLabel(self):
        return self.getItemLabel
    def set_getItemLabel(self, getItemLabel):
        self.getItemLabel = getItemLabel
    def get_getItemID(self):
        return self.getItemID
    def set_getItemID(self, getItemID):
        self.getItemID = getItemID
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_alignLabel(self):
        return self.alignLabel
    def set_alignLabel(self, alignLabel):
        self.alignLabel = alignLabel
    def get_expand(self):
        return self.expand
    def set_expand(self, expand):
        self.expand = expand
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    def get_getEnabled(self):
        return self.getEnabled
    def set_getEnabled(self, getEnabled):
        self.getEnabled = getEnabled
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_getLabel(self):
        return self.getLabel
    def set_getLabel(self, getLabel):
        self.getLabel = getLabel
    def get_visible(self):
        return self.visible
    def set_visible(self, visible):
        self.visible = visible
    def get_getVisible(self):
        return self.getVisible
    def set_getVisible(self, getVisible):
        self.getVisible = getVisible
    def get_onAction(self):
        return self.onAction
    def set_onAction(self, onAction):
        self.onAction = onAction
    def get_keytip(self):
        return self.keytip
    def set_keytip(self, keytip):
        self.keytip = keytip
    def get_getKeytip(self):
        return self.getKeytip
    def set_getKeytip(self, getKeytip):
        self.getKeytip = getKeytip
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Keytip(self, value):
        # Validate type ST_Keytip, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Keytip' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Keytip' % {"value" : value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.radioButton
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_RadioGroup', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_RadioGroup')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_RadioGroup')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_RadioGroup', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_RadioGroup'):
        if self.getSelectedItemIndex is not None and 'getSelectedItemIndex' not in already_processed:
            already_processed.add('getSelectedItemIndex')
            outfile.write(' getSelectedItemIndex=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getSelectedItemIndex), input_name='getSelectedItemIndex')), ))
        if self.getItemCount is not None and 'getItemCount' not in already_processed:
            already_processed.add('getItemCount')
            outfile.write(' getItemCount=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getItemCount), input_name='getItemCount')), ))
        if self.getItemLabel is not None and 'getItemLabel' not in already_processed:
            already_processed.add('getItemLabel')
            outfile.write(' getItemLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getItemLabel), input_name='getItemLabel')), ))
        if self.getItemID is not None and 'getItemID' not in already_processed:
            already_processed.add('getItemID')
            outfile.write(' getItemID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getItemID), input_name='getItemID')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.alignLabel is not None and 'alignLabel' not in already_processed:
            already_processed.add('alignLabel')
            outfile.write(' alignLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.alignLabel), input_name='alignLabel')), ))
        if self.expand is not None and 'expand' not in already_processed:
            already_processed.add('expand')
            outfile.write(' expand=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.expand), input_name='expand')), ))
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            outfile.write(' enabled="%s"' % self.gds_format_boolean(self.enabled, input_name='enabled'))
        if self.getEnabled is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            outfile.write(' getEnabled=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getEnabled), input_name='getEnabled')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.getLabel is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            outfile.write(' getLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getLabel), input_name='getLabel')), ))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            outfile.write(' visible="%s"' % self.gds_format_boolean(self.visible, input_name='visible'))
        if self.getVisible is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            outfile.write(' getVisible=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getVisible), input_name='getVisible')), ))
        if self.onAction is not None and 'onAction' not in already_processed:
            already_processed.add('onAction')
            outfile.write(' onAction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.onAction), input_name='onAction')), ))
        if self.keytip is not None and 'keytip' not in already_processed:
            already_processed.add('keytip')
            outfile.write(' keytip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.keytip), input_name='keytip')), ))
        if self.getKeytip is not None and 'getKeytip' not in already_processed:
            already_processed.add('getKeytip')
            outfile.write(' getKeytip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getKeytip), input_name='getKeytip')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_RadioGroup', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for radioButton_ in self.radioButton:
            namespaceprefix_ = self.radioButton_nsprefix_ + ':' if (UseCapturedNS_ and self.radioButton_nsprefix_) else ''
            radioButton_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='radioButton', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('getSelectedItemIndex', node)
        if value is not None and 'getSelectedItemIndex' not in already_processed:
            already_processed.add('getSelectedItemIndex')
            self.getSelectedItemIndex = value
            self.validate_ST_Delegate(self.getSelectedItemIndex)    # validate type ST_Delegate
        value = find_attr_value_('getItemCount', node)
        if value is not None and 'getItemCount' not in already_processed:
            already_processed.add('getItemCount')
            self.getItemCount = value
            self.validate_ST_Delegate(self.getItemCount)    # validate type ST_Delegate
        value = find_attr_value_('getItemLabel', node)
        if value is not None and 'getItemLabel' not in already_processed:
            already_processed.add('getItemLabel')
            self.getItemLabel = value
            self.validate_ST_Delegate(self.getItemLabel)    # validate type ST_Delegate
        value = find_attr_value_('getItemID', node)
        if value is not None and 'getItemID' not in already_processed:
            already_processed.add('getItemID')
            self.getItemID = value
            self.validate_ST_Delegate(self.getItemID)    # validate type ST_Delegate
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('alignLabel', node)
        if value is not None and 'alignLabel' not in already_processed:
            already_processed.add('alignLabel')
            self.alignLabel = value
        value = find_attr_value_('expand', node)
        if value is not None and 'expand' not in already_processed:
            already_processed.add('expand')
            self.expand = value
        value = find_attr_value_('enabled', node)
        if value is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            if value in ('true', '1'):
                self.enabled = True
            elif value in ('false', '0'):
                self.enabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getEnabled', node)
        if value is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            self.getEnabled = value
            self.validate_ST_Delegate(self.getEnabled)    # validate type ST_Delegate
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
            self.validate_ST_String(self.label)    # validate type ST_String
        value = find_attr_value_('getLabel', node)
        if value is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            self.getLabel = value
            self.validate_ST_Delegate(self.getLabel)    # validate type ST_Delegate
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            if value in ('true', '1'):
                self.visible = True
            elif value in ('false', '0'):
                self.visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getVisible', node)
        if value is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            self.getVisible = value
            self.validate_ST_Delegate(self.getVisible)    # validate type ST_Delegate
        value = find_attr_value_('onAction', node)
        if value is not None and 'onAction' not in already_processed:
            already_processed.add('onAction')
            self.onAction = value
            self.validate_ST_Delegate(self.onAction)    # validate type ST_Delegate
        value = find_attr_value_('keytip', node)
        if value is not None and 'keytip' not in already_processed:
            already_processed.add('keytip')
            self.keytip = value
            self.keytip = ' '.join(self.keytip.split())
            self.validate_ST_Keytip(self.keytip)    # validate type ST_Keytip
        value = find_attr_value_('getKeytip', node)
        if value is not None and 'getKeytip' not in already_processed:
            already_processed.add('getKeytip')
            self.getKeytip = value
            self.validate_ST_Delegate(self.getKeytip)    # validate type ST_Delegate
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'radioButton':
            obj_ = CT_BackstageItem.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.radioButton.append(obj_)
            obj_.original_tagname_ = 'radioButton'
# end class CT_RadioGroup


class CT_BackstageComboBox(GeneratedsSuper):
    """Specifies a combo box control"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, getText=None, onChange=None, sizeString=None, getItemCount=None, getItemLabel=None, getItemID=None, id=None, idQ=None, tag=None, alignLabel=None, expand=None, enabled=None, getEnabled=None, label=None, getLabel=None, visible=None, getVisible=None, keytip=None, getKeytip=None, item=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.getText = _cast(None, getText)
        self.getText_nsprefix_ = None
        self.onChange = _cast(None, onChange)
        self.onChange_nsprefix_ = None
        self.sizeString = _cast(None, sizeString)
        self.sizeString_nsprefix_ = None
        self.getItemCount = _cast(None, getItemCount)
        self.getItemCount_nsprefix_ = None
        self.getItemLabel = _cast(None, getItemLabel)
        self.getItemLabel_nsprefix_ = None
        self.getItemID = _cast(None, getItemID)
        self.getItemID_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.alignLabel = _cast(None, alignLabel)
        self.alignLabel_nsprefix_ = None
        self.expand = _cast(None, expand)
        self.expand_nsprefix_ = None
        self.enabled = _cast(bool, enabled)
        self.enabled_nsprefix_ = None
        self.getEnabled = _cast(None, getEnabled)
        self.getEnabled_nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.getLabel = _cast(None, getLabel)
        self.getLabel_nsprefix_ = None
        self.visible = _cast(bool, visible)
        self.visible_nsprefix_ = None
        self.getVisible = _cast(None, getVisible)
        self.getVisible_nsprefix_ = None
        self.keytip = _cast(None, keytip)
        self.keytip_nsprefix_ = None
        self.getKeytip = _cast(None, getKeytip)
        self.getKeytip_nsprefix_ = None
        if item is None:
            self.item = []
        else:
            self.item = item
        self.item_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_BackstageComboBox)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_BackstageComboBox.subclass:
            return CT_BackstageComboBox.subclass(*args_, **kwargs_)
        else:
            return CT_BackstageComboBox(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_item(self):
        return self.item
    def set_item(self, item):
        self.item = item
    def add_item(self, value):
        self.item.append(value)
    def insert_item_at(self, index, value):
        self.item.insert(index, value)
    def replace_item_at(self, index, value):
        self.item[index] = value
    def get_getText(self):
        return self.getText
    def set_getText(self, getText):
        self.getText = getText
    def get_onChange(self):
        return self.onChange
    def set_onChange(self, onChange):
        self.onChange = onChange
    def get_sizeString(self):
        return self.sizeString
    def set_sizeString(self, sizeString):
        self.sizeString = sizeString
    def get_getItemCount(self):
        return self.getItemCount
    def set_getItemCount(self, getItemCount):
        self.getItemCount = getItemCount
    def get_getItemLabel(self):
        return self.getItemLabel
    def set_getItemLabel(self, getItemLabel):
        self.getItemLabel = getItemLabel
    def get_getItemID(self):
        return self.getItemID
    def set_getItemID(self, getItemID):
        self.getItemID = getItemID
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_alignLabel(self):
        return self.alignLabel
    def set_alignLabel(self, alignLabel):
        self.alignLabel = alignLabel
    def get_expand(self):
        return self.expand
    def set_expand(self, expand):
        self.expand = expand
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    def get_getEnabled(self):
        return self.getEnabled
    def set_getEnabled(self, getEnabled):
        self.getEnabled = getEnabled
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_getLabel(self):
        return self.getLabel
    def set_getLabel(self, getLabel):
        self.getLabel = getLabel
    def get_visible(self):
        return self.visible
    def set_visible(self, visible):
        self.visible = visible
    def get_getVisible(self):
        return self.getVisible
    def set_getVisible(self, getVisible):
        self.getVisible = getVisible
    def get_keytip(self):
        return self.keytip
    def set_keytip(self, keytip):
        self.keytip = keytip
    def get_getKeytip(self):
        return self.getKeytip
    def set_getKeytip(self, getKeytip):
        self.getKeytip = getKeytip
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_Keytip(self, value):
        # Validate type ST_Keytip, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Keytip' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Keytip' % {"value" : value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.item
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_BackstageComboBox', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_BackstageComboBox')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_BackstageComboBox')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_BackstageComboBox', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_BackstageComboBox'):
        if self.getText is not None and 'getText' not in already_processed:
            already_processed.add('getText')
            outfile.write(' getText=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getText), input_name='getText')), ))
        if self.onChange is not None and 'onChange' not in already_processed:
            already_processed.add('onChange')
            outfile.write(' onChange=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.onChange), input_name='onChange')), ))
        if self.sizeString is not None and 'sizeString' not in already_processed:
            already_processed.add('sizeString')
            outfile.write(' sizeString=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sizeString), input_name='sizeString')), ))
        if self.getItemCount is not None and 'getItemCount' not in already_processed:
            already_processed.add('getItemCount')
            outfile.write(' getItemCount=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getItemCount), input_name='getItemCount')), ))
        if self.getItemLabel is not None and 'getItemLabel' not in already_processed:
            already_processed.add('getItemLabel')
            outfile.write(' getItemLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getItemLabel), input_name='getItemLabel')), ))
        if self.getItemID is not None and 'getItemID' not in already_processed:
            already_processed.add('getItemID')
            outfile.write(' getItemID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getItemID), input_name='getItemID')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.alignLabel is not None and 'alignLabel' not in already_processed:
            already_processed.add('alignLabel')
            outfile.write(' alignLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.alignLabel), input_name='alignLabel')), ))
        if self.expand is not None and 'expand' not in already_processed:
            already_processed.add('expand')
            outfile.write(' expand=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.expand), input_name='expand')), ))
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            outfile.write(' enabled="%s"' % self.gds_format_boolean(self.enabled, input_name='enabled'))
        if self.getEnabled is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            outfile.write(' getEnabled=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getEnabled), input_name='getEnabled')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.getLabel is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            outfile.write(' getLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getLabel), input_name='getLabel')), ))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            outfile.write(' visible="%s"' % self.gds_format_boolean(self.visible, input_name='visible'))
        if self.getVisible is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            outfile.write(' getVisible=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getVisible), input_name='getVisible')), ))
        if self.keytip is not None and 'keytip' not in already_processed:
            already_processed.add('keytip')
            outfile.write(' keytip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.keytip), input_name='keytip')), ))
        if self.getKeytip is not None and 'getKeytip' not in already_processed:
            already_processed.add('getKeytip')
            outfile.write(' getKeytip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getKeytip), input_name='getKeytip')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_BackstageComboBox', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for item_ in self.item:
            namespaceprefix_ = self.item_nsprefix_ + ':' if (UseCapturedNS_ and self.item_nsprefix_) else ''
            item_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='item', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('getText', node)
        if value is not None and 'getText' not in already_processed:
            already_processed.add('getText')
            self.getText = value
            self.validate_ST_Delegate(self.getText)    # validate type ST_Delegate
        value = find_attr_value_('onChange', node)
        if value is not None and 'onChange' not in already_processed:
            already_processed.add('onChange')
            self.onChange = value
            self.validate_ST_Delegate(self.onChange)    # validate type ST_Delegate
        value = find_attr_value_('sizeString', node)
        if value is not None and 'sizeString' not in already_processed:
            already_processed.add('sizeString')
            self.sizeString = value
            self.validate_ST_String(self.sizeString)    # validate type ST_String
        value = find_attr_value_('getItemCount', node)
        if value is not None and 'getItemCount' not in already_processed:
            already_processed.add('getItemCount')
            self.getItemCount = value
            self.validate_ST_Delegate(self.getItemCount)    # validate type ST_Delegate
        value = find_attr_value_('getItemLabel', node)
        if value is not None and 'getItemLabel' not in already_processed:
            already_processed.add('getItemLabel')
            self.getItemLabel = value
            self.validate_ST_Delegate(self.getItemLabel)    # validate type ST_Delegate
        value = find_attr_value_('getItemID', node)
        if value is not None and 'getItemID' not in already_processed:
            already_processed.add('getItemID')
            self.getItemID = value
            self.validate_ST_Delegate(self.getItemID)    # validate type ST_Delegate
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('alignLabel', node)
        if value is not None and 'alignLabel' not in already_processed:
            already_processed.add('alignLabel')
            self.alignLabel = value
        value = find_attr_value_('expand', node)
        if value is not None and 'expand' not in already_processed:
            already_processed.add('expand')
            self.expand = value
        value = find_attr_value_('enabled', node)
        if value is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            if value in ('true', '1'):
                self.enabled = True
            elif value in ('false', '0'):
                self.enabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getEnabled', node)
        if value is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            self.getEnabled = value
            self.validate_ST_Delegate(self.getEnabled)    # validate type ST_Delegate
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
            self.validate_ST_String(self.label)    # validate type ST_String
        value = find_attr_value_('getLabel', node)
        if value is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            self.getLabel = value
            self.validate_ST_Delegate(self.getLabel)    # validate type ST_Delegate
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            if value in ('true', '1'):
                self.visible = True
            elif value in ('false', '0'):
                self.visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getVisible', node)
        if value is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            self.getVisible = value
            self.validate_ST_Delegate(self.getVisible)    # validate type ST_Delegate
        value = find_attr_value_('keytip', node)
        if value is not None and 'keytip' not in already_processed:
            already_processed.add('keytip')
            self.keytip = value
            self.keytip = ' '.join(self.keytip.split())
            self.validate_ST_Keytip(self.keytip)    # validate type ST_Keytip
        value = find_attr_value_('getKeytip', node)
        if value is not None and 'getKeytip' not in already_processed:
            already_processed.add('getKeytip')
            self.getKeytip = value
            self.validate_ST_Delegate(self.getKeytip)    # validate type ST_Delegate
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'item':
            obj_ = CT_BackstageItem.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.item.append(obj_)
            obj_.original_tagname_ = 'item'
# end class CT_BackstageComboBox


class CT_BackstageItem(GeneratedsSuper):
    """Represents a selection item in a Backstage DropDown, ComboBox or
    RadioGroup
    Specifies the ID of an item. Items cannot use idMso or idQ."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, label=None, getLabel=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.getLabel = _cast(None, getLabel)
        self.getLabel_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_BackstageItem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_BackstageItem.subclass:
            return CT_BackstageItem.subclass(*args_, **kwargs_)
        else:
            return CT_BackstageItem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_getLabel(self):
        return self.getLabel
    def set_getLabel(self, getLabel):
        self.getLabel = getLabel
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_BackstageItem', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_BackstageItem')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_BackstageItem')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_BackstageItem', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_BackstageItem'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.getLabel is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            outfile.write(' getLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getLabel), input_name='getLabel')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_BackstageItem', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
            self.validate_ST_String(self.label)    # validate type ST_String
        value = find_attr_value_('getLabel', node)
        if value is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            self.getLabel = value
            self.validate_ST_Delegate(self.getLabel)    # validate type ST_Delegate
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CT_BackstageItem


class CT_Hyperlink(GeneratedsSuper):
    """Specifies a hyperlink control"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, target=None, getTarget=None, id=None, idQ=None, tag=None, alignLabel=None, expand=None, enabled=None, getEnabled=None, visible=None, getVisible=None, keytip=None, getKeytip=None, label=None, getLabel=None, onAction=None, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.target = _cast(None, target)
        self.target_nsprefix_ = None
        self.getTarget = _cast(None, getTarget)
        self.getTarget_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.alignLabel = _cast(None, alignLabel)
        self.alignLabel_nsprefix_ = None
        self.expand = _cast(None, expand)
        self.expand_nsprefix_ = None
        self.enabled = _cast(bool, enabled)
        self.enabled_nsprefix_ = None
        self.getEnabled = _cast(None, getEnabled)
        self.getEnabled_nsprefix_ = None
        self.visible = _cast(bool, visible)
        self.visible_nsprefix_ = None
        self.getVisible = _cast(None, getVisible)
        self.getVisible_nsprefix_ = None
        self.keytip = _cast(None, keytip)
        self.keytip_nsprefix_ = None
        self.getKeytip = _cast(None, getKeytip)
        self.getKeytip_nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.getLabel = _cast(None, getLabel)
        self.getLabel_nsprefix_ = None
        self.onAction = _cast(None, onAction)
        self.onAction_nsprefix_ = None
        self.image = _cast(None, image)
        self.image_nsprefix_ = None
        self.imageMso = _cast(None, imageMso)
        self.imageMso_nsprefix_ = None
        self.getImage = _cast(None, getImage)
        self.getImage_nsprefix_ = None
        self.screentip = _cast(None, screentip)
        self.screentip_nsprefix_ = None
        self.getScreentip = _cast(None, getScreentip)
        self.getScreentip_nsprefix_ = None
        self.supertip = _cast(None, supertip)
        self.supertip_nsprefix_ = None
        self.getSupertip = _cast(None, getSupertip)
        self.getSupertip_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_Hyperlink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_Hyperlink.subclass:
            return CT_Hyperlink.subclass(*args_, **kwargs_)
        else:
            return CT_Hyperlink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_target(self):
        return self.target
    def set_target(self, target):
        self.target = target
    def get_getTarget(self):
        return self.getTarget
    def set_getTarget(self, getTarget):
        self.getTarget = getTarget
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_alignLabel(self):
        return self.alignLabel
    def set_alignLabel(self, alignLabel):
        self.alignLabel = alignLabel
    def get_expand(self):
        return self.expand
    def set_expand(self, expand):
        self.expand = expand
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    def get_getEnabled(self):
        return self.getEnabled
    def set_getEnabled(self, getEnabled):
        self.getEnabled = getEnabled
    def get_visible(self):
        return self.visible
    def set_visible(self, visible):
        self.visible = visible
    def get_getVisible(self):
        return self.getVisible
    def set_getVisible(self, getVisible):
        self.getVisible = getVisible
    def get_keytip(self):
        return self.keytip
    def set_keytip(self, keytip):
        self.keytip = keytip
    def get_getKeytip(self):
        return self.getKeytip
    def set_getKeytip(self, getKeytip):
        self.getKeytip = getKeytip
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_getLabel(self):
        return self.getLabel
    def set_getLabel(self, getLabel):
        self.getLabel = getLabel
    def get_onAction(self):
        return self.onAction
    def set_onAction(self, onAction):
        self.onAction = onAction
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def get_imageMso(self):
        return self.imageMso
    def set_imageMso(self, imageMso):
        self.imageMso = imageMso
    def get_getImage(self):
        return self.getImage
    def set_getImage(self, getImage):
        self.getImage = getImage
    def get_screentip(self):
        return self.screentip
    def set_screentip(self, screentip):
        self.screentip = screentip
    def get_getScreentip(self):
        return self.getScreentip
    def set_getScreentip(self, getScreentip):
        self.getScreentip = getScreentip
    def get_supertip(self):
        return self.supertip
    def set_supertip(self, supertip):
        self.supertip = supertip
    def get_getSupertip(self):
        return self.getSupertip
    def set_getSupertip(self, getSupertip):
        self.getSupertip = getSupertip
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_Keytip(self, value):
        # Validate type ST_Keytip, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Keytip' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Keytip' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_Uri(self, value):
        # Validate type ST_Uri, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Uri' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Uri' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_Hyperlink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_Hyperlink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_Hyperlink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_Hyperlink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_Hyperlink'):
        if self.target is not None and 'target' not in already_processed:
            already_processed.add('target')
            outfile.write(' target=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.target), input_name='target')), ))
        if self.getTarget is not None and 'getTarget' not in already_processed:
            already_processed.add('getTarget')
            outfile.write(' getTarget=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getTarget), input_name='getTarget')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.alignLabel is not None and 'alignLabel' not in already_processed:
            already_processed.add('alignLabel')
            outfile.write(' alignLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.alignLabel), input_name='alignLabel')), ))
        if self.expand is not None and 'expand' not in already_processed:
            already_processed.add('expand')
            outfile.write(' expand=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.expand), input_name='expand')), ))
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            outfile.write(' enabled="%s"' % self.gds_format_boolean(self.enabled, input_name='enabled'))
        if self.getEnabled is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            outfile.write(' getEnabled=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getEnabled), input_name='getEnabled')), ))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            outfile.write(' visible="%s"' % self.gds_format_boolean(self.visible, input_name='visible'))
        if self.getVisible is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            outfile.write(' getVisible=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getVisible), input_name='getVisible')), ))
        if self.keytip is not None and 'keytip' not in already_processed:
            already_processed.add('keytip')
            outfile.write(' keytip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.keytip), input_name='keytip')), ))
        if self.getKeytip is not None and 'getKeytip' not in already_processed:
            already_processed.add('getKeytip')
            outfile.write(' getKeytip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getKeytip), input_name='getKeytip')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.getLabel is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            outfile.write(' getLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getLabel), input_name='getLabel')), ))
        if self.onAction is not None and 'onAction' not in already_processed:
            already_processed.add('onAction')
            outfile.write(' onAction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.onAction), input_name='onAction')), ))
        if self.image is not None and 'image' not in already_processed:
            already_processed.add('image')
            outfile.write(' image=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.image), input_name='image')), ))
        if self.imageMso is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            outfile.write(' imageMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.imageMso), input_name='imageMso')), ))
        if self.getImage is not None and 'getImage' not in already_processed:
            already_processed.add('getImage')
            outfile.write(' getImage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getImage), input_name='getImage')), ))
        if self.screentip is not None and 'screentip' not in already_processed:
            already_processed.add('screentip')
            outfile.write(' screentip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.screentip), input_name='screentip')), ))
        if self.getScreentip is not None and 'getScreentip' not in already_processed:
            already_processed.add('getScreentip')
            outfile.write(' getScreentip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getScreentip), input_name='getScreentip')), ))
        if self.supertip is not None and 'supertip' not in already_processed:
            already_processed.add('supertip')
            outfile.write(' supertip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.supertip), input_name='supertip')), ))
        if self.getSupertip is not None and 'getSupertip' not in already_processed:
            already_processed.add('getSupertip')
            outfile.write(' getSupertip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getSupertip), input_name='getSupertip')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_Hyperlink', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('target', node)
        if value is not None and 'target' not in already_processed:
            already_processed.add('target')
            self.target = value
            self.validate_ST_String(self.target)    # validate type ST_String
        value = find_attr_value_('getTarget', node)
        if value is not None and 'getTarget' not in already_processed:
            already_processed.add('getTarget')
            self.getTarget = value
            self.validate_ST_Delegate(self.getTarget)    # validate type ST_Delegate
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('alignLabel', node)
        if value is not None and 'alignLabel' not in already_processed:
            already_processed.add('alignLabel')
            self.alignLabel = value
        value = find_attr_value_('expand', node)
        if value is not None and 'expand' not in already_processed:
            already_processed.add('expand')
            self.expand = value
        value = find_attr_value_('enabled', node)
        if value is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            if value in ('true', '1'):
                self.enabled = True
            elif value in ('false', '0'):
                self.enabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getEnabled', node)
        if value is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            self.getEnabled = value
            self.validate_ST_Delegate(self.getEnabled)    # validate type ST_Delegate
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            if value in ('true', '1'):
                self.visible = True
            elif value in ('false', '0'):
                self.visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getVisible', node)
        if value is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            self.getVisible = value
            self.validate_ST_Delegate(self.getVisible)    # validate type ST_Delegate
        value = find_attr_value_('keytip', node)
        if value is not None and 'keytip' not in already_processed:
            already_processed.add('keytip')
            self.keytip = value
            self.keytip = ' '.join(self.keytip.split())
            self.validate_ST_Keytip(self.keytip)    # validate type ST_Keytip
        value = find_attr_value_('getKeytip', node)
        if value is not None and 'getKeytip' not in already_processed:
            already_processed.add('getKeytip')
            self.getKeytip = value
            self.validate_ST_Delegate(self.getKeytip)    # validate type ST_Delegate
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
            self.validate_ST_String(self.label)    # validate type ST_String
        value = find_attr_value_('getLabel', node)
        if value is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            self.getLabel = value
            self.validate_ST_Delegate(self.getLabel)    # validate type ST_Delegate
        value = find_attr_value_('onAction', node)
        if value is not None and 'onAction' not in already_processed:
            already_processed.add('onAction')
            self.onAction = value
            self.validate_ST_Delegate(self.onAction)    # validate type ST_Delegate
        value = find_attr_value_('image', node)
        if value is not None and 'image' not in already_processed:
            already_processed.add('image')
            self.image = value
            self.validate_ST_Uri(self.image)    # validate type ST_Uri
        value = find_attr_value_('imageMso', node)
        if value is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            self.imageMso = value
            self.validate_ST_ID(self.imageMso)    # validate type ST_ID
        value = find_attr_value_('getImage', node)
        if value is not None and 'getImage' not in already_processed:
            already_processed.add('getImage')
            self.getImage = value
            self.validate_ST_Delegate(self.getImage)    # validate type ST_Delegate
        value = find_attr_value_('screentip', node)
        if value is not None and 'screentip' not in already_processed:
            already_processed.add('screentip')
            self.screentip = value
            self.validate_ST_String(self.screentip)    # validate type ST_String
        value = find_attr_value_('getScreentip', node)
        if value is not None and 'getScreentip' not in already_processed:
            already_processed.add('getScreentip')
            self.getScreentip = value
            self.validate_ST_Delegate(self.getScreentip)    # validate type ST_Delegate
        value = find_attr_value_('supertip', node)
        if value is not None and 'supertip' not in already_processed:
            already_processed.add('supertip')
            self.supertip = value
            self.validate_ST_String(self.supertip)    # validate type ST_String
        value = find_attr_value_('getSupertip', node)
        if value is not None and 'getSupertip' not in already_processed:
            already_processed.add('getSupertip')
            self.getSupertip = value
            self.validate_ST_Delegate(self.getSupertip)    # validate type ST_Delegate
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CT_Hyperlink


class CT_BackstageLabelControl(GeneratedsSuper):
    """Specifies a label control"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, noWrap=None, id=None, idQ=None, tag=None, alignLabel=None, expand=None, enabled=None, getEnabled=None, label=None, getLabel=None, visible=None, getVisible=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.noWrap = _cast(bool, noWrap)
        self.noWrap_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.alignLabel = _cast(None, alignLabel)
        self.alignLabel_nsprefix_ = None
        self.expand = _cast(None, expand)
        self.expand_nsprefix_ = None
        self.enabled = _cast(bool, enabled)
        self.enabled_nsprefix_ = None
        self.getEnabled = _cast(None, getEnabled)
        self.getEnabled_nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.getLabel = _cast(None, getLabel)
        self.getLabel_nsprefix_ = None
        self.visible = _cast(bool, visible)
        self.visible_nsprefix_ = None
        self.getVisible = _cast(None, getVisible)
        self.getVisible_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_BackstageLabelControl)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_BackstageLabelControl.subclass:
            return CT_BackstageLabelControl.subclass(*args_, **kwargs_)
        else:
            return CT_BackstageLabelControl(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_noWrap(self):
        return self.noWrap
    def set_noWrap(self, noWrap):
        self.noWrap = noWrap
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_alignLabel(self):
        return self.alignLabel
    def set_alignLabel(self, alignLabel):
        self.alignLabel = alignLabel
    def get_expand(self):
        return self.expand
    def set_expand(self, expand):
        self.expand = expand
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    def get_getEnabled(self):
        return self.getEnabled
    def set_getEnabled(self, getEnabled):
        self.getEnabled = getEnabled
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_getLabel(self):
        return self.getLabel
    def set_getLabel(self, getLabel):
        self.getLabel = getLabel
    def get_visible(self):
        return self.visible
    def set_visible(self, visible):
        self.visible = visible
    def get_getVisible(self):
        return self.getVisible
    def set_getVisible(self, getVisible):
        self.getVisible = getVisible
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_BackstageLabelControl', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_BackstageLabelControl')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_BackstageLabelControl')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_BackstageLabelControl', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_BackstageLabelControl'):
        if self.noWrap is not None and 'noWrap' not in already_processed:
            already_processed.add('noWrap')
            outfile.write(' noWrap="%s"' % self.gds_format_boolean(self.noWrap, input_name='noWrap'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.alignLabel is not None and 'alignLabel' not in already_processed:
            already_processed.add('alignLabel')
            outfile.write(' alignLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.alignLabel), input_name='alignLabel')), ))
        if self.expand is not None and 'expand' not in already_processed:
            already_processed.add('expand')
            outfile.write(' expand=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.expand), input_name='expand')), ))
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            outfile.write(' enabled="%s"' % self.gds_format_boolean(self.enabled, input_name='enabled'))
        if self.getEnabled is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            outfile.write(' getEnabled=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getEnabled), input_name='getEnabled')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.getLabel is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            outfile.write(' getLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getLabel), input_name='getLabel')), ))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            outfile.write(' visible="%s"' % self.gds_format_boolean(self.visible, input_name='visible'))
        if self.getVisible is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            outfile.write(' getVisible=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getVisible), input_name='getVisible')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_BackstageLabelControl', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('noWrap', node)
        if value is not None and 'noWrap' not in already_processed:
            already_processed.add('noWrap')
            if value in ('true', '1'):
                self.noWrap = True
            elif value in ('false', '0'):
                self.noWrap = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('alignLabel', node)
        if value is not None and 'alignLabel' not in already_processed:
            already_processed.add('alignLabel')
            self.alignLabel = value
        value = find_attr_value_('expand', node)
        if value is not None and 'expand' not in already_processed:
            already_processed.add('expand')
            self.expand = value
        value = find_attr_value_('enabled', node)
        if value is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            if value in ('true', '1'):
                self.enabled = True
            elif value in ('false', '0'):
                self.enabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getEnabled', node)
        if value is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            self.getEnabled = value
            self.validate_ST_Delegate(self.getEnabled)    # validate type ST_Delegate
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
            self.validate_ST_String(self.label)    # validate type ST_String
        value = find_attr_value_('getLabel', node)
        if value is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            self.getLabel = value
            self.validate_ST_Delegate(self.getLabel)    # validate type ST_Delegate
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            if value in ('true', '1'):
                self.visible = True
            elif value in ('false', '0'):
                self.visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getVisible', node)
        if value is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            self.getVisible = value
            self.validate_ST_Delegate(self.getVisible)    # validate type ST_Delegate
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CT_BackstageLabelControl


class CT_PrimaryItem(GeneratedsSuper):
    """Specifies a primary button or menu"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, button=None, menu=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.button = button
        self.button_nsprefix_ = None
        self.menu = menu
        self.menu_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_PrimaryItem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_PrimaryItem.subclass:
            return CT_PrimaryItem.subclass(*args_, **kwargs_)
        else:
            return CT_PrimaryItem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_button(self):
        return self.button
    def set_button(self, button):
        self.button = button
    def get_menu(self):
        return self.menu
    def set_menu(self, menu):
        self.menu = menu
    def hasContent_(self):
        if (
            self.button is not None or
            self.menu is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_PrimaryItem', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_PrimaryItem')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_PrimaryItem')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_PrimaryItem', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_PrimaryItem'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_PrimaryItem', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.button is not None:
            namespaceprefix_ = self.button_nsprefix_ + ':' if (UseCapturedNS_ and self.button_nsprefix_) else ''
            self.button.export(outfile, level, namespaceprefix_, namespacedef_='', name_='button', pretty_print=pretty_print)
        if self.menu is not None:
            namespaceprefix_ = self.menu_nsprefix_ + ':' if (UseCapturedNS_ and self.menu_nsprefix_) else ''
            self.menu.export(outfile, level, namespaceprefix_, namespacedef_='', name_='menu', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'button':
            class_obj_ = self.get_class_obj_(child_, CT_BackstageRegularButton)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.button = obj_
            obj_.original_tagname_ = 'button'
        elif nodeName_ == 'menu':
            obj_ = CT_BackstagePrimaryMenu.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.menu = obj_
            obj_.original_tagname_ = 'menu'
# end class CT_PrimaryItem


class CT_BackstageMenuGroup(GeneratedsSuper):
    """Backstage MenuGroup
    Specifies size of menu items."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, itemSize=None, id=None, idQ=None, tag=None, label=None, getLabel=None, button=None, checkBox=None, menu=None, toggleButton=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.itemSize = _cast(None, itemSize)
        self.itemSize_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.getLabel = _cast(None, getLabel)
        self.getLabel_nsprefix_ = None
        if button is None:
            self.button = []
        else:
            self.button = button
        self.button_nsprefix_ = None
        if checkBox is None:
            self.checkBox = []
        else:
            self.checkBox = checkBox
        self.checkBox_nsprefix_ = None
        if menu is None:
            self.menu = []
        else:
            self.menu = menu
        self.menu_nsprefix_ = None
        if toggleButton is None:
            self.toggleButton = []
        else:
            self.toggleButton = toggleButton
        self.toggleButton_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_BackstageMenuGroup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_BackstageMenuGroup.subclass:
            return CT_BackstageMenuGroup.subclass(*args_, **kwargs_)
        else:
            return CT_BackstageMenuGroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_button(self):
        return self.button
    def set_button(self, button):
        self.button = button
    def add_button(self, value):
        self.button.append(value)
    def insert_button_at(self, index, value):
        self.button.insert(index, value)
    def replace_button_at(self, index, value):
        self.button[index] = value
    def get_checkBox(self):
        return self.checkBox
    def set_checkBox(self, checkBox):
        self.checkBox = checkBox
    def add_checkBox(self, value):
        self.checkBox.append(value)
    def insert_checkBox_at(self, index, value):
        self.checkBox.insert(index, value)
    def replace_checkBox_at(self, index, value):
        self.checkBox[index] = value
    def get_menu(self):
        return self.menu
    def set_menu(self, menu):
        self.menu = menu
    def add_menu(self, value):
        self.menu.append(value)
    def insert_menu_at(self, index, value):
        self.menu.insert(index, value)
    def replace_menu_at(self, index, value):
        self.menu[index] = value
    def get_toggleButton(self):
        return self.toggleButton
    def set_toggleButton(self, toggleButton):
        self.toggleButton = toggleButton
    def add_toggleButton(self, value):
        self.toggleButton.append(value)
    def insert_toggleButton_at(self, index, value):
        self.toggleButton.insert(index, value)
    def replace_toggleButton_at(self, index, value):
        self.toggleButton[index] = value
    def get_itemSize(self):
        return self.itemSize
    def set_itemSize(self, itemSize):
        self.itemSize = itemSize
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_getLabel(self):
        return self.getLabel
    def set_getLabel(self, getLabel):
        self.getLabel = getLabel
    def validate_ST_ItemSize(self, value):
        # Validate type ST_ItemSize, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['normal', 'large']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ST_ItemSize' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.button or
            self.checkBox or
            self.menu or
            self.toggleButton
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_BackstageMenuGroup', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_BackstageMenuGroup')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_BackstageMenuGroup')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_BackstageMenuGroup', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_BackstageMenuGroup'):
        if self.itemSize is not None and 'itemSize' not in already_processed:
            already_processed.add('itemSize')
            outfile.write(' itemSize=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.itemSize), input_name='itemSize')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.getLabel is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            outfile.write(' getLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getLabel), input_name='getLabel')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_BackstageMenuGroup', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for button_ in self.button:
            namespaceprefix_ = self.button_nsprefix_ + ':' if (UseCapturedNS_ and self.button_nsprefix_) else ''
            button_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='button', pretty_print=pretty_print)
        for checkBox_ in self.checkBox:
            namespaceprefix_ = self.checkBox_nsprefix_ + ':' if (UseCapturedNS_ and self.checkBox_nsprefix_) else ''
            checkBox_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='checkBox', pretty_print=pretty_print)
        for menu_ in self.menu:
            namespaceprefix_ = self.menu_nsprefix_ + ':' if (UseCapturedNS_ and self.menu_nsprefix_) else ''
            menu_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='menu', pretty_print=pretty_print)
        for toggleButton_ in self.toggleButton:
            namespaceprefix_ = self.toggleButton_nsprefix_ + ':' if (UseCapturedNS_ and self.toggleButton_nsprefix_) else ''
            toggleButton_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='toggleButton', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('itemSize', node)
        if value is not None and 'itemSize' not in already_processed:
            already_processed.add('itemSize')
            self.itemSize = value
            self.validate_ST_ItemSize(self.itemSize)    # validate type ST_ItemSize
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
            self.validate_ST_String(self.label)    # validate type ST_String
        value = find_attr_value_('getLabel', node)
        if value is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            self.getLabel = value
            self.validate_ST_Delegate(self.getLabel)    # validate type ST_Delegate
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'button':
            obj_ = CT_BackstageMenuButton.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.button.append(obj_)
            obj_.original_tagname_ = 'button'
        elif nodeName_ == 'checkBox':
            class_obj_ = self.get_class_obj_(child_, CT_BackstageMenuCheckBox)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.checkBox.append(obj_)
            obj_.original_tagname_ = 'checkBox'
        elif nodeName_ == 'menu':
            obj_ = CT_BackstageSubMenu.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.menu.append(obj_)
            obj_.original_tagname_ = 'menu'
        elif nodeName_ == 'toggleButton':
            obj_ = CT_BackstageMenuToggleButton.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.toggleButton.append(obj_)
            obj_.original_tagname_ = 'toggleButton'
# end class CT_BackstageMenuGroup


class CT_BackstageMenuBase(GeneratedsSuper):
    """Specifies a Backstage menu"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, idQ=None, tag=None, enabled=None, getEnabled=None, label=None, getLabel=None, visible=None, getVisible=None, image=None, imageMso=None, getImage=None, keytip=None, getKeytip=None, menuGroup=None, extensiontype_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.enabled = _cast(bool, enabled)
        self.enabled_nsprefix_ = None
        self.getEnabled = _cast(None, getEnabled)
        self.getEnabled_nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.getLabel = _cast(None, getLabel)
        self.getLabel_nsprefix_ = None
        self.visible = _cast(bool, visible)
        self.visible_nsprefix_ = None
        self.getVisible = _cast(None, getVisible)
        self.getVisible_nsprefix_ = None
        self.image = _cast(None, image)
        self.image_nsprefix_ = None
        self.imageMso = _cast(None, imageMso)
        self.imageMso_nsprefix_ = None
        self.getImage = _cast(None, getImage)
        self.getImage_nsprefix_ = None
        self.keytip = _cast(None, keytip)
        self.keytip_nsprefix_ = None
        self.getKeytip = _cast(None, getKeytip)
        self.getKeytip_nsprefix_ = None
        if menuGroup is None:
            self.menuGroup = []
        else:
            self.menuGroup = menuGroup
        self.menuGroup_nsprefix_ = None
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_BackstageMenuBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_BackstageMenuBase.subclass:
            return CT_BackstageMenuBase.subclass(*args_, **kwargs_)
        else:
            return CT_BackstageMenuBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_menuGroup(self):
        return self.menuGroup
    def set_menuGroup(self, menuGroup):
        self.menuGroup = menuGroup
    def add_menuGroup(self, value):
        self.menuGroup.append(value)
    def insert_menuGroup_at(self, index, value):
        self.menuGroup.insert(index, value)
    def replace_menuGroup_at(self, index, value):
        self.menuGroup[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    def get_getEnabled(self):
        return self.getEnabled
    def set_getEnabled(self, getEnabled):
        self.getEnabled = getEnabled
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_getLabel(self):
        return self.getLabel
    def set_getLabel(self, getLabel):
        self.getLabel = getLabel
    def get_visible(self):
        return self.visible
    def set_visible(self, visible):
        self.visible = visible
    def get_getVisible(self):
        return self.getVisible
    def set_getVisible(self, getVisible):
        self.getVisible = getVisible
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def get_imageMso(self):
        return self.imageMso
    def set_imageMso(self, imageMso):
        self.imageMso = imageMso
    def get_getImage(self):
        return self.getImage
    def set_getImage(self, getImage):
        self.getImage = getImage
    def get_keytip(self):
        return self.keytip
    def set_keytip(self, keytip):
        self.keytip = keytip
    def get_getKeytip(self):
        return self.getKeytip
    def set_getKeytip(self, getKeytip):
        self.getKeytip = getKeytip
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Uri(self, value):
        # Validate type ST_Uri, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Uri' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Uri' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_Keytip(self, value):
        # Validate type ST_Keytip, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Keytip' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Keytip' % {"value" : value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.menuGroup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_BackstageMenuBase', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_BackstageMenuBase')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_BackstageMenuBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_BackstageMenuBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_BackstageMenuBase'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            outfile.write(' enabled="%s"' % self.gds_format_boolean(self.enabled, input_name='enabled'))
        if self.getEnabled is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            outfile.write(' getEnabled=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getEnabled), input_name='getEnabled')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.getLabel is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            outfile.write(' getLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getLabel), input_name='getLabel')), ))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            outfile.write(' visible="%s"' % self.gds_format_boolean(self.visible, input_name='visible'))
        if self.getVisible is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            outfile.write(' getVisible=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getVisible), input_name='getVisible')), ))
        if self.image is not None and 'image' not in already_processed:
            already_processed.add('image')
            outfile.write(' image=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.image), input_name='image')), ))
        if self.imageMso is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            outfile.write(' imageMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.imageMso), input_name='imageMso')), ))
        if self.getImage is not None and 'getImage' not in already_processed:
            already_processed.add('getImage')
            outfile.write(' getImage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getImage), input_name='getImage')), ))
        if self.keytip is not None and 'keytip' not in already_processed:
            already_processed.add('keytip')
            outfile.write(' keytip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.keytip), input_name='keytip')), ))
        if self.getKeytip is not None and 'getKeytip' not in already_processed:
            already_processed.add('getKeytip')
            outfile.write(' getKeytip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getKeytip), input_name='getKeytip')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            if ":" not in self.extensiontype_:
                imported_ns_type_prefix_ = GenerateDSNamespaceTypePrefixes_.get(self.extensiontype_, '')
                outfile.write(' xsi:type="%s%s"' % (imported_ns_type_prefix_, self.extensiontype_))
            else:
                outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_BackstageMenuBase', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for menuGroup_ in self.menuGroup:
            namespaceprefix_ = self.menuGroup_nsprefix_ + ':' if (UseCapturedNS_ and self.menuGroup_nsprefix_) else ''
            menuGroup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='menuGroup', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('enabled', node)
        if value is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            if value in ('true', '1'):
                self.enabled = True
            elif value in ('false', '0'):
                self.enabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getEnabled', node)
        if value is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            self.getEnabled = value
            self.validate_ST_Delegate(self.getEnabled)    # validate type ST_Delegate
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
            self.validate_ST_String(self.label)    # validate type ST_String
        value = find_attr_value_('getLabel', node)
        if value is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            self.getLabel = value
            self.validate_ST_Delegate(self.getLabel)    # validate type ST_Delegate
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            if value in ('true', '1'):
                self.visible = True
            elif value in ('false', '0'):
                self.visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getVisible', node)
        if value is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            self.getVisible = value
            self.validate_ST_Delegate(self.getVisible)    # validate type ST_Delegate
        value = find_attr_value_('image', node)
        if value is not None and 'image' not in already_processed:
            already_processed.add('image')
            self.image = value
            self.validate_ST_Uri(self.image)    # validate type ST_Uri
        value = find_attr_value_('imageMso', node)
        if value is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            self.imageMso = value
            self.validate_ST_ID(self.imageMso)    # validate type ST_ID
        value = find_attr_value_('getImage', node)
        if value is not None and 'getImage' not in already_processed:
            already_processed.add('getImage')
            self.getImage = value
            self.validate_ST_Delegate(self.getImage)    # validate type ST_Delegate
        value = find_attr_value_('keytip', node)
        if value is not None and 'keytip' not in already_processed:
            already_processed.add('keytip')
            self.keytip = value
            self.keytip = ' '.join(self.keytip.split())
            self.validate_ST_Keytip(self.keytip)    # validate type ST_Keytip
        value = find_attr_value_('getKeytip', node)
        if value is not None and 'getKeytip' not in already_processed:
            already_processed.add('getKeytip')
            self.getKeytip = value
            self.validate_ST_Delegate(self.getKeytip)    # validate type ST_Delegate
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'menuGroup':
            obj_ = CT_BackstageMenuGroup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.menuGroup.append(obj_)
            obj_.original_tagname_ = 'menuGroup'
# end class CT_BackstageMenuBase


class CT_BackstagePrimaryMenu(CT_BackstageMenuBase):
    """Specifies a BackstageMenu which also includes the screentip
    attributes"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_BackstageMenuBase
    def __init__(self, id=None, idQ=None, tag=None, enabled=None, getEnabled=None, label=None, getLabel=None, visible=None, getVisible=None, image=None, imageMso=None, getImage=None, keytip=None, getKeytip=None, menuGroup=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_BackstagePrimaryMenu, self).__init__(id, idQ, tag, enabled, getEnabled, label, getLabel, visible, getVisible, image, imageMso, getImage, keytip, getKeytip, menuGroup,  **kwargs_)
        self.screentip = _cast(None, screentip)
        self.screentip_nsprefix_ = None
        self.getScreentip = _cast(None, getScreentip)
        self.getScreentip_nsprefix_ = None
        self.supertip = _cast(None, supertip)
        self.supertip_nsprefix_ = None
        self.getSupertip = _cast(None, getSupertip)
        self.getSupertip_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_BackstagePrimaryMenu)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_BackstagePrimaryMenu.subclass:
            return CT_BackstagePrimaryMenu.subclass(*args_, **kwargs_)
        else:
            return CT_BackstagePrimaryMenu(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_screentip(self):
        return self.screentip
    def set_screentip(self, screentip):
        self.screentip = screentip
    def get_getScreentip(self):
        return self.getScreentip
    def set_getScreentip(self, getScreentip):
        self.getScreentip = getScreentip
    def get_supertip(self):
        return self.supertip
    def set_supertip(self, supertip):
        self.supertip = supertip
    def get_getSupertip(self):
        return self.getSupertip
    def set_getSupertip(self, getSupertip):
        self.getSupertip = getSupertip
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(CT_BackstagePrimaryMenu, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_BackstagePrimaryMenu', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_BackstagePrimaryMenu')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_BackstagePrimaryMenu')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_BackstagePrimaryMenu', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_BackstagePrimaryMenu'):
        super(CT_BackstagePrimaryMenu, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_BackstagePrimaryMenu')
        if self.screentip is not None and 'screentip' not in already_processed:
            already_processed.add('screentip')
            outfile.write(' screentip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.screentip), input_name='screentip')), ))
        if self.getScreentip is not None and 'getScreentip' not in already_processed:
            already_processed.add('getScreentip')
            outfile.write(' getScreentip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getScreentip), input_name='getScreentip')), ))
        if self.supertip is not None and 'supertip' not in already_processed:
            already_processed.add('supertip')
            outfile.write(' supertip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.supertip), input_name='supertip')), ))
        if self.getSupertip is not None and 'getSupertip' not in already_processed:
            already_processed.add('getSupertip')
            outfile.write(' getSupertip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getSupertip), input_name='getSupertip')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_BackstagePrimaryMenu', fromsubclass_=False, pretty_print=True):
        super(CT_BackstagePrimaryMenu, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('screentip', node)
        if value is not None and 'screentip' not in already_processed:
            already_processed.add('screentip')
            self.screentip = value
            self.validate_ST_String(self.screentip)    # validate type ST_String
        value = find_attr_value_('getScreentip', node)
        if value is not None and 'getScreentip' not in already_processed:
            already_processed.add('getScreentip')
            self.getScreentip = value
            self.validate_ST_Delegate(self.getScreentip)    # validate type ST_Delegate
        value = find_attr_value_('supertip', node)
        if value is not None and 'supertip' not in already_processed:
            already_processed.add('supertip')
            self.supertip = value
            self.validate_ST_String(self.supertip)    # validate type ST_String
        value = find_attr_value_('getSupertip', node)
        if value is not None and 'getSupertip' not in already_processed:
            already_processed.add('getSupertip')
            self.getSupertip = value
            self.validate_ST_Delegate(self.getSupertip)    # validate type ST_Delegate
        super(CT_BackstagePrimaryMenu, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CT_BackstagePrimaryMenu, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CT_BackstagePrimaryMenu


class CT_BackstageSubMenu(CT_BackstageMenuBase):
    """Specifies a BackstageMenu which also includes the
    description/getDescription attributes"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_BackstageMenuBase
    def __init__(self, id=None, idQ=None, tag=None, enabled=None, getEnabled=None, label=None, getLabel=None, visible=None, getVisible=None, image=None, imageMso=None, getImage=None, keytip=None, getKeytip=None, menuGroup=None, description=None, getDescription=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_BackstageSubMenu, self).__init__(id, idQ, tag, enabled, getEnabled, label, getLabel, visible, getVisible, image, imageMso, getImage, keytip, getKeytip, menuGroup,  **kwargs_)
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
        self.getDescription = _cast(None, getDescription)
        self.getDescription_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_BackstageSubMenu)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_BackstageSubMenu.subclass:
            return CT_BackstageSubMenu.subclass(*args_, **kwargs_)
        else:
            return CT_BackstageSubMenu(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_getDescription(self):
        return self.getDescription
    def set_getDescription(self, getDescription):
        self.getDescription = getDescription
    def validate_ST_LongString(self, value):
        # Validate type ST_LongString, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_LongString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_LongString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            super(CT_BackstageSubMenu, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_BackstageSubMenu', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_BackstageSubMenu')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_BackstageSubMenu')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_BackstageSubMenu', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_BackstageSubMenu'):
        super(CT_BackstageSubMenu, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_BackstageSubMenu')
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.getDescription is not None and 'getDescription' not in already_processed:
            already_processed.add('getDescription')
            outfile.write(' getDescription=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getDescription), input_name='getDescription')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_BackstageSubMenu', fromsubclass_=False, pretty_print=True):
        super(CT_BackstageSubMenu, self).exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
            self.validate_ST_LongString(self.description)    # validate type ST_LongString
        value = find_attr_value_('getDescription', node)
        if value is not None and 'getDescription' not in already_processed:
            already_processed.add('getDescription')
            self.getDescription = value
            self.validate_ST_Delegate(self.getDescription)    # validate type ST_Delegate
        super(CT_BackstageSubMenu, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CT_BackstageSubMenu, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CT_BackstageSubMenu


class CT_ImageControl(GeneratedsSuper):
    """An image-hosting control"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, idQ=None, tag=None, enabled=None, getEnabled=None, visible=None, getVisible=None, image=None, imageMso=None, getImage=None, altText=None, getAltText=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.enabled = _cast(bool, enabled)
        self.enabled_nsprefix_ = None
        self.getEnabled = _cast(None, getEnabled)
        self.getEnabled_nsprefix_ = None
        self.visible = _cast(bool, visible)
        self.visible_nsprefix_ = None
        self.getVisible = _cast(None, getVisible)
        self.getVisible_nsprefix_ = None
        self.image = _cast(None, image)
        self.image_nsprefix_ = None
        self.imageMso = _cast(None, imageMso)
        self.imageMso_nsprefix_ = None
        self.getImage = _cast(None, getImage)
        self.getImage_nsprefix_ = None
        self.altText = _cast(None, altText)
        self.altText_nsprefix_ = None
        self.getAltText = _cast(None, getAltText)
        self.getAltText_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_ImageControl)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_ImageControl.subclass:
            return CT_ImageControl.subclass(*args_, **kwargs_)
        else:
            return CT_ImageControl(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    def get_getEnabled(self):
        return self.getEnabled
    def set_getEnabled(self, getEnabled):
        self.getEnabled = getEnabled
    def get_visible(self):
        return self.visible
    def set_visible(self, visible):
        self.visible = visible
    def get_getVisible(self):
        return self.getVisible
    def set_getVisible(self, getVisible):
        self.getVisible = getVisible
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def get_imageMso(self):
        return self.imageMso
    def set_imageMso(self, imageMso):
        self.imageMso = imageMso
    def get_getImage(self):
        return self.getImage
    def set_getImage(self, getImage):
        self.getImage = getImage
    def get_altText(self):
        return self.altText
    def set_altText(self, altText):
        self.altText = altText
    def get_getAltText(self):
        return self.getAltText
    def set_getAltText(self, getAltText):
        self.getAltText = getAltText
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Uri(self, value):
        # Validate type ST_Uri, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Uri' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Uri' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_LongString(self, value):
        # Validate type ST_LongString, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_LongString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_LongString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_ImageControl', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_ImageControl')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_ImageControl')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_ImageControl', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_ImageControl'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            outfile.write(' enabled="%s"' % self.gds_format_boolean(self.enabled, input_name='enabled'))
        if self.getEnabled is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            outfile.write(' getEnabled=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getEnabled), input_name='getEnabled')), ))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            outfile.write(' visible="%s"' % self.gds_format_boolean(self.visible, input_name='visible'))
        if self.getVisible is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            outfile.write(' getVisible=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getVisible), input_name='getVisible')), ))
        if self.image is not None and 'image' not in already_processed:
            already_processed.add('image')
            outfile.write(' image=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.image), input_name='image')), ))
        if self.imageMso is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            outfile.write(' imageMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.imageMso), input_name='imageMso')), ))
        if self.getImage is not None and 'getImage' not in already_processed:
            already_processed.add('getImage')
            outfile.write(' getImage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getImage), input_name='getImage')), ))
        if self.altText is not None and 'altText' not in already_processed:
            already_processed.add('altText')
            outfile.write(' altText=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.altText), input_name='altText')), ))
        if self.getAltText is not None and 'getAltText' not in already_processed:
            already_processed.add('getAltText')
            outfile.write(' getAltText=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getAltText), input_name='getAltText')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_ImageControl', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('enabled', node)
        if value is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            if value in ('true', '1'):
                self.enabled = True
            elif value in ('false', '0'):
                self.enabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getEnabled', node)
        if value is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            self.getEnabled = value
            self.validate_ST_Delegate(self.getEnabled)    # validate type ST_Delegate
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            if value in ('true', '1'):
                self.visible = True
            elif value in ('false', '0'):
                self.visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getVisible', node)
        if value is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            self.getVisible = value
            self.validate_ST_Delegate(self.getVisible)    # validate type ST_Delegate
        value = find_attr_value_('image', node)
        if value is not None and 'image' not in already_processed:
            already_processed.add('image')
            self.image = value
            self.validate_ST_Uri(self.image)    # validate type ST_Uri
        value = find_attr_value_('imageMso', node)
        if value is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            self.imageMso = value
            self.validate_ST_ID(self.imageMso)    # validate type ST_ID
        value = find_attr_value_('getImage', node)
        if value is not None and 'getImage' not in already_processed:
            already_processed.add('getImage')
            self.getImage = value
            self.validate_ST_Delegate(self.getImage)    # validate type ST_Delegate
        value = find_attr_value_('altText', node)
        if value is not None and 'altText' not in already_processed:
            already_processed.add('altText')
            self.altText = value
            self.validate_ST_LongString(self.altText)    # validate type ST_LongString
        value = find_attr_value_('getAltText', node)
        if value is not None and 'getAltText' not in already_processed:
            already_processed.add('getAltText')
            self.getAltText = value
            self.validate_ST_Delegate(self.getAltText)    # validate type ST_Delegate
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CT_ImageControl


class CT_GroupControls(GeneratedsSuper):
    """Specifies a collection of controls that can live in groups."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, button=None, checkBox=None, editBox=None, dropDown=None, radioGroup=None, comboBox=None, hyperlink=None, labelControl=None, groupBox=None, layoutContainer=None, imageControl=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if button is None:
            self.button = []
        else:
            self.button = button
        self.button_nsprefix_ = None
        if checkBox is None:
            self.checkBox = []
        else:
            self.checkBox = checkBox
        self.checkBox_nsprefix_ = None
        if editBox is None:
            self.editBox = []
        else:
            self.editBox = editBox
        self.editBox_nsprefix_ = None
        if dropDown is None:
            self.dropDown = []
        else:
            self.dropDown = dropDown
        self.dropDown_nsprefix_ = None
        if radioGroup is None:
            self.radioGroup = []
        else:
            self.radioGroup = radioGroup
        self.radioGroup_nsprefix_ = None
        if comboBox is None:
            self.comboBox = []
        else:
            self.comboBox = comboBox
        self.comboBox_nsprefix_ = None
        if hyperlink is None:
            self.hyperlink = []
        else:
            self.hyperlink = hyperlink
        self.hyperlink_nsprefix_ = None
        if labelControl is None:
            self.labelControl = []
        else:
            self.labelControl = labelControl
        self.labelControl_nsprefix_ = None
        if groupBox is None:
            self.groupBox = []
        else:
            self.groupBox = groupBox
        self.groupBox_nsprefix_ = None
        if layoutContainer is None:
            self.layoutContainer = []
        else:
            self.layoutContainer = layoutContainer
        self.layoutContainer_nsprefix_ = None
        if imageControl is None:
            self.imageControl = []
        else:
            self.imageControl = imageControl
        self.imageControl_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_GroupControls)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_GroupControls.subclass:
            return CT_GroupControls.subclass(*args_, **kwargs_)
        else:
            return CT_GroupControls(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_button(self):
        return self.button
    def set_button(self, button):
        self.button = button
    def add_button(self, value):
        self.button.append(value)
    def insert_button_at(self, index, value):
        self.button.insert(index, value)
    def replace_button_at(self, index, value):
        self.button[index] = value
    def get_checkBox(self):
        return self.checkBox
    def set_checkBox(self, checkBox):
        self.checkBox = checkBox
    def add_checkBox(self, value):
        self.checkBox.append(value)
    def insert_checkBox_at(self, index, value):
        self.checkBox.insert(index, value)
    def replace_checkBox_at(self, index, value):
        self.checkBox[index] = value
    def get_editBox(self):
        return self.editBox
    def set_editBox(self, editBox):
        self.editBox = editBox
    def add_editBox(self, value):
        self.editBox.append(value)
    def insert_editBox_at(self, index, value):
        self.editBox.insert(index, value)
    def replace_editBox_at(self, index, value):
        self.editBox[index] = value
    def get_dropDown(self):
        return self.dropDown
    def set_dropDown(self, dropDown):
        self.dropDown = dropDown
    def add_dropDown(self, value):
        self.dropDown.append(value)
    def insert_dropDown_at(self, index, value):
        self.dropDown.insert(index, value)
    def replace_dropDown_at(self, index, value):
        self.dropDown[index] = value
    def get_radioGroup(self):
        return self.radioGroup
    def set_radioGroup(self, radioGroup):
        self.radioGroup = radioGroup
    def add_radioGroup(self, value):
        self.radioGroup.append(value)
    def insert_radioGroup_at(self, index, value):
        self.radioGroup.insert(index, value)
    def replace_radioGroup_at(self, index, value):
        self.radioGroup[index] = value
    def get_comboBox(self):
        return self.comboBox
    def set_comboBox(self, comboBox):
        self.comboBox = comboBox
    def add_comboBox(self, value):
        self.comboBox.append(value)
    def insert_comboBox_at(self, index, value):
        self.comboBox.insert(index, value)
    def replace_comboBox_at(self, index, value):
        self.comboBox[index] = value
    def get_hyperlink(self):
        return self.hyperlink
    def set_hyperlink(self, hyperlink):
        self.hyperlink = hyperlink
    def add_hyperlink(self, value):
        self.hyperlink.append(value)
    def insert_hyperlink_at(self, index, value):
        self.hyperlink.insert(index, value)
    def replace_hyperlink_at(self, index, value):
        self.hyperlink[index] = value
    def get_labelControl(self):
        return self.labelControl
    def set_labelControl(self, labelControl):
        self.labelControl = labelControl
    def add_labelControl(self, value):
        self.labelControl.append(value)
    def insert_labelControl_at(self, index, value):
        self.labelControl.insert(index, value)
    def replace_labelControl_at(self, index, value):
        self.labelControl[index] = value
    def get_groupBox(self):
        return self.groupBox
    def set_groupBox(self, groupBox):
        self.groupBox = groupBox
    def add_groupBox(self, value):
        self.groupBox.append(value)
    def insert_groupBox_at(self, index, value):
        self.groupBox.insert(index, value)
    def replace_groupBox_at(self, index, value):
        self.groupBox[index] = value
    def get_layoutContainer(self):
        return self.layoutContainer
    def set_layoutContainer(self, layoutContainer):
        self.layoutContainer = layoutContainer
    def add_layoutContainer(self, value):
        self.layoutContainer.append(value)
    def insert_layoutContainer_at(self, index, value):
        self.layoutContainer.insert(index, value)
    def replace_layoutContainer_at(self, index, value):
        self.layoutContainer[index] = value
    def get_imageControl(self):
        return self.imageControl
    def set_imageControl(self, imageControl):
        self.imageControl = imageControl
    def add_imageControl(self, value):
        self.imageControl.append(value)
    def insert_imageControl_at(self, index, value):
        self.imageControl.insert(index, value)
    def replace_imageControl_at(self, index, value):
        self.imageControl[index] = value
    def hasContent_(self):
        if (
            self.button or
            self.checkBox or
            self.editBox or
            self.dropDown or
            self.radioGroup or
            self.comboBox or
            self.hyperlink or
            self.labelControl or
            self.groupBox or
            self.layoutContainer or
            self.imageControl
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_GroupControls', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_GroupControls')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_GroupControls')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_GroupControls', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_GroupControls'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_GroupControls', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for button_ in self.button:
            namespaceprefix_ = self.button_nsprefix_ + ':' if (UseCapturedNS_ and self.button_nsprefix_) else ''
            button_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='button', pretty_print=pretty_print)
        for checkBox_ in self.checkBox:
            namespaceprefix_ = self.checkBox_nsprefix_ + ':' if (UseCapturedNS_ and self.checkBox_nsprefix_) else ''
            checkBox_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='checkBox', pretty_print=pretty_print)
        for editBox_ in self.editBox:
            namespaceprefix_ = self.editBox_nsprefix_ + ':' if (UseCapturedNS_ and self.editBox_nsprefix_) else ''
            editBox_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='editBox', pretty_print=pretty_print)
        for dropDown_ in self.dropDown:
            namespaceprefix_ = self.dropDown_nsprefix_ + ':' if (UseCapturedNS_ and self.dropDown_nsprefix_) else ''
            dropDown_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dropDown', pretty_print=pretty_print)
        for radioGroup_ in self.radioGroup:
            namespaceprefix_ = self.radioGroup_nsprefix_ + ':' if (UseCapturedNS_ and self.radioGroup_nsprefix_) else ''
            radioGroup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='radioGroup', pretty_print=pretty_print)
        for comboBox_ in self.comboBox:
            namespaceprefix_ = self.comboBox_nsprefix_ + ':' if (UseCapturedNS_ and self.comboBox_nsprefix_) else ''
            comboBox_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='comboBox', pretty_print=pretty_print)
        for hyperlink_ in self.hyperlink:
            namespaceprefix_ = self.hyperlink_nsprefix_ + ':' if (UseCapturedNS_ and self.hyperlink_nsprefix_) else ''
            hyperlink_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='hyperlink', pretty_print=pretty_print)
        for labelControl_ in self.labelControl:
            namespaceprefix_ = self.labelControl_nsprefix_ + ':' if (UseCapturedNS_ and self.labelControl_nsprefix_) else ''
            labelControl_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='labelControl', pretty_print=pretty_print)
        for groupBox_ in self.groupBox:
            namespaceprefix_ = self.groupBox_nsprefix_ + ':' if (UseCapturedNS_ and self.groupBox_nsprefix_) else ''
            groupBox_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='groupBox', pretty_print=pretty_print)
        for layoutContainer_ in self.layoutContainer:
            namespaceprefix_ = self.layoutContainer_nsprefix_ + ':' if (UseCapturedNS_ and self.layoutContainer_nsprefix_) else ''
            layoutContainer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='layoutContainer', pretty_print=pretty_print)
        for imageControl_ in self.imageControl:
            namespaceprefix_ = self.imageControl_nsprefix_ + ':' if (UseCapturedNS_ and self.imageControl_nsprefix_) else ''
            imageControl_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='imageControl', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'button':
            obj_ = CT_BackstageGroupButton.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.button.append(obj_)
            obj_.original_tagname_ = 'button'
        elif nodeName_ == 'checkBox':
            obj_ = CT_BackstageCheckBox.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.checkBox.append(obj_)
            obj_.original_tagname_ = 'checkBox'
        elif nodeName_ == 'editBox':
            obj_ = CT_BackstageEditBox.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.editBox.append(obj_)
            obj_.original_tagname_ = 'editBox'
        elif nodeName_ == 'dropDown':
            obj_ = CT_BackstageDropDown.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dropDown.append(obj_)
            obj_.original_tagname_ = 'dropDown'
        elif nodeName_ == 'radioGroup':
            obj_ = CT_RadioGroup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.radioGroup.append(obj_)
            obj_.original_tagname_ = 'radioGroup'
        elif nodeName_ == 'comboBox':
            obj_ = CT_BackstageComboBox.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.comboBox.append(obj_)
            obj_.original_tagname_ = 'comboBox'
        elif nodeName_ == 'hyperlink':
            obj_ = CT_Hyperlink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.hyperlink.append(obj_)
            obj_.original_tagname_ = 'hyperlink'
        elif nodeName_ == 'labelControl':
            obj_ = CT_BackstageLabelControl.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.labelControl.append(obj_)
            obj_.original_tagname_ = 'labelControl'
        elif nodeName_ == 'groupBox':
            obj_ = CT_GroupBox.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.groupBox.append(obj_)
            obj_.original_tagname_ = 'groupBox'
        elif nodeName_ == 'layoutContainer':
            obj_ = CT_LayoutContainer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.layoutContainer.append(obj_)
            obj_.original_tagname_ = 'layoutContainer'
        elif nodeName_ == 'imageControl':
            obj_ = CT_ImageControl.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.imageControl.append(obj_)
            obj_.original_tagname_ = 'imageControl'
# end class CT_GroupControls


class CT_BackstageGroup(GeneratedsSuper):
    """Specifies a group in the backstage."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, idQ=None, tag=None, idMso=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, label=None, getLabel=None, visible=None, getVisible=None, style=None, getStyle=None, helperText=None, getHelperText=None, showLabel=None, getShowLabel=None, primaryItem=None, topItems=None, bottomItems=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.idMso = _cast(None, idMso)
        self.idMso_nsprefix_ = None
        self.insertAfterMso = _cast(None, insertAfterMso)
        self.insertAfterMso_nsprefix_ = None
        self.insertBeforeMso = _cast(None, insertBeforeMso)
        self.insertBeforeMso_nsprefix_ = None
        self.insertAfterQ = _cast(None, insertAfterQ)
        self.insertAfterQ_nsprefix_ = None
        self.insertBeforeQ = _cast(None, insertBeforeQ)
        self.insertBeforeQ_nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.getLabel = _cast(None, getLabel)
        self.getLabel_nsprefix_ = None
        self.visible = _cast(bool, visible)
        self.visible_nsprefix_ = None
        self.getVisible = _cast(None, getVisible)
        self.getVisible_nsprefix_ = None
        self.style = _cast(None, style)
        self.style_nsprefix_ = None
        self.getStyle = _cast(None, getStyle)
        self.getStyle_nsprefix_ = None
        self.helperText = _cast(None, helperText)
        self.helperText_nsprefix_ = None
        self.getHelperText = _cast(None, getHelperText)
        self.getHelperText_nsprefix_ = None
        self.showLabel = _cast(bool, showLabel)
        self.showLabel_nsprefix_ = None
        self.getShowLabel = _cast(None, getShowLabel)
        self.getShowLabel_nsprefix_ = None
        self.primaryItem = primaryItem
        self.primaryItem_nsprefix_ = None
        self.topItems = topItems
        self.topItems_nsprefix_ = None
        self.bottomItems = bottomItems
        self.bottomItems_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_BackstageGroup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_BackstageGroup.subclass:
            return CT_BackstageGroup.subclass(*args_, **kwargs_)
        else:
            return CT_BackstageGroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_primaryItem(self):
        return self.primaryItem
    def set_primaryItem(self, primaryItem):
        self.primaryItem = primaryItem
    def get_topItems(self):
        return self.topItems
    def set_topItems(self, topItems):
        self.topItems = topItems
    def get_bottomItems(self):
        return self.bottomItems
    def set_bottomItems(self, bottomItems):
        self.bottomItems = bottomItems
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_idMso(self):
        return self.idMso
    def set_idMso(self, idMso):
        self.idMso = idMso
    def get_insertAfterMso(self):
        return self.insertAfterMso
    def set_insertAfterMso(self, insertAfterMso):
        self.insertAfterMso = insertAfterMso
    def get_insertBeforeMso(self):
        return self.insertBeforeMso
    def set_insertBeforeMso(self, insertBeforeMso):
        self.insertBeforeMso = insertBeforeMso
    def get_insertAfterQ(self):
        return self.insertAfterQ
    def set_insertAfterQ(self, insertAfterQ):
        self.insertAfterQ = insertAfterQ
    def get_insertBeforeQ(self):
        return self.insertBeforeQ
    def set_insertBeforeQ(self, insertBeforeQ):
        self.insertBeforeQ = insertBeforeQ
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_getLabel(self):
        return self.getLabel
    def set_getLabel(self, getLabel):
        self.getLabel = getLabel
    def get_visible(self):
        return self.visible
    def set_visible(self, visible):
        self.visible = visible
    def get_getVisible(self):
        return self.getVisible
    def set_getVisible(self, getVisible):
        self.getVisible = getVisible
    def get_style(self):
        return self.style
    def set_style(self, style):
        self.style = style
    def get_getStyle(self):
        return self.getStyle
    def set_getStyle(self, getStyle):
        self.getStyle = getStyle
    def get_helperText(self):
        return self.helperText
    def set_helperText(self, helperText):
        self.helperText = helperText
    def get_getHelperText(self):
        return self.getHelperText
    def set_getHelperText(self, getHelperText):
        self.getHelperText = getHelperText
    def get_showLabel(self):
        return self.showLabel
    def set_showLabel(self, showLabel):
        self.showLabel = showLabel
    def get_getShowLabel(self):
        return self.getShowLabel
    def set_getShowLabel(self, getShowLabel):
        self.getShowLabel = getShowLabel
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_LongString(self, value):
        # Validate type ST_LongString, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_LongString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_LongString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.primaryItem is not None or
            self.topItems is not None or
            self.bottomItems is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_BackstageGroup', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_BackstageGroup')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_BackstageGroup')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_BackstageGroup', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_BackstageGroup'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.idMso is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            outfile.write(' idMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idMso), input_name='idMso')), ))
        if self.insertAfterMso is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            outfile.write(' insertAfterMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterMso), input_name='insertAfterMso')), ))
        if self.insertBeforeMso is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            outfile.write(' insertBeforeMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeMso), input_name='insertBeforeMso')), ))
        if self.insertAfterQ is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            outfile.write(' insertAfterQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterQ), input_name='insertAfterQ')), ))
        if self.insertBeforeQ is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            outfile.write(' insertBeforeQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeQ), input_name='insertBeforeQ')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.getLabel is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            outfile.write(' getLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getLabel), input_name='getLabel')), ))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            outfile.write(' visible="%s"' % self.gds_format_boolean(self.visible, input_name='visible'))
        if self.getVisible is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            outfile.write(' getVisible=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getVisible), input_name='getVisible')), ))
        if self.style is not None and 'style' not in already_processed:
            already_processed.add('style')
            outfile.write(' style=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.style), input_name='style')), ))
        if self.getStyle is not None and 'getStyle' not in already_processed:
            already_processed.add('getStyle')
            outfile.write(' getStyle=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getStyle), input_name='getStyle')), ))
        if self.helperText is not None and 'helperText' not in already_processed:
            already_processed.add('helperText')
            outfile.write(' helperText=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.helperText), input_name='helperText')), ))
        if self.getHelperText is not None and 'getHelperText' not in already_processed:
            already_processed.add('getHelperText')
            outfile.write(' getHelperText=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getHelperText), input_name='getHelperText')), ))
        if self.showLabel is not None and 'showLabel' not in already_processed:
            already_processed.add('showLabel')
            outfile.write(' showLabel="%s"' % self.gds_format_boolean(self.showLabel, input_name='showLabel'))
        if self.getShowLabel is not None and 'getShowLabel' not in already_processed:
            already_processed.add('getShowLabel')
            outfile.write(' getShowLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getShowLabel), input_name='getShowLabel')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_BackstageGroup', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.primaryItem is not None:
            namespaceprefix_ = self.primaryItem_nsprefix_ + ':' if (UseCapturedNS_ and self.primaryItem_nsprefix_) else ''
            self.primaryItem.export(outfile, level, namespaceprefix_, namespacedef_='', name_='primaryItem', pretty_print=pretty_print)
        if self.topItems is not None:
            namespaceprefix_ = self.topItems_nsprefix_ + ':' if (UseCapturedNS_ and self.topItems_nsprefix_) else ''
            self.topItems.export(outfile, level, namespaceprefix_, namespacedef_='', name_='topItems', pretty_print=pretty_print)
        if self.bottomItems is not None:
            namespaceprefix_ = self.bottomItems_nsprefix_ + ':' if (UseCapturedNS_ and self.bottomItems_nsprefix_) else ''
            self.bottomItems.export(outfile, level, namespaceprefix_, namespacedef_='', name_='bottomItems', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('idMso', node)
        if value is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            self.idMso = value
            self.validate_ST_ID(self.idMso)    # validate type ST_ID
        value = find_attr_value_('insertAfterMso', node)
        if value is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            self.insertAfterMso = value
            self.validate_ST_ID(self.insertAfterMso)    # validate type ST_ID
        value = find_attr_value_('insertBeforeMso', node)
        if value is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            self.insertBeforeMso = value
            self.validate_ST_ID(self.insertBeforeMso)    # validate type ST_ID
        value = find_attr_value_('insertAfterQ', node)
        if value is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            self.insertAfterQ = value
            self.validate_ST_QID(self.insertAfterQ)    # validate type ST_QID
        value = find_attr_value_('insertBeforeQ', node)
        if value is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            self.insertBeforeQ = value
            self.validate_ST_QID(self.insertBeforeQ)    # validate type ST_QID
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
            self.validate_ST_String(self.label)    # validate type ST_String
        value = find_attr_value_('getLabel', node)
        if value is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            self.getLabel = value
            self.validate_ST_Delegate(self.getLabel)    # validate type ST_Delegate
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            if value in ('true', '1'):
                self.visible = True
            elif value in ('false', '0'):
                self.visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getVisible', node)
        if value is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            self.getVisible = value
            self.validate_ST_Delegate(self.getVisible)    # validate type ST_Delegate
        value = find_attr_value_('style', node)
        if value is not None and 'style' not in already_processed:
            already_processed.add('style')
            self.style = value
        value = find_attr_value_('getStyle', node)
        if value is not None and 'getStyle' not in already_processed:
            already_processed.add('getStyle')
            self.getStyle = value
            self.validate_ST_Delegate(self.getStyle)    # validate type ST_Delegate
        value = find_attr_value_('helperText', node)
        if value is not None and 'helperText' not in already_processed:
            already_processed.add('helperText')
            self.helperText = value
            self.validate_ST_LongString(self.helperText)    # validate type ST_LongString
        value = find_attr_value_('getHelperText', node)
        if value is not None and 'getHelperText' not in already_processed:
            already_processed.add('getHelperText')
            self.getHelperText = value
            self.validate_ST_Delegate(self.getHelperText)    # validate type ST_Delegate
        value = find_attr_value_('showLabel', node)
        if value is not None and 'showLabel' not in already_processed:
            already_processed.add('showLabel')
            if value in ('true', '1'):
                self.showLabel = True
            elif value in ('false', '0'):
                self.showLabel = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getShowLabel', node)
        if value is not None and 'getShowLabel' not in already_processed:
            already_processed.add('getShowLabel')
            self.getShowLabel = value
            self.validate_ST_Delegate(self.getShowLabel)    # validate type ST_Delegate
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'primaryItem':
            obj_ = CT_PrimaryItem.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.primaryItem = obj_
            obj_.original_tagname_ = 'primaryItem'
        elif nodeName_ == 'topItems':
            obj_ = CT_GroupControls.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.topItems = obj_
            obj_.original_tagname_ = 'topItems'
        elif nodeName_ == 'bottomItems':
            obj_ = CT_GroupControls.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.bottomItems = obj_
            obj_.original_tagname_ = 'bottomItems'
# end class CT_BackstageGroup


class CT_HeaderGroup(GeneratedsSuper):
    """Specifies a collection of headerButton controls."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, idQ=None, tag=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, button=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.insertAfterMso = _cast(None, insertAfterMso)
        self.insertAfterMso_nsprefix_ = None
        self.insertBeforeMso = _cast(None, insertBeforeMso)
        self.insertBeforeMso_nsprefix_ = None
        self.insertAfterQ = _cast(None, insertAfterQ)
        self.insertAfterQ_nsprefix_ = None
        self.insertBeforeQ = _cast(None, insertBeforeQ)
        self.insertBeforeQ_nsprefix_ = None
        if button is None:
            self.button = []
        else:
            self.button = button
        self.button_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_HeaderGroup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_HeaderGroup.subclass:
            return CT_HeaderGroup.subclass(*args_, **kwargs_)
        else:
            return CT_HeaderGroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_button(self):
        return self.button
    def set_button(self, button):
        self.button = button
    def add_button(self, value):
        self.button.append(value)
    def insert_button_at(self, index, value):
        self.button.insert(index, value)
    def replace_button_at(self, index, value):
        self.button[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_insertAfterMso(self):
        return self.insertAfterMso
    def set_insertAfterMso(self, insertAfterMso):
        self.insertAfterMso = insertAfterMso
    def get_insertBeforeMso(self):
        return self.insertBeforeMso
    def set_insertBeforeMso(self, insertBeforeMso):
        self.insertBeforeMso = insertBeforeMso
    def get_insertAfterQ(self):
        return self.insertAfterQ
    def set_insertAfterQ(self, insertAfterQ):
        self.insertAfterQ = insertAfterQ
    def get_insertBeforeQ(self):
        return self.insertBeforeQ
    def set_insertBeforeQ(self, insertBeforeQ):
        self.insertBeforeQ = insertBeforeQ
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.button
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_HeaderGroup', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_HeaderGroup')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_HeaderGroup')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_HeaderGroup', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_HeaderGroup'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.insertAfterMso is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            outfile.write(' insertAfterMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterMso), input_name='insertAfterMso')), ))
        if self.insertBeforeMso is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            outfile.write(' insertBeforeMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeMso), input_name='insertBeforeMso')), ))
        if self.insertAfterQ is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            outfile.write(' insertAfterQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterQ), input_name='insertAfterQ')), ))
        if self.insertBeforeQ is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            outfile.write(' insertBeforeQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeQ), input_name='insertBeforeQ')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_HeaderGroup', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for button_ in self.button:
            namespaceprefix_ = self.button_nsprefix_ + ':' if (UseCapturedNS_ and self.button_nsprefix_) else ''
            button_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='button', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('insertAfterMso', node)
        if value is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            self.insertAfterMso = value
            self.validate_ST_ID(self.insertAfterMso)    # validate type ST_ID
        value = find_attr_value_('insertBeforeMso', node)
        if value is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            self.insertBeforeMso = value
            self.validate_ST_ID(self.insertBeforeMso)    # validate type ST_ID
        value = find_attr_value_('insertAfterQ', node)
        if value is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            self.insertAfterQ = value
            self.validate_ST_QID(self.insertAfterQ)    # validate type ST_QID
        value = find_attr_value_('insertBeforeQ', node)
        if value is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            self.insertBeforeQ = value
            self.validate_ST_QID(self.insertBeforeQ)    # validate type ST_QID
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'button':
            class_obj_ = self.get_class_obj_(child_, CT_BackstageRegularButton)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.button.append(obj_)
            obj_.original_tagname_ = 'button'
# end class CT_HeaderGroup


class CT_TaskGroup(GeneratedsSuper):
    """Specifies a TaskGroup."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, allowedTaskSizes=None, id=None, idQ=None, tag=None, idMso=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, label=None, getLabel=None, visible=None, getVisible=None, helperText=None, getHelperText=None, showLabel=None, getShowLabel=None, category=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.allowedTaskSizes = _cast(None, allowedTaskSizes)
        self.allowedTaskSizes_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.idMso = _cast(None, idMso)
        self.idMso_nsprefix_ = None
        self.insertAfterMso = _cast(None, insertAfterMso)
        self.insertAfterMso_nsprefix_ = None
        self.insertBeforeMso = _cast(None, insertBeforeMso)
        self.insertBeforeMso_nsprefix_ = None
        self.insertAfterQ = _cast(None, insertAfterQ)
        self.insertAfterQ_nsprefix_ = None
        self.insertBeforeQ = _cast(None, insertBeforeQ)
        self.insertBeforeQ_nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.getLabel = _cast(None, getLabel)
        self.getLabel_nsprefix_ = None
        self.visible = _cast(bool, visible)
        self.visible_nsprefix_ = None
        self.getVisible = _cast(None, getVisible)
        self.getVisible_nsprefix_ = None
        self.helperText = _cast(None, helperText)
        self.helperText_nsprefix_ = None
        self.getHelperText = _cast(None, getHelperText)
        self.getHelperText_nsprefix_ = None
        self.showLabel = _cast(bool, showLabel)
        self.showLabel_nsprefix_ = None
        self.getShowLabel = _cast(None, getShowLabel)
        self.getShowLabel_nsprefix_ = None
        if category is None:
            self.category = []
        else:
            self.category = category
        self.category_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_TaskGroup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_TaskGroup.subclass:
            return CT_TaskGroup.subclass(*args_, **kwargs_)
        else:
            return CT_TaskGroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_category(self):
        return self.category
    def set_category(self, category):
        self.category = category
    def add_category(self, value):
        self.category.append(value)
    def insert_category_at(self, index, value):
        self.category.insert(index, value)
    def replace_category_at(self, index, value):
        self.category[index] = value
    def get_allowedTaskSizes(self):
        return self.allowedTaskSizes
    def set_allowedTaskSizes(self, allowedTaskSizes):
        self.allowedTaskSizes = allowedTaskSizes
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_idMso(self):
        return self.idMso
    def set_idMso(self, idMso):
        self.idMso = idMso
    def get_insertAfterMso(self):
        return self.insertAfterMso
    def set_insertAfterMso(self, insertAfterMso):
        self.insertAfterMso = insertAfterMso
    def get_insertBeforeMso(self):
        return self.insertBeforeMso
    def set_insertBeforeMso(self, insertBeforeMso):
        self.insertBeforeMso = insertBeforeMso
    def get_insertAfterQ(self):
        return self.insertAfterQ
    def set_insertAfterQ(self, insertAfterQ):
        self.insertAfterQ = insertAfterQ
    def get_insertBeforeQ(self):
        return self.insertBeforeQ
    def set_insertBeforeQ(self, insertBeforeQ):
        self.insertBeforeQ = insertBeforeQ
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_getLabel(self):
        return self.getLabel
    def set_getLabel(self, getLabel):
        self.getLabel = getLabel
    def get_visible(self):
        return self.visible
    def set_visible(self, visible):
        self.visible = visible
    def get_getVisible(self):
        return self.getVisible
    def set_getVisible(self, getVisible):
        self.getVisible = getVisible
    def get_helperText(self):
        return self.helperText
    def set_helperText(self, helperText):
        self.helperText = helperText
    def get_getHelperText(self):
        return self.getHelperText
    def set_getHelperText(self, getHelperText):
        self.getHelperText = getHelperText
    def get_showLabel(self):
        return self.showLabel
    def set_showLabel(self, showLabel):
        self.showLabel = showLabel
    def get_getShowLabel(self):
        return self.getShowLabel
    def set_getShowLabel(self, getShowLabel):
        self.getShowLabel = getShowLabel
    def validate_ST_TaskSizes(self, value):
        # Validate type ST_TaskSizes, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['largeMediumSmall', 'largeMedium', 'large', 'mediumSmall', 'medium', 'small']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ST_TaskSizes' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_LongString(self, value):
        # Validate type ST_LongString, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_LongString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_LongString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.category
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_TaskGroup', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_TaskGroup')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_TaskGroup')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_TaskGroup', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_TaskGroup'):
        if self.allowedTaskSizes is not None and 'allowedTaskSizes' not in already_processed:
            already_processed.add('allowedTaskSizes')
            outfile.write(' allowedTaskSizes=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.allowedTaskSizes), input_name='allowedTaskSizes')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.idMso is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            outfile.write(' idMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idMso), input_name='idMso')), ))
        if self.insertAfterMso is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            outfile.write(' insertAfterMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterMso), input_name='insertAfterMso')), ))
        if self.insertBeforeMso is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            outfile.write(' insertBeforeMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeMso), input_name='insertBeforeMso')), ))
        if self.insertAfterQ is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            outfile.write(' insertAfterQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterQ), input_name='insertAfterQ')), ))
        if self.insertBeforeQ is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            outfile.write(' insertBeforeQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeQ), input_name='insertBeforeQ')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.getLabel is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            outfile.write(' getLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getLabel), input_name='getLabel')), ))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            outfile.write(' visible="%s"' % self.gds_format_boolean(self.visible, input_name='visible'))
        if self.getVisible is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            outfile.write(' getVisible=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getVisible), input_name='getVisible')), ))
        if self.helperText is not None and 'helperText' not in already_processed:
            already_processed.add('helperText')
            outfile.write(' helperText=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.helperText), input_name='helperText')), ))
        if self.getHelperText is not None and 'getHelperText' not in already_processed:
            already_processed.add('getHelperText')
            outfile.write(' getHelperText=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getHelperText), input_name='getHelperText')), ))
        if self.showLabel is not None and 'showLabel' not in already_processed:
            already_processed.add('showLabel')
            outfile.write(' showLabel="%s"' % self.gds_format_boolean(self.showLabel, input_name='showLabel'))
        if self.getShowLabel is not None and 'getShowLabel' not in already_processed:
            already_processed.add('getShowLabel')
            outfile.write(' getShowLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getShowLabel), input_name='getShowLabel')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_TaskGroup', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for category_ in self.category:
            namespaceprefix_ = self.category_nsprefix_ + ':' if (UseCapturedNS_ and self.category_nsprefix_) else ''
            category_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='category', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('allowedTaskSizes', node)
        if value is not None and 'allowedTaskSizes' not in already_processed:
            already_processed.add('allowedTaskSizes')
            self.allowedTaskSizes = value
            self.validate_ST_TaskSizes(self.allowedTaskSizes)    # validate type ST_TaskSizes
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('idMso', node)
        if value is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            self.idMso = value
            self.validate_ST_ID(self.idMso)    # validate type ST_ID
        value = find_attr_value_('insertAfterMso', node)
        if value is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            self.insertAfterMso = value
            self.validate_ST_ID(self.insertAfterMso)    # validate type ST_ID
        value = find_attr_value_('insertBeforeMso', node)
        if value is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            self.insertBeforeMso = value
            self.validate_ST_ID(self.insertBeforeMso)    # validate type ST_ID
        value = find_attr_value_('insertAfterQ', node)
        if value is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            self.insertAfterQ = value
            self.validate_ST_QID(self.insertAfterQ)    # validate type ST_QID
        value = find_attr_value_('insertBeforeQ', node)
        if value is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            self.insertBeforeQ = value
            self.validate_ST_QID(self.insertBeforeQ)    # validate type ST_QID
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
            self.validate_ST_String(self.label)    # validate type ST_String
        value = find_attr_value_('getLabel', node)
        if value is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            self.getLabel = value
            self.validate_ST_Delegate(self.getLabel)    # validate type ST_Delegate
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            if value in ('true', '1'):
                self.visible = True
            elif value in ('false', '0'):
                self.visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getVisible', node)
        if value is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            self.getVisible = value
            self.validate_ST_Delegate(self.getVisible)    # validate type ST_Delegate
        value = find_attr_value_('helperText', node)
        if value is not None and 'helperText' not in already_processed:
            already_processed.add('helperText')
            self.helperText = value
            self.validate_ST_LongString(self.helperText)    # validate type ST_LongString
        value = find_attr_value_('getHelperText', node)
        if value is not None and 'getHelperText' not in already_processed:
            already_processed.add('getHelperText')
            self.getHelperText = value
            self.validate_ST_Delegate(self.getHelperText)    # validate type ST_Delegate
        value = find_attr_value_('showLabel', node)
        if value is not None and 'showLabel' not in already_processed:
            already_processed.add('showLabel')
            if value in ('true', '1'):
                self.showLabel = True
            elif value in ('false', '0'):
                self.showLabel = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getShowLabel', node)
        if value is not None and 'getShowLabel' not in already_processed:
            already_processed.add('getShowLabel')
            self.getShowLabel = value
            self.validate_ST_Delegate(self.getShowLabel)    # validate type ST_Delegate
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'category':
            obj_ = CT_TaskGroupCategory.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.category.append(obj_)
            obj_.original_tagname_ = 'category'
# end class CT_TaskGroup


class CT_TaskGroupCategory(GeneratedsSuper):
    """Specifies a collection of TaskGroupTask controls."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, idQ=None, tag=None, idMso=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, label=None, getLabel=None, task=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.idMso = _cast(None, idMso)
        self.idMso_nsprefix_ = None
        self.insertAfterMso = _cast(None, insertAfterMso)
        self.insertAfterMso_nsprefix_ = None
        self.insertBeforeMso = _cast(None, insertBeforeMso)
        self.insertBeforeMso_nsprefix_ = None
        self.insertAfterQ = _cast(None, insertAfterQ)
        self.insertAfterQ_nsprefix_ = None
        self.insertBeforeQ = _cast(None, insertBeforeQ)
        self.insertBeforeQ_nsprefix_ = None
        self.visible = _cast(bool, visible)
        self.visible_nsprefix_ = None
        self.getVisible = _cast(None, getVisible)
        self.getVisible_nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.getLabel = _cast(None, getLabel)
        self.getLabel_nsprefix_ = None
        if task is None:
            self.task = []
        else:
            self.task = task
        self.task_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_TaskGroupCategory)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_TaskGroupCategory.subclass:
            return CT_TaskGroupCategory.subclass(*args_, **kwargs_)
        else:
            return CT_TaskGroupCategory(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_task(self):
        return self.task
    def set_task(self, task):
        self.task = task
    def add_task(self, value):
        self.task.append(value)
    def insert_task_at(self, index, value):
        self.task.insert(index, value)
    def replace_task_at(self, index, value):
        self.task[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_idMso(self):
        return self.idMso
    def set_idMso(self, idMso):
        self.idMso = idMso
    def get_insertAfterMso(self):
        return self.insertAfterMso
    def set_insertAfterMso(self, insertAfterMso):
        self.insertAfterMso = insertAfterMso
    def get_insertBeforeMso(self):
        return self.insertBeforeMso
    def set_insertBeforeMso(self, insertBeforeMso):
        self.insertBeforeMso = insertBeforeMso
    def get_insertAfterQ(self):
        return self.insertAfterQ
    def set_insertAfterQ(self, insertAfterQ):
        self.insertAfterQ = insertAfterQ
    def get_insertBeforeQ(self):
        return self.insertBeforeQ
    def set_insertBeforeQ(self, insertBeforeQ):
        self.insertBeforeQ = insertBeforeQ
    def get_visible(self):
        return self.visible
    def set_visible(self, visible):
        self.visible = visible
    def get_getVisible(self):
        return self.getVisible
    def set_getVisible(self, getVisible):
        self.getVisible = getVisible
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_getLabel(self):
        return self.getLabel
    def set_getLabel(self, getLabel):
        self.getLabel = getLabel
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.task
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_TaskGroupCategory', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_TaskGroupCategory')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_TaskGroupCategory')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_TaskGroupCategory', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_TaskGroupCategory'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.idMso is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            outfile.write(' idMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idMso), input_name='idMso')), ))
        if self.insertAfterMso is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            outfile.write(' insertAfterMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterMso), input_name='insertAfterMso')), ))
        if self.insertBeforeMso is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            outfile.write(' insertBeforeMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeMso), input_name='insertBeforeMso')), ))
        if self.insertAfterQ is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            outfile.write(' insertAfterQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterQ), input_name='insertAfterQ')), ))
        if self.insertBeforeQ is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            outfile.write(' insertBeforeQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeQ), input_name='insertBeforeQ')), ))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            outfile.write(' visible="%s"' % self.gds_format_boolean(self.visible, input_name='visible'))
        if self.getVisible is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            outfile.write(' getVisible=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getVisible), input_name='getVisible')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.getLabel is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            outfile.write(' getLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getLabel), input_name='getLabel')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_TaskGroupCategory', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for task_ in self.task:
            namespaceprefix_ = self.task_nsprefix_ + ':' if (UseCapturedNS_ and self.task_nsprefix_) else ''
            task_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='task', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('idMso', node)
        if value is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            self.idMso = value
            self.validate_ST_ID(self.idMso)    # validate type ST_ID
        value = find_attr_value_('insertAfterMso', node)
        if value is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            self.insertAfterMso = value
            self.validate_ST_ID(self.insertAfterMso)    # validate type ST_ID
        value = find_attr_value_('insertBeforeMso', node)
        if value is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            self.insertBeforeMso = value
            self.validate_ST_ID(self.insertBeforeMso)    # validate type ST_ID
        value = find_attr_value_('insertAfterQ', node)
        if value is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            self.insertAfterQ = value
            self.validate_ST_QID(self.insertAfterQ)    # validate type ST_QID
        value = find_attr_value_('insertBeforeQ', node)
        if value is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            self.insertBeforeQ = value
            self.validate_ST_QID(self.insertBeforeQ)    # validate type ST_QID
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            if value in ('true', '1'):
                self.visible = True
            elif value in ('false', '0'):
                self.visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getVisible', node)
        if value is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            self.getVisible = value
            self.validate_ST_Delegate(self.getVisible)    # validate type ST_Delegate
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
            self.validate_ST_String(self.label)    # validate type ST_String
        value = find_attr_value_('getLabel', node)
        if value is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            self.getLabel = value
            self.validate_ST_Delegate(self.getLabel)    # validate type ST_Delegate
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'task':
            obj_ = CT_TaskGroupTask.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.task.append(obj_)
            obj_.original_tagname_ = 'task'
# end class CT_TaskGroupCategory


class CT_TaskGroupTask(GeneratedsSuper):
    """Specifies a task in a TaskGroup"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, idQ=None, tag=None, idMso=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, onAction=None, isDefinitive=None, image=None, imageMso=None, getImage=None, enabled=None, getEnabled=None, label=None, getLabel=None, visible=None, getVisible=None, description=None, getDescription=None, keytip=None, getKeytip=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.idMso = _cast(None, idMso)
        self.idMso_nsprefix_ = None
        self.insertAfterMso = _cast(None, insertAfterMso)
        self.insertAfterMso_nsprefix_ = None
        self.insertBeforeMso = _cast(None, insertBeforeMso)
        self.insertBeforeMso_nsprefix_ = None
        self.insertAfterQ = _cast(None, insertAfterQ)
        self.insertAfterQ_nsprefix_ = None
        self.insertBeforeQ = _cast(None, insertBeforeQ)
        self.insertBeforeQ_nsprefix_ = None
        self.onAction = _cast(None, onAction)
        self.onAction_nsprefix_ = None
        self.isDefinitive = _cast(bool, isDefinitive)
        self.isDefinitive_nsprefix_ = None
        self.image = _cast(None, image)
        self.image_nsprefix_ = None
        self.imageMso = _cast(None, imageMso)
        self.imageMso_nsprefix_ = None
        self.getImage = _cast(None, getImage)
        self.getImage_nsprefix_ = None
        self.enabled = _cast(bool, enabled)
        self.enabled_nsprefix_ = None
        self.getEnabled = _cast(None, getEnabled)
        self.getEnabled_nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.getLabel = _cast(None, getLabel)
        self.getLabel_nsprefix_ = None
        self.visible = _cast(bool, visible)
        self.visible_nsprefix_ = None
        self.getVisible = _cast(None, getVisible)
        self.getVisible_nsprefix_ = None
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
        self.getDescription = _cast(None, getDescription)
        self.getDescription_nsprefix_ = None
        self.keytip = _cast(None, keytip)
        self.keytip_nsprefix_ = None
        self.getKeytip = _cast(None, getKeytip)
        self.getKeytip_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_TaskGroupTask)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_TaskGroupTask.subclass:
            return CT_TaskGroupTask.subclass(*args_, **kwargs_)
        else:
            return CT_TaskGroupTask(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_idMso(self):
        return self.idMso
    def set_idMso(self, idMso):
        self.idMso = idMso
    def get_insertAfterMso(self):
        return self.insertAfterMso
    def set_insertAfterMso(self, insertAfterMso):
        self.insertAfterMso = insertAfterMso
    def get_insertBeforeMso(self):
        return self.insertBeforeMso
    def set_insertBeforeMso(self, insertBeforeMso):
        self.insertBeforeMso = insertBeforeMso
    def get_insertAfterQ(self):
        return self.insertAfterQ
    def set_insertAfterQ(self, insertAfterQ):
        self.insertAfterQ = insertAfterQ
    def get_insertBeforeQ(self):
        return self.insertBeforeQ
    def set_insertBeforeQ(self, insertBeforeQ):
        self.insertBeforeQ = insertBeforeQ
    def get_onAction(self):
        return self.onAction
    def set_onAction(self, onAction):
        self.onAction = onAction
    def get_isDefinitive(self):
        return self.isDefinitive
    def set_isDefinitive(self, isDefinitive):
        self.isDefinitive = isDefinitive
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def get_imageMso(self):
        return self.imageMso
    def set_imageMso(self, imageMso):
        self.imageMso = imageMso
    def get_getImage(self):
        return self.getImage
    def set_getImage(self, getImage):
        self.getImage = getImage
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    def get_getEnabled(self):
        return self.getEnabled
    def set_getEnabled(self, getEnabled):
        self.getEnabled = getEnabled
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_getLabel(self):
        return self.getLabel
    def set_getLabel(self, getLabel):
        self.getLabel = getLabel
    def get_visible(self):
        return self.visible
    def set_visible(self, visible):
        self.visible = visible
    def get_getVisible(self):
        return self.getVisible
    def set_getVisible(self, getVisible):
        self.getVisible = getVisible
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_getDescription(self):
        return self.getDescription
    def set_getDescription(self, getDescription):
        self.getDescription = getDescription
    def get_keytip(self):
        return self.keytip
    def set_keytip(self, keytip):
        self.keytip = keytip
    def get_getKeytip(self):
        return self.getKeytip
    def set_getKeytip(self, getKeytip):
        self.getKeytip = getKeytip
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Uri(self, value):
        # Validate type ST_Uri, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Uri' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Uri' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_LongString(self, value):
        # Validate type ST_LongString, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_LongString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_LongString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Keytip(self, value):
        # Validate type ST_Keytip, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Keytip' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Keytip' % {"value" : value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_TaskGroupTask', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_TaskGroupTask')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_TaskGroupTask')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_TaskGroupTask', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_TaskGroupTask'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.idMso is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            outfile.write(' idMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idMso), input_name='idMso')), ))
        if self.insertAfterMso is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            outfile.write(' insertAfterMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterMso), input_name='insertAfterMso')), ))
        if self.insertBeforeMso is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            outfile.write(' insertBeforeMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeMso), input_name='insertBeforeMso')), ))
        if self.insertAfterQ is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            outfile.write(' insertAfterQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterQ), input_name='insertAfterQ')), ))
        if self.insertBeforeQ is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            outfile.write(' insertBeforeQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeQ), input_name='insertBeforeQ')), ))
        if self.onAction is not None and 'onAction' not in already_processed:
            already_processed.add('onAction')
            outfile.write(' onAction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.onAction), input_name='onAction')), ))
        if self.isDefinitive is not None and 'isDefinitive' not in already_processed:
            already_processed.add('isDefinitive')
            outfile.write(' isDefinitive="%s"' % self.gds_format_boolean(self.isDefinitive, input_name='isDefinitive'))
        if self.image is not None and 'image' not in already_processed:
            already_processed.add('image')
            outfile.write(' image=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.image), input_name='image')), ))
        if self.imageMso is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            outfile.write(' imageMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.imageMso), input_name='imageMso')), ))
        if self.getImage is not None and 'getImage' not in already_processed:
            already_processed.add('getImage')
            outfile.write(' getImage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getImage), input_name='getImage')), ))
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            outfile.write(' enabled="%s"' % self.gds_format_boolean(self.enabled, input_name='enabled'))
        if self.getEnabled is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            outfile.write(' getEnabled=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getEnabled), input_name='getEnabled')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.getLabel is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            outfile.write(' getLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getLabel), input_name='getLabel')), ))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            outfile.write(' visible="%s"' % self.gds_format_boolean(self.visible, input_name='visible'))
        if self.getVisible is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            outfile.write(' getVisible=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getVisible), input_name='getVisible')), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.getDescription is not None and 'getDescription' not in already_processed:
            already_processed.add('getDescription')
            outfile.write(' getDescription=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getDescription), input_name='getDescription')), ))
        if self.keytip is not None and 'keytip' not in already_processed:
            already_processed.add('keytip')
            outfile.write(' keytip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.keytip), input_name='keytip')), ))
        if self.getKeytip is not None and 'getKeytip' not in already_processed:
            already_processed.add('getKeytip')
            outfile.write(' getKeytip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getKeytip), input_name='getKeytip')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_TaskGroupTask', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('idMso', node)
        if value is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            self.idMso = value
            self.validate_ST_ID(self.idMso)    # validate type ST_ID
        value = find_attr_value_('insertAfterMso', node)
        if value is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            self.insertAfterMso = value
            self.validate_ST_ID(self.insertAfterMso)    # validate type ST_ID
        value = find_attr_value_('insertBeforeMso', node)
        if value is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            self.insertBeforeMso = value
            self.validate_ST_ID(self.insertBeforeMso)    # validate type ST_ID
        value = find_attr_value_('insertAfterQ', node)
        if value is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            self.insertAfterQ = value
            self.validate_ST_QID(self.insertAfterQ)    # validate type ST_QID
        value = find_attr_value_('insertBeforeQ', node)
        if value is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            self.insertBeforeQ = value
            self.validate_ST_QID(self.insertBeforeQ)    # validate type ST_QID
        value = find_attr_value_('onAction', node)
        if value is not None and 'onAction' not in already_processed:
            already_processed.add('onAction')
            self.onAction = value
            self.validate_ST_Delegate(self.onAction)    # validate type ST_Delegate
        value = find_attr_value_('isDefinitive', node)
        if value is not None and 'isDefinitive' not in already_processed:
            already_processed.add('isDefinitive')
            if value in ('true', '1'):
                self.isDefinitive = True
            elif value in ('false', '0'):
                self.isDefinitive = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('image', node)
        if value is not None and 'image' not in already_processed:
            already_processed.add('image')
            self.image = value
            self.validate_ST_Uri(self.image)    # validate type ST_Uri
        value = find_attr_value_('imageMso', node)
        if value is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            self.imageMso = value
            self.validate_ST_ID(self.imageMso)    # validate type ST_ID
        value = find_attr_value_('getImage', node)
        if value is not None and 'getImage' not in already_processed:
            already_processed.add('getImage')
            self.getImage = value
            self.validate_ST_Delegate(self.getImage)    # validate type ST_Delegate
        value = find_attr_value_('enabled', node)
        if value is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            if value in ('true', '1'):
                self.enabled = True
            elif value in ('false', '0'):
                self.enabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getEnabled', node)
        if value is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            self.getEnabled = value
            self.validate_ST_Delegate(self.getEnabled)    # validate type ST_Delegate
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
            self.validate_ST_String(self.label)    # validate type ST_String
        value = find_attr_value_('getLabel', node)
        if value is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            self.getLabel = value
            self.validate_ST_Delegate(self.getLabel)    # validate type ST_Delegate
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            if value in ('true', '1'):
                self.visible = True
            elif value in ('false', '0'):
                self.visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getVisible', node)
        if value is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            self.getVisible = value
            self.validate_ST_Delegate(self.getVisible)    # validate type ST_Delegate
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
            self.validate_ST_LongString(self.description)    # validate type ST_LongString
        value = find_attr_value_('getDescription', node)
        if value is not None and 'getDescription' not in already_processed:
            already_processed.add('getDescription')
            self.getDescription = value
            self.validate_ST_Delegate(self.getDescription)    # validate type ST_Delegate
        value = find_attr_value_('keytip', node)
        if value is not None and 'keytip' not in already_processed:
            already_processed.add('keytip')
            self.keytip = value
            self.keytip = ' '.join(self.keytip.split())
            self.validate_ST_Keytip(self.keytip)    # validate type ST_Keytip
        value = find_attr_value_('getKeytip', node)
        if value is not None and 'getKeytip' not in already_processed:
            already_processed.add('getKeytip')
            self.getKeytip = value
            self.validate_ST_Delegate(self.getKeytip)    # validate type ST_Delegate
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CT_TaskGroupTask


class CT_TaskFormGroup(GeneratedsSuper):
    """Specifies a TaskFormGroup."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, allowedTaskSizes=None, id=None, idQ=None, tag=None, idMso=None, label=None, getLabel=None, visible=None, getVisible=None, helperText=None, getHelperText=None, showLabel=None, getShowLabel=None, category=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.allowedTaskSizes = _cast(None, allowedTaskSizes)
        self.allowedTaskSizes_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.idMso = _cast(None, idMso)
        self.idMso_nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.getLabel = _cast(None, getLabel)
        self.getLabel_nsprefix_ = None
        self.visible = _cast(bool, visible)
        self.visible_nsprefix_ = None
        self.getVisible = _cast(None, getVisible)
        self.getVisible_nsprefix_ = None
        self.helperText = _cast(None, helperText)
        self.helperText_nsprefix_ = None
        self.getHelperText = _cast(None, getHelperText)
        self.getHelperText_nsprefix_ = None
        self.showLabel = _cast(bool, showLabel)
        self.showLabel_nsprefix_ = None
        self.getShowLabel = _cast(None, getShowLabel)
        self.getShowLabel_nsprefix_ = None
        if category is None:
            self.category = []
        else:
            self.category = category
        self.category_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_TaskFormGroup)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_TaskFormGroup.subclass:
            return CT_TaskFormGroup.subclass(*args_, **kwargs_)
        else:
            return CT_TaskFormGroup(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_category(self):
        return self.category
    def set_category(self, category):
        self.category = category
    def add_category(self, value):
        self.category.append(value)
    def insert_category_at(self, index, value):
        self.category.insert(index, value)
    def replace_category_at(self, index, value):
        self.category[index] = value
    def get_allowedTaskSizes(self):
        return self.allowedTaskSizes
    def set_allowedTaskSizes(self, allowedTaskSizes):
        self.allowedTaskSizes = allowedTaskSizes
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_idMso(self):
        return self.idMso
    def set_idMso(self, idMso):
        self.idMso = idMso
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_getLabel(self):
        return self.getLabel
    def set_getLabel(self, getLabel):
        self.getLabel = getLabel
    def get_visible(self):
        return self.visible
    def set_visible(self, visible):
        self.visible = visible
    def get_getVisible(self):
        return self.getVisible
    def set_getVisible(self, getVisible):
        self.getVisible = getVisible
    def get_helperText(self):
        return self.helperText
    def set_helperText(self, helperText):
        self.helperText = helperText
    def get_getHelperText(self):
        return self.getHelperText
    def set_getHelperText(self, getHelperText):
        self.getHelperText = getHelperText
    def get_showLabel(self):
        return self.showLabel
    def set_showLabel(self, showLabel):
        self.showLabel = showLabel
    def get_getShowLabel(self):
        return self.getShowLabel
    def set_getShowLabel(self, getShowLabel):
        self.getShowLabel = getShowLabel
    def validate_ST_TaskSizes(self, value):
        # Validate type ST_TaskSizes, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            value = value
            enumerations = ['largeMediumSmall', 'largeMedium', 'large', 'mediumSmall', 'medium', 'small']
            if value not in enumerations:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd enumeration restriction on ST_TaskSizes' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_LongString(self, value):
        # Validate type ST_LongString, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_LongString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_LongString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.category
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_TaskFormGroup', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_TaskFormGroup')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_TaskFormGroup')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_TaskFormGroup', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_TaskFormGroup'):
        if self.allowedTaskSizes is not None and 'allowedTaskSizes' not in already_processed:
            already_processed.add('allowedTaskSizes')
            outfile.write(' allowedTaskSizes=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.allowedTaskSizes), input_name='allowedTaskSizes')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.idMso is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            outfile.write(' idMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idMso), input_name='idMso')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.getLabel is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            outfile.write(' getLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getLabel), input_name='getLabel')), ))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            outfile.write(' visible="%s"' % self.gds_format_boolean(self.visible, input_name='visible'))
        if self.getVisible is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            outfile.write(' getVisible=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getVisible), input_name='getVisible')), ))
        if self.helperText is not None and 'helperText' not in already_processed:
            already_processed.add('helperText')
            outfile.write(' helperText=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.helperText), input_name='helperText')), ))
        if self.getHelperText is not None and 'getHelperText' not in already_processed:
            already_processed.add('getHelperText')
            outfile.write(' getHelperText=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getHelperText), input_name='getHelperText')), ))
        if self.showLabel is not None and 'showLabel' not in already_processed:
            already_processed.add('showLabel')
            outfile.write(' showLabel="%s"' % self.gds_format_boolean(self.showLabel, input_name='showLabel'))
        if self.getShowLabel is not None and 'getShowLabel' not in already_processed:
            already_processed.add('getShowLabel')
            outfile.write(' getShowLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getShowLabel), input_name='getShowLabel')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_TaskFormGroup', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for category_ in self.category:
            namespaceprefix_ = self.category_nsprefix_ + ':' if (UseCapturedNS_ and self.category_nsprefix_) else ''
            category_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='category', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('allowedTaskSizes', node)
        if value is not None and 'allowedTaskSizes' not in already_processed:
            already_processed.add('allowedTaskSizes')
            self.allowedTaskSizes = value
            self.validate_ST_TaskSizes(self.allowedTaskSizes)    # validate type ST_TaskSizes
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('idMso', node)
        if value is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            self.idMso = value
            self.validate_ST_ID(self.idMso)    # validate type ST_ID
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
            self.validate_ST_String(self.label)    # validate type ST_String
        value = find_attr_value_('getLabel', node)
        if value is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            self.getLabel = value
            self.validate_ST_Delegate(self.getLabel)    # validate type ST_Delegate
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            if value in ('true', '1'):
                self.visible = True
            elif value in ('false', '0'):
                self.visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getVisible', node)
        if value is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            self.getVisible = value
            self.validate_ST_Delegate(self.getVisible)    # validate type ST_Delegate
        value = find_attr_value_('helperText', node)
        if value is not None and 'helperText' not in already_processed:
            already_processed.add('helperText')
            self.helperText = value
            self.validate_ST_LongString(self.helperText)    # validate type ST_LongString
        value = find_attr_value_('getHelperText', node)
        if value is not None and 'getHelperText' not in already_processed:
            already_processed.add('getHelperText')
            self.getHelperText = value
            self.validate_ST_Delegate(self.getHelperText)    # validate type ST_Delegate
        value = find_attr_value_('showLabel', node)
        if value is not None and 'showLabel' not in already_processed:
            already_processed.add('showLabel')
            if value in ('true', '1'):
                self.showLabel = True
            elif value in ('false', '0'):
                self.showLabel = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getShowLabel', node)
        if value is not None and 'getShowLabel' not in already_processed:
            already_processed.add('getShowLabel')
            self.getShowLabel = value
            self.validate_ST_Delegate(self.getShowLabel)    # validate type ST_Delegate
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'category':
            obj_ = CT_TaskFormGroupCategory.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.category.append(obj_)
            obj_.original_tagname_ = 'category'
# end class CT_TaskFormGroup


class CT_TaskFormGroupCategory(GeneratedsSuper):
    """Specifies a collection of TaskFormGroupTask controls."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, idQ=None, tag=None, idMso=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, label=None, getLabel=None, task=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.idMso = _cast(None, idMso)
        self.idMso_nsprefix_ = None
        self.insertAfterMso = _cast(None, insertAfterMso)
        self.insertAfterMso_nsprefix_ = None
        self.insertBeforeMso = _cast(None, insertBeforeMso)
        self.insertBeforeMso_nsprefix_ = None
        self.insertAfterQ = _cast(None, insertAfterQ)
        self.insertAfterQ_nsprefix_ = None
        self.insertBeforeQ = _cast(None, insertBeforeQ)
        self.insertBeforeQ_nsprefix_ = None
        self.visible = _cast(bool, visible)
        self.visible_nsprefix_ = None
        self.getVisible = _cast(None, getVisible)
        self.getVisible_nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.getLabel = _cast(None, getLabel)
        self.getLabel_nsprefix_ = None
        if task is None:
            self.task = []
        else:
            self.task = task
        self.task_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_TaskFormGroupCategory)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_TaskFormGroupCategory.subclass:
            return CT_TaskFormGroupCategory.subclass(*args_, **kwargs_)
        else:
            return CT_TaskFormGroupCategory(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_task(self):
        return self.task
    def set_task(self, task):
        self.task = task
    def add_task(self, value):
        self.task.append(value)
    def insert_task_at(self, index, value):
        self.task.insert(index, value)
    def replace_task_at(self, index, value):
        self.task[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_idMso(self):
        return self.idMso
    def set_idMso(self, idMso):
        self.idMso = idMso
    def get_insertAfterMso(self):
        return self.insertAfterMso
    def set_insertAfterMso(self, insertAfterMso):
        self.insertAfterMso = insertAfterMso
    def get_insertBeforeMso(self):
        return self.insertBeforeMso
    def set_insertBeforeMso(self, insertBeforeMso):
        self.insertBeforeMso = insertBeforeMso
    def get_insertAfterQ(self):
        return self.insertAfterQ
    def set_insertAfterQ(self, insertAfterQ):
        self.insertAfterQ = insertAfterQ
    def get_insertBeforeQ(self):
        return self.insertBeforeQ
    def set_insertBeforeQ(self, insertBeforeQ):
        self.insertBeforeQ = insertBeforeQ
    def get_visible(self):
        return self.visible
    def set_visible(self, visible):
        self.visible = visible
    def get_getVisible(self):
        return self.getVisible
    def set_getVisible(self, getVisible):
        self.getVisible = getVisible
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_getLabel(self):
        return self.getLabel
    def set_getLabel(self, getLabel):
        self.getLabel = getLabel
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.task
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_TaskFormGroupCategory', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_TaskFormGroupCategory')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_TaskFormGroupCategory')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_TaskFormGroupCategory', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_TaskFormGroupCategory'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.idMso is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            outfile.write(' idMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idMso), input_name='idMso')), ))
        if self.insertAfterMso is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            outfile.write(' insertAfterMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterMso), input_name='insertAfterMso')), ))
        if self.insertBeforeMso is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            outfile.write(' insertBeforeMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeMso), input_name='insertBeforeMso')), ))
        if self.insertAfterQ is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            outfile.write(' insertAfterQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterQ), input_name='insertAfterQ')), ))
        if self.insertBeforeQ is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            outfile.write(' insertBeforeQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeQ), input_name='insertBeforeQ')), ))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            outfile.write(' visible="%s"' % self.gds_format_boolean(self.visible, input_name='visible'))
        if self.getVisible is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            outfile.write(' getVisible=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getVisible), input_name='getVisible')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.getLabel is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            outfile.write(' getLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getLabel), input_name='getLabel')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_TaskFormGroupCategory', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for task_ in self.task:
            namespaceprefix_ = self.task_nsprefix_ + ':' if (UseCapturedNS_ and self.task_nsprefix_) else ''
            task_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='task', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('idMso', node)
        if value is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            self.idMso = value
            self.validate_ST_ID(self.idMso)    # validate type ST_ID
        value = find_attr_value_('insertAfterMso', node)
        if value is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            self.insertAfterMso = value
            self.validate_ST_ID(self.insertAfterMso)    # validate type ST_ID
        value = find_attr_value_('insertBeforeMso', node)
        if value is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            self.insertBeforeMso = value
            self.validate_ST_ID(self.insertBeforeMso)    # validate type ST_ID
        value = find_attr_value_('insertAfterQ', node)
        if value is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            self.insertAfterQ = value
            self.validate_ST_QID(self.insertAfterQ)    # validate type ST_QID
        value = find_attr_value_('insertBeforeQ', node)
        if value is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            self.insertBeforeQ = value
            self.validate_ST_QID(self.insertBeforeQ)    # validate type ST_QID
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            if value in ('true', '1'):
                self.visible = True
            elif value in ('false', '0'):
                self.visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getVisible', node)
        if value is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            self.getVisible = value
            self.validate_ST_Delegate(self.getVisible)    # validate type ST_Delegate
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
            self.validate_ST_String(self.label)    # validate type ST_String
        value = find_attr_value_('getLabel', node)
        if value is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            self.getLabel = value
            self.validate_ST_Delegate(self.getLabel)    # validate type ST_Delegate
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'task':
            obj_ = CT_TaskFormGroupTask.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.task.append(obj_)
            obj_.original_tagname_ = 'task'
# end class CT_TaskFormGroupCategory


class CT_TaskFormGroupTask(GeneratedsSuper):
    """Specifies a task in a TaskFormGroup"""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, idQ=None, tag=None, idMso=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, image=None, imageMso=None, getImage=None, enabled=None, getEnabled=None, label=None, getLabel=None, visible=None, getVisible=None, description=None, getDescription=None, keytip=None, getKeytip=None, group=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.idMso = _cast(None, idMso)
        self.idMso_nsprefix_ = None
        self.insertAfterMso = _cast(None, insertAfterMso)
        self.insertAfterMso_nsprefix_ = None
        self.insertBeforeMso = _cast(None, insertBeforeMso)
        self.insertBeforeMso_nsprefix_ = None
        self.insertAfterQ = _cast(None, insertAfterQ)
        self.insertAfterQ_nsprefix_ = None
        self.insertBeforeQ = _cast(None, insertBeforeQ)
        self.insertBeforeQ_nsprefix_ = None
        self.image = _cast(None, image)
        self.image_nsprefix_ = None
        self.imageMso = _cast(None, imageMso)
        self.imageMso_nsprefix_ = None
        self.getImage = _cast(None, getImage)
        self.getImage_nsprefix_ = None
        self.enabled = _cast(bool, enabled)
        self.enabled_nsprefix_ = None
        self.getEnabled = _cast(None, getEnabled)
        self.getEnabled_nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.getLabel = _cast(None, getLabel)
        self.getLabel_nsprefix_ = None
        self.visible = _cast(bool, visible)
        self.visible_nsprefix_ = None
        self.getVisible = _cast(None, getVisible)
        self.getVisible_nsprefix_ = None
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
        self.getDescription = _cast(None, getDescription)
        self.getDescription_nsprefix_ = None
        self.keytip = _cast(None, keytip)
        self.keytip_nsprefix_ = None
        self.getKeytip = _cast(None, getKeytip)
        self.getKeytip_nsprefix_ = None
        if group is None:
            self.group = []
        else:
            self.group = group
        self.group_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_TaskFormGroupTask)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_TaskFormGroupTask.subclass:
            return CT_TaskFormGroupTask.subclass(*args_, **kwargs_)
        else:
            return CT_TaskFormGroupTask(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_group(self):
        return self.group
    def set_group(self, group):
        self.group = group
    def add_group(self, value):
        self.group.append(value)
    def insert_group_at(self, index, value):
        self.group.insert(index, value)
    def replace_group_at(self, index, value):
        self.group[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_idMso(self):
        return self.idMso
    def set_idMso(self, idMso):
        self.idMso = idMso
    def get_insertAfterMso(self):
        return self.insertAfterMso
    def set_insertAfterMso(self, insertAfterMso):
        self.insertAfterMso = insertAfterMso
    def get_insertBeforeMso(self):
        return self.insertBeforeMso
    def set_insertBeforeMso(self, insertBeforeMso):
        self.insertBeforeMso = insertBeforeMso
    def get_insertAfterQ(self):
        return self.insertAfterQ
    def set_insertAfterQ(self, insertAfterQ):
        self.insertAfterQ = insertAfterQ
    def get_insertBeforeQ(self):
        return self.insertBeforeQ
    def set_insertBeforeQ(self, insertBeforeQ):
        self.insertBeforeQ = insertBeforeQ
    def get_image(self):
        return self.image
    def set_image(self, image):
        self.image = image
    def get_imageMso(self):
        return self.imageMso
    def set_imageMso(self, imageMso):
        self.imageMso = imageMso
    def get_getImage(self):
        return self.getImage
    def set_getImage(self, getImage):
        self.getImage = getImage
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    def get_getEnabled(self):
        return self.getEnabled
    def set_getEnabled(self, getEnabled):
        self.getEnabled = getEnabled
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_getLabel(self):
        return self.getLabel
    def set_getLabel(self, getLabel):
        self.getLabel = getLabel
    def get_visible(self):
        return self.visible
    def set_visible(self, visible):
        self.visible = visible
    def get_getVisible(self):
        return self.getVisible
    def set_getVisible(self, getVisible):
        self.getVisible = getVisible
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_getDescription(self):
        return self.getDescription
    def set_getDescription(self, getDescription):
        self.getDescription = getDescription
    def get_keytip(self):
        return self.keytip
    def set_keytip(self, keytip):
        self.keytip = keytip
    def get_getKeytip(self):
        return self.getKeytip
    def set_getKeytip(self, getKeytip):
        self.getKeytip = getKeytip
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_Uri(self, value):
        # Validate type ST_Uri, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Uri' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Uri' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_LongString(self, value):
        # Validate type ST_LongString, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4096:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_LongString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_LongString' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Keytip(self, value):
        # Validate type ST_Keytip, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Keytip' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Keytip' % {"value" : value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.group
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_TaskFormGroupTask', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_TaskFormGroupTask')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_TaskFormGroupTask')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_TaskFormGroupTask', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_TaskFormGroupTask'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.idMso is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            outfile.write(' idMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idMso), input_name='idMso')), ))
        if self.insertAfterMso is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            outfile.write(' insertAfterMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterMso), input_name='insertAfterMso')), ))
        if self.insertBeforeMso is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            outfile.write(' insertBeforeMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeMso), input_name='insertBeforeMso')), ))
        if self.insertAfterQ is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            outfile.write(' insertAfterQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterQ), input_name='insertAfterQ')), ))
        if self.insertBeforeQ is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            outfile.write(' insertBeforeQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeQ), input_name='insertBeforeQ')), ))
        if self.image is not None and 'image' not in already_processed:
            already_processed.add('image')
            outfile.write(' image=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.image), input_name='image')), ))
        if self.imageMso is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            outfile.write(' imageMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.imageMso), input_name='imageMso')), ))
        if self.getImage is not None and 'getImage' not in already_processed:
            already_processed.add('getImage')
            outfile.write(' getImage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getImage), input_name='getImage')), ))
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            outfile.write(' enabled="%s"' % self.gds_format_boolean(self.enabled, input_name='enabled'))
        if self.getEnabled is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            outfile.write(' getEnabled=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getEnabled), input_name='getEnabled')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.getLabel is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            outfile.write(' getLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getLabel), input_name='getLabel')), ))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            outfile.write(' visible="%s"' % self.gds_format_boolean(self.visible, input_name='visible'))
        if self.getVisible is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            outfile.write(' getVisible=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getVisible), input_name='getVisible')), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.description), input_name='description')), ))
        if self.getDescription is not None and 'getDescription' not in already_processed:
            already_processed.add('getDescription')
            outfile.write(' getDescription=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getDescription), input_name='getDescription')), ))
        if self.keytip is not None and 'keytip' not in already_processed:
            already_processed.add('keytip')
            outfile.write(' keytip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.keytip), input_name='keytip')), ))
        if self.getKeytip is not None and 'getKeytip' not in already_processed:
            already_processed.add('getKeytip')
            outfile.write(' getKeytip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getKeytip), input_name='getKeytip')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_TaskFormGroupTask', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for group_ in self.group:
            namespaceprefix_ = self.group_nsprefix_ + ':' if (UseCapturedNS_ and self.group_nsprefix_) else ''
            group_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='group', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('idMso', node)
        if value is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            self.idMso = value
            self.validate_ST_ID(self.idMso)    # validate type ST_ID
        value = find_attr_value_('insertAfterMso', node)
        if value is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            self.insertAfterMso = value
            self.validate_ST_ID(self.insertAfterMso)    # validate type ST_ID
        value = find_attr_value_('insertBeforeMso', node)
        if value is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            self.insertBeforeMso = value
            self.validate_ST_ID(self.insertBeforeMso)    # validate type ST_ID
        value = find_attr_value_('insertAfterQ', node)
        if value is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            self.insertAfterQ = value
            self.validate_ST_QID(self.insertAfterQ)    # validate type ST_QID
        value = find_attr_value_('insertBeforeQ', node)
        if value is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            self.insertBeforeQ = value
            self.validate_ST_QID(self.insertBeforeQ)    # validate type ST_QID
        value = find_attr_value_('image', node)
        if value is not None and 'image' not in already_processed:
            already_processed.add('image')
            self.image = value
            self.validate_ST_Uri(self.image)    # validate type ST_Uri
        value = find_attr_value_('imageMso', node)
        if value is not None and 'imageMso' not in already_processed:
            already_processed.add('imageMso')
            self.imageMso = value
            self.validate_ST_ID(self.imageMso)    # validate type ST_ID
        value = find_attr_value_('getImage', node)
        if value is not None and 'getImage' not in already_processed:
            already_processed.add('getImage')
            self.getImage = value
            self.validate_ST_Delegate(self.getImage)    # validate type ST_Delegate
        value = find_attr_value_('enabled', node)
        if value is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            if value in ('true', '1'):
                self.enabled = True
            elif value in ('false', '0'):
                self.enabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getEnabled', node)
        if value is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            self.getEnabled = value
            self.validate_ST_Delegate(self.getEnabled)    # validate type ST_Delegate
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
            self.validate_ST_String(self.label)    # validate type ST_String
        value = find_attr_value_('getLabel', node)
        if value is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            self.getLabel = value
            self.validate_ST_Delegate(self.getLabel)    # validate type ST_Delegate
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            if value in ('true', '1'):
                self.visible = True
            elif value in ('false', '0'):
                self.visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getVisible', node)
        if value is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            self.getVisible = value
            self.validate_ST_Delegate(self.getVisible)    # validate type ST_Delegate
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
            self.validate_ST_LongString(self.description)    # validate type ST_LongString
        value = find_attr_value_('getDescription', node)
        if value is not None and 'getDescription' not in already_processed:
            already_processed.add('getDescription')
            self.getDescription = value
            self.validate_ST_Delegate(self.getDescription)    # validate type ST_Delegate
        value = find_attr_value_('keytip', node)
        if value is not None and 'keytip' not in already_processed:
            already_processed.add('keytip')
            self.keytip = value
            self.keytip = ' '.join(self.keytip.split())
            self.validate_ST_Keytip(self.keytip)    # validate type ST_Keytip
        value = find_attr_value_('getKeytip', node)
        if value is not None and 'getKeytip' not in already_processed:
            already_processed.add('getKeytip')
            self.getKeytip = value
            self.validate_ST_Delegate(self.getKeytip)    # validate type ST_Delegate
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'group':
            obj_ = CT_BackstageGroup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.group.append(obj_)
            obj_.original_tagname_ = 'group'
# end class CT_TaskFormGroupTask


class CT_GroupBox(GeneratedsSuper):
    """Specifies a groupBox."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, id=None, idQ=None, tag=None, expand=None, label=None, getLabel=None, button=None, checkBox=None, editBox=None, dropDown=None, radioGroup=None, comboBox=None, hyperlink=None, labelControl=None, groupBox=None, layoutContainer=None, imageControl=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.expand = _cast(None, expand)
        self.expand_nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.getLabel = _cast(None, getLabel)
        self.getLabel_nsprefix_ = None
        if button is None:
            self.button = []
        else:
            self.button = button
        self.button_nsprefix_ = None
        if checkBox is None:
            self.checkBox = []
        else:
            self.checkBox = checkBox
        self.checkBox_nsprefix_ = None
        if editBox is None:
            self.editBox = []
        else:
            self.editBox = editBox
        self.editBox_nsprefix_ = None
        if dropDown is None:
            self.dropDown = []
        else:
            self.dropDown = dropDown
        self.dropDown_nsprefix_ = None
        if radioGroup is None:
            self.radioGroup = []
        else:
            self.radioGroup = radioGroup
        self.radioGroup_nsprefix_ = None
        if comboBox is None:
            self.comboBox = []
        else:
            self.comboBox = comboBox
        self.comboBox_nsprefix_ = None
        if hyperlink is None:
            self.hyperlink = []
        else:
            self.hyperlink = hyperlink
        self.hyperlink_nsprefix_ = None
        if labelControl is None:
            self.labelControl = []
        else:
            self.labelControl = labelControl
        self.labelControl_nsprefix_ = None
        if groupBox is None:
            self.groupBox = []
        else:
            self.groupBox = groupBox
        self.groupBox_nsprefix_ = None
        if layoutContainer is None:
            self.layoutContainer = []
        else:
            self.layoutContainer = layoutContainer
        self.layoutContainer_nsprefix_ = None
        if imageControl is None:
            self.imageControl = []
        else:
            self.imageControl = imageControl
        self.imageControl_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_GroupBox)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_GroupBox.subclass:
            return CT_GroupBox.subclass(*args_, **kwargs_)
        else:
            return CT_GroupBox(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_button(self):
        return self.button
    def set_button(self, button):
        self.button = button
    def add_button(self, value):
        self.button.append(value)
    def insert_button_at(self, index, value):
        self.button.insert(index, value)
    def replace_button_at(self, index, value):
        self.button[index] = value
    def get_checkBox(self):
        return self.checkBox
    def set_checkBox(self, checkBox):
        self.checkBox = checkBox
    def add_checkBox(self, value):
        self.checkBox.append(value)
    def insert_checkBox_at(self, index, value):
        self.checkBox.insert(index, value)
    def replace_checkBox_at(self, index, value):
        self.checkBox[index] = value
    def get_editBox(self):
        return self.editBox
    def set_editBox(self, editBox):
        self.editBox = editBox
    def add_editBox(self, value):
        self.editBox.append(value)
    def insert_editBox_at(self, index, value):
        self.editBox.insert(index, value)
    def replace_editBox_at(self, index, value):
        self.editBox[index] = value
    def get_dropDown(self):
        return self.dropDown
    def set_dropDown(self, dropDown):
        self.dropDown = dropDown
    def add_dropDown(self, value):
        self.dropDown.append(value)
    def insert_dropDown_at(self, index, value):
        self.dropDown.insert(index, value)
    def replace_dropDown_at(self, index, value):
        self.dropDown[index] = value
    def get_radioGroup(self):
        return self.radioGroup
    def set_radioGroup(self, radioGroup):
        self.radioGroup = radioGroup
    def add_radioGroup(self, value):
        self.radioGroup.append(value)
    def insert_radioGroup_at(self, index, value):
        self.radioGroup.insert(index, value)
    def replace_radioGroup_at(self, index, value):
        self.radioGroup[index] = value
    def get_comboBox(self):
        return self.comboBox
    def set_comboBox(self, comboBox):
        self.comboBox = comboBox
    def add_comboBox(self, value):
        self.comboBox.append(value)
    def insert_comboBox_at(self, index, value):
        self.comboBox.insert(index, value)
    def replace_comboBox_at(self, index, value):
        self.comboBox[index] = value
    def get_hyperlink(self):
        return self.hyperlink
    def set_hyperlink(self, hyperlink):
        self.hyperlink = hyperlink
    def add_hyperlink(self, value):
        self.hyperlink.append(value)
    def insert_hyperlink_at(self, index, value):
        self.hyperlink.insert(index, value)
    def replace_hyperlink_at(self, index, value):
        self.hyperlink[index] = value
    def get_labelControl(self):
        return self.labelControl
    def set_labelControl(self, labelControl):
        self.labelControl = labelControl
    def add_labelControl(self, value):
        self.labelControl.append(value)
    def insert_labelControl_at(self, index, value):
        self.labelControl.insert(index, value)
    def replace_labelControl_at(self, index, value):
        self.labelControl[index] = value
    def get_groupBox(self):
        return self.groupBox
    def set_groupBox(self, groupBox):
        self.groupBox = groupBox
    def add_groupBox(self, value):
        self.groupBox.append(value)
    def insert_groupBox_at(self, index, value):
        self.groupBox.insert(index, value)
    def replace_groupBox_at(self, index, value):
        self.groupBox[index] = value
    def get_layoutContainer(self):
        return self.layoutContainer
    def set_layoutContainer(self, layoutContainer):
        self.layoutContainer = layoutContainer
    def add_layoutContainer(self, value):
        self.layoutContainer.append(value)
    def insert_layoutContainer_at(self, index, value):
        self.layoutContainer.insert(index, value)
    def replace_layoutContainer_at(self, index, value):
        self.layoutContainer[index] = value
    def get_imageControl(self):
        return self.imageControl
    def set_imageControl(self, imageControl):
        self.imageControl = imageControl
    def add_imageControl(self, value):
        self.imageControl.append(value)
    def insert_imageControl_at(self, index, value):
        self.imageControl.insert(index, value)
    def replace_imageControl_at(self, index, value):
        self.imageControl[index] = value
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_expand(self):
        return self.expand
    def set_expand(self, expand):
        self.expand = expand
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_getLabel(self):
        return self.getLabel
    def set_getLabel(self, getLabel):
        self.getLabel = getLabel
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.button or
            self.checkBox or
            self.editBox or
            self.dropDown or
            self.radioGroup or
            self.comboBox or
            self.hyperlink or
            self.labelControl or
            self.groupBox or
            self.layoutContainer or
            self.imageControl
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_GroupBox', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_GroupBox')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_GroupBox')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_GroupBox', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_GroupBox'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.expand is not None and 'expand' not in already_processed:
            already_processed.add('expand')
            outfile.write(' expand=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.expand), input_name='expand')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.getLabel is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            outfile.write(' getLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getLabel), input_name='getLabel')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_GroupBox', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for button_ in self.button:
            namespaceprefix_ = self.button_nsprefix_ + ':' if (UseCapturedNS_ and self.button_nsprefix_) else ''
            button_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='button', pretty_print=pretty_print)
        for checkBox_ in self.checkBox:
            namespaceprefix_ = self.checkBox_nsprefix_ + ':' if (UseCapturedNS_ and self.checkBox_nsprefix_) else ''
            checkBox_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='checkBox', pretty_print=pretty_print)
        for editBox_ in self.editBox:
            namespaceprefix_ = self.editBox_nsprefix_ + ':' if (UseCapturedNS_ and self.editBox_nsprefix_) else ''
            editBox_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='editBox', pretty_print=pretty_print)
        for dropDown_ in self.dropDown:
            namespaceprefix_ = self.dropDown_nsprefix_ + ':' if (UseCapturedNS_ and self.dropDown_nsprefix_) else ''
            dropDown_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dropDown', pretty_print=pretty_print)
        for radioGroup_ in self.radioGroup:
            namespaceprefix_ = self.radioGroup_nsprefix_ + ':' if (UseCapturedNS_ and self.radioGroup_nsprefix_) else ''
            radioGroup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='radioGroup', pretty_print=pretty_print)
        for comboBox_ in self.comboBox:
            namespaceprefix_ = self.comboBox_nsprefix_ + ':' if (UseCapturedNS_ and self.comboBox_nsprefix_) else ''
            comboBox_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='comboBox', pretty_print=pretty_print)
        for hyperlink_ in self.hyperlink:
            namespaceprefix_ = self.hyperlink_nsprefix_ + ':' if (UseCapturedNS_ and self.hyperlink_nsprefix_) else ''
            hyperlink_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='hyperlink', pretty_print=pretty_print)
        for labelControl_ in self.labelControl:
            namespaceprefix_ = self.labelControl_nsprefix_ + ':' if (UseCapturedNS_ and self.labelControl_nsprefix_) else ''
            labelControl_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='labelControl', pretty_print=pretty_print)
        for groupBox_ in self.groupBox:
            namespaceprefix_ = self.groupBox_nsprefix_ + ':' if (UseCapturedNS_ and self.groupBox_nsprefix_) else ''
            groupBox_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='groupBox', pretty_print=pretty_print)
        for layoutContainer_ in self.layoutContainer:
            namespaceprefix_ = self.layoutContainer_nsprefix_ + ':' if (UseCapturedNS_ and self.layoutContainer_nsprefix_) else ''
            layoutContainer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='layoutContainer', pretty_print=pretty_print)
        for imageControl_ in self.imageControl:
            namespaceprefix_ = self.imageControl_nsprefix_ + ':' if (UseCapturedNS_ and self.imageControl_nsprefix_) else ''
            imageControl_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='imageControl', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('expand', node)
        if value is not None and 'expand' not in already_processed:
            already_processed.add('expand')
            self.expand = value
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
            self.validate_ST_String(self.label)    # validate type ST_String
        value = find_attr_value_('getLabel', node)
        if value is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            self.getLabel = value
            self.validate_ST_Delegate(self.getLabel)    # validate type ST_Delegate
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'button':
            obj_ = CT_BackstageGroupButton.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.button.append(obj_)
            obj_.original_tagname_ = 'button'
        elif nodeName_ == 'checkBox':
            obj_ = CT_BackstageCheckBox.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.checkBox.append(obj_)
            obj_.original_tagname_ = 'checkBox'
        elif nodeName_ == 'editBox':
            obj_ = CT_BackstageEditBox.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.editBox.append(obj_)
            obj_.original_tagname_ = 'editBox'
        elif nodeName_ == 'dropDown':
            obj_ = CT_BackstageDropDown.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dropDown.append(obj_)
            obj_.original_tagname_ = 'dropDown'
        elif nodeName_ == 'radioGroup':
            obj_ = CT_RadioGroup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.radioGroup.append(obj_)
            obj_.original_tagname_ = 'radioGroup'
        elif nodeName_ == 'comboBox':
            obj_ = CT_BackstageComboBox.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.comboBox.append(obj_)
            obj_.original_tagname_ = 'comboBox'
        elif nodeName_ == 'hyperlink':
            obj_ = CT_Hyperlink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.hyperlink.append(obj_)
            obj_.original_tagname_ = 'hyperlink'
        elif nodeName_ == 'labelControl':
            obj_ = CT_BackstageLabelControl.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.labelControl.append(obj_)
            obj_.original_tagname_ = 'labelControl'
        elif nodeName_ == 'groupBox':
            obj_ = CT_GroupBox.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.groupBox.append(obj_)
            obj_.original_tagname_ = 'groupBox'
        elif nodeName_ == 'layoutContainer':
            obj_ = CT_LayoutContainer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.layoutContainer.append(obj_)
            obj_.original_tagname_ = 'layoutContainer'
        elif nodeName_ == 'imageControl':
            obj_ = CT_ImageControl.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.imageControl.append(obj_)
            obj_.original_tagname_ = 'imageControl'
# end class CT_GroupBox


class CT_LayoutContainer(GeneratedsSuper):
    """Specifies a layoutContainer.
    Specifies side of the layoutContainer where the children controls will be
    aligned.
    Specifies the directions in which the layoutContainer will expand to fill
    its parent container.
    Specifies the layout direction for the children controls."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, align=None, expand=None, layoutChildren=None, id=None, idQ=None, tag=None, button=None, checkBox=None, editBox=None, dropDown=None, radioGroup=None, comboBox=None, hyperlink=None, labelControl=None, groupBox=None, layoutContainer=None, imageControl=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.align = _cast(None, align)
        self.align_nsprefix_ = None
        self.expand = _cast(None, expand)
        self.expand_nsprefix_ = None
        self.layoutChildren = _cast(None, layoutChildren)
        self.layoutChildren_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        if button is None:
            self.button = []
        else:
            self.button = button
        self.button_nsprefix_ = None
        if checkBox is None:
            self.checkBox = []
        else:
            self.checkBox = checkBox
        self.checkBox_nsprefix_ = None
        if editBox is None:
            self.editBox = []
        else:
            self.editBox = editBox
        self.editBox_nsprefix_ = None
        if dropDown is None:
            self.dropDown = []
        else:
            self.dropDown = dropDown
        self.dropDown_nsprefix_ = None
        if radioGroup is None:
            self.radioGroup = []
        else:
            self.radioGroup = radioGroup
        self.radioGroup_nsprefix_ = None
        if comboBox is None:
            self.comboBox = []
        else:
            self.comboBox = comboBox
        self.comboBox_nsprefix_ = None
        if hyperlink is None:
            self.hyperlink = []
        else:
            self.hyperlink = hyperlink
        self.hyperlink_nsprefix_ = None
        if labelControl is None:
            self.labelControl = []
        else:
            self.labelControl = labelControl
        self.labelControl_nsprefix_ = None
        if groupBox is None:
            self.groupBox = []
        else:
            self.groupBox = groupBox
        self.groupBox_nsprefix_ = None
        if layoutContainer is None:
            self.layoutContainer = []
        else:
            self.layoutContainer = layoutContainer
        self.layoutContainer_nsprefix_ = None
        if imageControl is None:
            self.imageControl = []
        else:
            self.imageControl = imageControl
        self.imageControl_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_LayoutContainer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_LayoutContainer.subclass:
            return CT_LayoutContainer.subclass(*args_, **kwargs_)
        else:
            return CT_LayoutContainer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_button(self):
        return self.button
    def set_button(self, button):
        self.button = button
    def add_button(self, value):
        self.button.append(value)
    def insert_button_at(self, index, value):
        self.button.insert(index, value)
    def replace_button_at(self, index, value):
        self.button[index] = value
    def get_checkBox(self):
        return self.checkBox
    def set_checkBox(self, checkBox):
        self.checkBox = checkBox
    def add_checkBox(self, value):
        self.checkBox.append(value)
    def insert_checkBox_at(self, index, value):
        self.checkBox.insert(index, value)
    def replace_checkBox_at(self, index, value):
        self.checkBox[index] = value
    def get_editBox(self):
        return self.editBox
    def set_editBox(self, editBox):
        self.editBox = editBox
    def add_editBox(self, value):
        self.editBox.append(value)
    def insert_editBox_at(self, index, value):
        self.editBox.insert(index, value)
    def replace_editBox_at(self, index, value):
        self.editBox[index] = value
    def get_dropDown(self):
        return self.dropDown
    def set_dropDown(self, dropDown):
        self.dropDown = dropDown
    def add_dropDown(self, value):
        self.dropDown.append(value)
    def insert_dropDown_at(self, index, value):
        self.dropDown.insert(index, value)
    def replace_dropDown_at(self, index, value):
        self.dropDown[index] = value
    def get_radioGroup(self):
        return self.radioGroup
    def set_radioGroup(self, radioGroup):
        self.radioGroup = radioGroup
    def add_radioGroup(self, value):
        self.radioGroup.append(value)
    def insert_radioGroup_at(self, index, value):
        self.radioGroup.insert(index, value)
    def replace_radioGroup_at(self, index, value):
        self.radioGroup[index] = value
    def get_comboBox(self):
        return self.comboBox
    def set_comboBox(self, comboBox):
        self.comboBox = comboBox
    def add_comboBox(self, value):
        self.comboBox.append(value)
    def insert_comboBox_at(self, index, value):
        self.comboBox.insert(index, value)
    def replace_comboBox_at(self, index, value):
        self.comboBox[index] = value
    def get_hyperlink(self):
        return self.hyperlink
    def set_hyperlink(self, hyperlink):
        self.hyperlink = hyperlink
    def add_hyperlink(self, value):
        self.hyperlink.append(value)
    def insert_hyperlink_at(self, index, value):
        self.hyperlink.insert(index, value)
    def replace_hyperlink_at(self, index, value):
        self.hyperlink[index] = value
    def get_labelControl(self):
        return self.labelControl
    def set_labelControl(self, labelControl):
        self.labelControl = labelControl
    def add_labelControl(self, value):
        self.labelControl.append(value)
    def insert_labelControl_at(self, index, value):
        self.labelControl.insert(index, value)
    def replace_labelControl_at(self, index, value):
        self.labelControl[index] = value
    def get_groupBox(self):
        return self.groupBox
    def set_groupBox(self, groupBox):
        self.groupBox = groupBox
    def add_groupBox(self, value):
        self.groupBox.append(value)
    def insert_groupBox_at(self, index, value):
        self.groupBox.insert(index, value)
    def replace_groupBox_at(self, index, value):
        self.groupBox[index] = value
    def get_layoutContainer(self):
        return self.layoutContainer
    def set_layoutContainer(self, layoutContainer):
        self.layoutContainer = layoutContainer
    def add_layoutContainer(self, value):
        self.layoutContainer.append(value)
    def insert_layoutContainer_at(self, index, value):
        self.layoutContainer.insert(index, value)
    def replace_layoutContainer_at(self, index, value):
        self.layoutContainer[index] = value
    def get_imageControl(self):
        return self.imageControl
    def set_imageControl(self, imageControl):
        self.imageControl = imageControl
    def add_imageControl(self, value):
        self.imageControl.append(value)
    def insert_imageControl_at(self, index, value):
        self.imageControl.insert(index, value)
    def replace_imageControl_at(self, index, value):
        self.imageControl[index] = value
    def get_align(self):
        return self.align
    def set_align(self, align):
        self.align = align
    def get_expand(self):
        return self.expand
    def set_expand(self, expand):
        self.expand = expand
    def get_layoutChildren(self):
        return self.layoutChildren
    def set_layoutChildren(self, layoutChildren):
        self.layoutChildren = layoutChildren
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.button or
            self.checkBox or
            self.editBox or
            self.dropDown or
            self.radioGroup or
            self.comboBox or
            self.hyperlink or
            self.labelControl or
            self.groupBox or
            self.layoutContainer or
            self.imageControl
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_LayoutContainer', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_LayoutContainer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_LayoutContainer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_LayoutContainer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_LayoutContainer'):
        if self.align is not None and 'align' not in already_processed:
            already_processed.add('align')
            outfile.write(' align=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.align), input_name='align')), ))
        if self.expand is not None and 'expand' not in already_processed:
            already_processed.add('expand')
            outfile.write(' expand=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.expand), input_name='expand')), ))
        if self.layoutChildren is not None and 'layoutChildren' not in already_processed:
            already_processed.add('layoutChildren')
            outfile.write(' layoutChildren=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.layoutChildren), input_name='layoutChildren')), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_LayoutContainer', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for button_ in self.button:
            namespaceprefix_ = self.button_nsprefix_ + ':' if (UseCapturedNS_ and self.button_nsprefix_) else ''
            button_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='button', pretty_print=pretty_print)
        for checkBox_ in self.checkBox:
            namespaceprefix_ = self.checkBox_nsprefix_ + ':' if (UseCapturedNS_ and self.checkBox_nsprefix_) else ''
            checkBox_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='checkBox', pretty_print=pretty_print)
        for editBox_ in self.editBox:
            namespaceprefix_ = self.editBox_nsprefix_ + ':' if (UseCapturedNS_ and self.editBox_nsprefix_) else ''
            editBox_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='editBox', pretty_print=pretty_print)
        for dropDown_ in self.dropDown:
            namespaceprefix_ = self.dropDown_nsprefix_ + ':' if (UseCapturedNS_ and self.dropDown_nsprefix_) else ''
            dropDown_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dropDown', pretty_print=pretty_print)
        for radioGroup_ in self.radioGroup:
            namespaceprefix_ = self.radioGroup_nsprefix_ + ':' if (UseCapturedNS_ and self.radioGroup_nsprefix_) else ''
            radioGroup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='radioGroup', pretty_print=pretty_print)
        for comboBox_ in self.comboBox:
            namespaceprefix_ = self.comboBox_nsprefix_ + ':' if (UseCapturedNS_ and self.comboBox_nsprefix_) else ''
            comboBox_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='comboBox', pretty_print=pretty_print)
        for hyperlink_ in self.hyperlink:
            namespaceprefix_ = self.hyperlink_nsprefix_ + ':' if (UseCapturedNS_ and self.hyperlink_nsprefix_) else ''
            hyperlink_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='hyperlink', pretty_print=pretty_print)
        for labelControl_ in self.labelControl:
            namespaceprefix_ = self.labelControl_nsprefix_ + ':' if (UseCapturedNS_ and self.labelControl_nsprefix_) else ''
            labelControl_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='labelControl', pretty_print=pretty_print)
        for groupBox_ in self.groupBox:
            namespaceprefix_ = self.groupBox_nsprefix_ + ':' if (UseCapturedNS_ and self.groupBox_nsprefix_) else ''
            groupBox_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='groupBox', pretty_print=pretty_print)
        for layoutContainer_ in self.layoutContainer:
            namespaceprefix_ = self.layoutContainer_nsprefix_ + ':' if (UseCapturedNS_ and self.layoutContainer_nsprefix_) else ''
            layoutContainer_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='layoutContainer', pretty_print=pretty_print)
        for imageControl_ in self.imageControl:
            namespaceprefix_ = self.imageControl_nsprefix_ + ':' if (UseCapturedNS_ and self.imageControl_nsprefix_) else ''
            imageControl_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='imageControl', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('align', node)
        if value is not None and 'align' not in already_processed:
            already_processed.add('align')
            self.align = value
        value = find_attr_value_('expand', node)
        if value is not None and 'expand' not in already_processed:
            already_processed.add('expand')
            self.expand = value
        value = find_attr_value_('layoutChildren', node)
        if value is not None and 'layoutChildren' not in already_processed:
            already_processed.add('layoutChildren')
            self.layoutChildren = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'button':
            obj_ = CT_BackstageGroupButton.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.button.append(obj_)
            obj_.original_tagname_ = 'button'
        elif nodeName_ == 'checkBox':
            obj_ = CT_BackstageCheckBox.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.checkBox.append(obj_)
            obj_.original_tagname_ = 'checkBox'
        elif nodeName_ == 'editBox':
            obj_ = CT_BackstageEditBox.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.editBox.append(obj_)
            obj_.original_tagname_ = 'editBox'
        elif nodeName_ == 'dropDown':
            obj_ = CT_BackstageDropDown.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dropDown.append(obj_)
            obj_.original_tagname_ = 'dropDown'
        elif nodeName_ == 'radioGroup':
            obj_ = CT_RadioGroup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.radioGroup.append(obj_)
            obj_.original_tagname_ = 'radioGroup'
        elif nodeName_ == 'comboBox':
            obj_ = CT_BackstageComboBox.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.comboBox.append(obj_)
            obj_.original_tagname_ = 'comboBox'
        elif nodeName_ == 'hyperlink':
            obj_ = CT_Hyperlink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.hyperlink.append(obj_)
            obj_.original_tagname_ = 'hyperlink'
        elif nodeName_ == 'labelControl':
            obj_ = CT_BackstageLabelControl.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.labelControl.append(obj_)
            obj_.original_tagname_ = 'labelControl'
        elif nodeName_ == 'groupBox':
            obj_ = CT_GroupBox.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.groupBox.append(obj_)
            obj_.original_tagname_ = 'groupBox'
        elif nodeName_ == 'layoutContainer':
            obj_ = CT_LayoutContainer.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.layoutContainer.append(obj_)
            obj_.original_tagname_ = 'layoutContainer'
        elif nodeName_ == 'imageControl':
            obj_ = CT_ImageControl.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.imageControl.append(obj_)
            obj_.original_tagname_ = 'imageControl'
# end class CT_LayoutContainer


class CT_BackstageGroups(GeneratedsSuper):
    """Specifies a collection of groups, which is either one taskFormGroup or
    a set of simple groups."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, taskFormGroup=None, group=None, taskGroup=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.taskFormGroup = taskFormGroup
        self.taskFormGroup_nsprefix_ = None
        if group is None:
            self.group = []
        else:
            self.group = group
        self.group_nsprefix_ = None
        if taskGroup is None:
            self.taskGroup = []
        else:
            self.taskGroup = taskGroup
        self.taskGroup_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_BackstageGroups)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_BackstageGroups.subclass:
            return CT_BackstageGroups.subclass(*args_, **kwargs_)
        else:
            return CT_BackstageGroups(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_taskFormGroup(self):
        return self.taskFormGroup
    def set_taskFormGroup(self, taskFormGroup):
        self.taskFormGroup = taskFormGroup
    def get_group(self):
        return self.group
    def set_group(self, group):
        self.group = group
    def add_group(self, value):
        self.group.append(value)
    def insert_group_at(self, index, value):
        self.group.insert(index, value)
    def replace_group_at(self, index, value):
        self.group[index] = value
    def get_taskGroup(self):
        return self.taskGroup
    def set_taskGroup(self, taskGroup):
        self.taskGroup = taskGroup
    def add_taskGroup(self, value):
        self.taskGroup.append(value)
    def insert_taskGroup_at(self, index, value):
        self.taskGroup.insert(index, value)
    def replace_taskGroup_at(self, index, value):
        self.taskGroup[index] = value
    def hasContent_(self):
        if (
            self.taskFormGroup is not None or
            self.group or
            self.taskGroup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_BackstageGroups', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_BackstageGroups')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_BackstageGroups')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_BackstageGroups', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_BackstageGroups'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_BackstageGroups', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.taskFormGroup is not None:
            namespaceprefix_ = self.taskFormGroup_nsprefix_ + ':' if (UseCapturedNS_ and self.taskFormGroup_nsprefix_) else ''
            self.taskFormGroup.export(outfile, level, namespaceprefix_, namespacedef_='', name_='taskFormGroup', pretty_print=pretty_print)
        for group_ in self.group:
            namespaceprefix_ = self.group_nsprefix_ + ':' if (UseCapturedNS_ and self.group_nsprefix_) else ''
            group_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='group', pretty_print=pretty_print)
        for taskGroup_ in self.taskGroup:
            namespaceprefix_ = self.taskGroup_nsprefix_ + ':' if (UseCapturedNS_ and self.taskGroup_nsprefix_) else ''
            taskGroup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='taskGroup', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'taskFormGroup':
            obj_ = CT_TaskFormGroup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.taskFormGroup = obj_
            obj_.original_tagname_ = 'taskFormGroup'
        elif nodeName_ == 'group':
            obj_ = CT_BackstageGroup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.group.append(obj_)
            obj_.original_tagname_ = 'group'
        elif nodeName_ == 'taskGroup':
            obj_ = CT_TaskGroup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.taskGroup.append(obj_)
            obj_.original_tagname_ = 'taskGroup'
# end class CT_BackstageGroups


class CT_SimpleGroups(GeneratedsSuper):
    """Specifies a collection of simple groups."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, group=None, taskGroup=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        if group is None:
            self.group = []
        else:
            self.group = group
        self.group_nsprefix_ = None
        if taskGroup is None:
            self.taskGroup = []
        else:
            self.taskGroup = taskGroup
        self.taskGroup_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_SimpleGroups)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_SimpleGroups.subclass:
            return CT_SimpleGroups.subclass(*args_, **kwargs_)
        else:
            return CT_SimpleGroups(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_group(self):
        return self.group
    def set_group(self, group):
        self.group = group
    def add_group(self, value):
        self.group.append(value)
    def insert_group_at(self, index, value):
        self.group.insert(index, value)
    def replace_group_at(self, index, value):
        self.group[index] = value
    def get_taskGroup(self):
        return self.taskGroup
    def set_taskGroup(self, taskGroup):
        self.taskGroup = taskGroup
    def add_taskGroup(self, value):
        self.taskGroup.append(value)
    def insert_taskGroup_at(self, index, value):
        self.taskGroup.insert(index, value)
    def replace_taskGroup_at(self, index, value):
        self.taskGroup[index] = value
    def hasContent_(self):
        if (
            self.group or
            self.taskGroup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_SimpleGroups', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_SimpleGroups')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_SimpleGroups')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_SimpleGroups', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_SimpleGroups'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_SimpleGroups', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for group_ in self.group:
            namespaceprefix_ = self.group_nsprefix_ + ':' if (UseCapturedNS_ and self.group_nsprefix_) else ''
            group_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='group', pretty_print=pretty_print)
        for taskGroup_ in self.taskGroup:
            namespaceprefix_ = self.taskGroup_nsprefix_ + ':' if (UseCapturedNS_ and self.taskGroup_nsprefix_) else ''
            taskGroup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='taskGroup', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'group':
            obj_ = CT_BackstageGroup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.group.append(obj_)
            obj_.original_tagname_ = 'group'
        elif nodeName_ == 'taskGroup':
            obj_ = CT_TaskGroup.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.taskGroup.append(obj_)
            obj_.original_tagname_ = 'taskGroup'
# end class CT_SimpleGroups


class CT_BackstageTab(GeneratedsSuper):
    """Specifies a tab that contains a fastCommands section and group controls.
    Specifies the division of the tab's columns, as a percentage of the width
    of the entire tab.
    Specifies the minimum width of the tab's first column in pixels.
    Specifies the maximum width of the tab's first column in pixels.
    Specifies the minimum width of the tab's second column in pixels.
    Specifies the maximum width of the tab's second column in pixels."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, columnWidthPercent=None, firstColumnMinWidth=None, firstColumnMaxWidth=None, secondColumnMinWidth=None, secondColumnMaxWidth=None, id=None, idQ=None, tag=None, idMso=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, enabled=None, getEnabled=None, label=None, getLabel=None, visible=None, getVisible=None, keytip=None, getKeytip=None, title=None, getTitle=None, firstColumn=None, secondColumn=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.columnWidthPercent = _cast(int, columnWidthPercent)
        self.columnWidthPercent_nsprefix_ = None
        self.firstColumnMinWidth = _cast(int, firstColumnMinWidth)
        self.firstColumnMinWidth_nsprefix_ = None
        self.firstColumnMaxWidth = _cast(int, firstColumnMaxWidth)
        self.firstColumnMaxWidth_nsprefix_ = None
        self.secondColumnMinWidth = _cast(int, secondColumnMinWidth)
        self.secondColumnMinWidth_nsprefix_ = None
        self.secondColumnMaxWidth = _cast(int, secondColumnMaxWidth)
        self.secondColumnMaxWidth_nsprefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.idQ = _cast(None, idQ)
        self.idQ_nsprefix_ = None
        self.tag = _cast(None, tag)
        self.tag_nsprefix_ = None
        self.idMso = _cast(None, idMso)
        self.idMso_nsprefix_ = None
        self.insertAfterMso = _cast(None, insertAfterMso)
        self.insertAfterMso_nsprefix_ = None
        self.insertBeforeMso = _cast(None, insertBeforeMso)
        self.insertBeforeMso_nsprefix_ = None
        self.insertAfterQ = _cast(None, insertAfterQ)
        self.insertAfterQ_nsprefix_ = None
        self.insertBeforeQ = _cast(None, insertBeforeQ)
        self.insertBeforeQ_nsprefix_ = None
        self.enabled = _cast(bool, enabled)
        self.enabled_nsprefix_ = None
        self.getEnabled = _cast(None, getEnabled)
        self.getEnabled_nsprefix_ = None
        self.label = _cast(None, label)
        self.label_nsprefix_ = None
        self.getLabel = _cast(None, getLabel)
        self.getLabel_nsprefix_ = None
        self.visible = _cast(bool, visible)
        self.visible_nsprefix_ = None
        self.getVisible = _cast(None, getVisible)
        self.getVisible_nsprefix_ = None
        self.keytip = _cast(None, keytip)
        self.keytip_nsprefix_ = None
        self.getKeytip = _cast(None, getKeytip)
        self.getKeytip_nsprefix_ = None
        self.title = _cast(None, title)
        self.title_nsprefix_ = None
        self.getTitle = _cast(None, getTitle)
        self.getTitle_nsprefix_ = None
        self.firstColumn = firstColumn
        self.firstColumn_nsprefix_ = None
        self.secondColumn = secondColumn
        self.secondColumn_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_BackstageTab)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_BackstageTab.subclass:
            return CT_BackstageTab.subclass(*args_, **kwargs_)
        else:
            return CT_BackstageTab(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_firstColumn(self):
        return self.firstColumn
    def set_firstColumn(self, firstColumn):
        self.firstColumn = firstColumn
    def get_secondColumn(self):
        return self.secondColumn
    def set_secondColumn(self, secondColumn):
        self.secondColumn = secondColumn
    def get_columnWidthPercent(self):
        return self.columnWidthPercent
    def set_columnWidthPercent(self, columnWidthPercent):
        self.columnWidthPercent = columnWidthPercent
    def get_firstColumnMinWidth(self):
        return self.firstColumnMinWidth
    def set_firstColumnMinWidth(self, firstColumnMinWidth):
        self.firstColumnMinWidth = firstColumnMinWidth
    def get_firstColumnMaxWidth(self):
        return self.firstColumnMaxWidth
    def set_firstColumnMaxWidth(self, firstColumnMaxWidth):
        self.firstColumnMaxWidth = firstColumnMaxWidth
    def get_secondColumnMinWidth(self):
        return self.secondColumnMinWidth
    def set_secondColumnMinWidth(self, secondColumnMinWidth):
        self.secondColumnMinWidth = secondColumnMinWidth
    def get_secondColumnMaxWidth(self):
        return self.secondColumnMaxWidth
    def set_secondColumnMaxWidth(self, secondColumnMaxWidth):
        self.secondColumnMaxWidth = secondColumnMaxWidth
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_idQ(self):
        return self.idQ
    def set_idQ(self, idQ):
        self.idQ = idQ
    def get_tag(self):
        return self.tag
    def set_tag(self, tag):
        self.tag = tag
    def get_idMso(self):
        return self.idMso
    def set_idMso(self, idMso):
        self.idMso = idMso
    def get_insertAfterMso(self):
        return self.insertAfterMso
    def set_insertAfterMso(self, insertAfterMso):
        self.insertAfterMso = insertAfterMso
    def get_insertBeforeMso(self):
        return self.insertBeforeMso
    def set_insertBeforeMso(self, insertBeforeMso):
        self.insertBeforeMso = insertBeforeMso
    def get_insertAfterQ(self):
        return self.insertAfterQ
    def set_insertAfterQ(self, insertAfterQ):
        self.insertAfterQ = insertAfterQ
    def get_insertBeforeQ(self):
        return self.insertBeforeQ
    def set_insertBeforeQ(self, insertBeforeQ):
        self.insertBeforeQ = insertBeforeQ
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    def get_getEnabled(self):
        return self.getEnabled
    def set_getEnabled(self, getEnabled):
        self.getEnabled = getEnabled
    def get_label(self):
        return self.label
    def set_label(self, label):
        self.label = label
    def get_getLabel(self):
        return self.getLabel
    def set_getLabel(self, getLabel):
        self.getLabel = getLabel
    def get_visible(self):
        return self.visible
    def set_visible(self, visible):
        self.visible = visible
    def get_getVisible(self):
        return self.getVisible
    def set_getVisible(self, getVisible):
        self.getVisible = getVisible
    def get_keytip(self):
        return self.keytip
    def set_keytip(self, keytip):
        self.keytip = keytip
    def get_getKeytip(self):
        return self.getKeytip
    def set_getKeytip(self, getKeytip):
        self.getKeytip = getKeytip
    def get_title(self):
        return self.title
    def set_title(self, title):
        self.title = title
    def get_getTitle(self):
        return self.getTitle
    def set_getTitle(self, getTitle):
        self.getTitle = getTitle
    def validate_ST_UniqueID(self, value):
        # Validate type ST_UniqueID, a restriction on xsd:ID.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_UniqueID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_UniqueID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_QID(self, value):
        # Validate type ST_QID, a restriction on xsd:QName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_QID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_QID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_String(self, value):
        # Validate type ST_String, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_String' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_ID(self, value):
        # Validate type ST_ID, a restriction on xsd:NCName.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_ID' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_ID' % {"value" : value, "lineno": lineno} )
                result = False
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def validate_ST_Keytip(self, value):
        # Validate type ST_Keytip, a restriction on xsd:token.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 3:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Keytip' % {"value": value, "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Keytip' % {"value" : value, "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.firstColumn is not None or
            self.secondColumn is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_BackstageTab', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_BackstageTab')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_BackstageTab')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_BackstageTab', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_BackstageTab'):
        if self.columnWidthPercent is not None and 'columnWidthPercent' not in already_processed:
            already_processed.add('columnWidthPercent')
            outfile.write(' columnWidthPercent="%s"' % self.gds_format_integer(self.columnWidthPercent, input_name='columnWidthPercent'))
        if self.firstColumnMinWidth is not None and 'firstColumnMinWidth' not in already_processed:
            already_processed.add('firstColumnMinWidth')
            outfile.write(' firstColumnMinWidth="%s"' % self.gds_format_integer(self.firstColumnMinWidth, input_name='firstColumnMinWidth'))
        if self.firstColumnMaxWidth is not None and 'firstColumnMaxWidth' not in already_processed:
            already_processed.add('firstColumnMaxWidth')
            outfile.write(' firstColumnMaxWidth="%s"' % self.gds_format_integer(self.firstColumnMaxWidth, input_name='firstColumnMaxWidth'))
        if self.secondColumnMinWidth is not None and 'secondColumnMinWidth' not in already_processed:
            already_processed.add('secondColumnMinWidth')
            outfile.write(' secondColumnMinWidth="%s"' % self.gds_format_integer(self.secondColumnMinWidth, input_name='secondColumnMinWidth'))
        if self.secondColumnMaxWidth is not None and 'secondColumnMaxWidth' not in already_processed:
            already_processed.add('secondColumnMaxWidth')
            outfile.write(' secondColumnMaxWidth="%s"' % self.gds_format_integer(self.secondColumnMaxWidth, input_name='secondColumnMaxWidth'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.idQ is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            outfile.write(' idQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idQ), input_name='idQ')), ))
        if self.tag is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            outfile.write(' tag=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.tag), input_name='tag')), ))
        if self.idMso is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            outfile.write(' idMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.idMso), input_name='idMso')), ))
        if self.insertAfterMso is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            outfile.write(' insertAfterMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterMso), input_name='insertAfterMso')), ))
        if self.insertBeforeMso is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            outfile.write(' insertBeforeMso=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeMso), input_name='insertBeforeMso')), ))
        if self.insertAfterQ is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            outfile.write(' insertAfterQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertAfterQ), input_name='insertAfterQ')), ))
        if self.insertBeforeQ is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            outfile.write(' insertBeforeQ=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.insertBeforeQ), input_name='insertBeforeQ')), ))
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            outfile.write(' enabled="%s"' % self.gds_format_boolean(self.enabled, input_name='enabled'))
        if self.getEnabled is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            outfile.write(' getEnabled=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getEnabled), input_name='getEnabled')), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.label), input_name='label')), ))
        if self.getLabel is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            outfile.write(' getLabel=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getLabel), input_name='getLabel')), ))
        if self.visible is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            outfile.write(' visible="%s"' % self.gds_format_boolean(self.visible, input_name='visible'))
        if self.getVisible is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            outfile.write(' getVisible=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getVisible), input_name='getVisible')), ))
        if self.keytip is not None and 'keytip' not in already_processed:
            already_processed.add('keytip')
            outfile.write(' keytip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.keytip), input_name='keytip')), ))
        if self.getKeytip is not None and 'getKeytip' not in already_processed:
            already_processed.add('getKeytip')
            outfile.write(' getKeytip=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getKeytip), input_name='getKeytip')), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.add('title')
            outfile.write(' title=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.title), input_name='title')), ))
        if self.getTitle is not None and 'getTitle' not in already_processed:
            already_processed.add('getTitle')
            outfile.write(' getTitle=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.getTitle), input_name='getTitle')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_BackstageTab', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.firstColumn is not None:
            namespaceprefix_ = self.firstColumn_nsprefix_ + ':' if (UseCapturedNS_ and self.firstColumn_nsprefix_) else ''
            self.firstColumn.export(outfile, level, namespaceprefix_, namespacedef_='', name_='firstColumn', pretty_print=pretty_print)
        if self.secondColumn is not None:
            namespaceprefix_ = self.secondColumn_nsprefix_ + ':' if (UseCapturedNS_ and self.secondColumn_nsprefix_) else ''
            self.secondColumn.export(outfile, level, namespaceprefix_, namespacedef_='', name_='secondColumn', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('columnWidthPercent', node)
        if value is not None and 'columnWidthPercent' not in already_processed:
            already_processed.add('columnWidthPercent')
            self.columnWidthPercent = self.gds_parse_integer(value, node, 'columnWidthPercent')
            if self.columnWidthPercent <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('firstColumnMinWidth', node)
        if value is not None and 'firstColumnMinWidth' not in already_processed:
            already_processed.add('firstColumnMinWidth')
            self.firstColumnMinWidth = self.gds_parse_integer(value, node, 'firstColumnMinWidth')
            if self.firstColumnMinWidth <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('firstColumnMaxWidth', node)
        if value is not None and 'firstColumnMaxWidth' not in already_processed:
            already_processed.add('firstColumnMaxWidth')
            self.firstColumnMaxWidth = self.gds_parse_integer(value, node, 'firstColumnMaxWidth')
            if self.firstColumnMaxWidth <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('secondColumnMinWidth', node)
        if value is not None and 'secondColumnMinWidth' not in already_processed:
            already_processed.add('secondColumnMinWidth')
            self.secondColumnMinWidth = self.gds_parse_integer(value, node, 'secondColumnMinWidth')
            if self.secondColumnMinWidth <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('secondColumnMaxWidth', node)
        if value is not None and 'secondColumnMaxWidth' not in already_processed:
            already_processed.add('secondColumnMaxWidth')
            self.secondColumnMaxWidth = self.gds_parse_integer(value, node, 'secondColumnMaxWidth')
            if self.secondColumnMaxWidth <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_ST_UniqueID(self.id)    # validate type ST_UniqueID
        value = find_attr_value_('idQ', node)
        if value is not None and 'idQ' not in already_processed:
            already_processed.add('idQ')
            self.idQ = value
            self.validate_ST_QID(self.idQ)    # validate type ST_QID
        value = find_attr_value_('tag', node)
        if value is not None and 'tag' not in already_processed:
            already_processed.add('tag')
            self.tag = value
            self.validate_ST_String(self.tag)    # validate type ST_String
        value = find_attr_value_('idMso', node)
        if value is not None and 'idMso' not in already_processed:
            already_processed.add('idMso')
            self.idMso = value
            self.validate_ST_ID(self.idMso)    # validate type ST_ID
        value = find_attr_value_('insertAfterMso', node)
        if value is not None and 'insertAfterMso' not in already_processed:
            already_processed.add('insertAfterMso')
            self.insertAfterMso = value
            self.validate_ST_ID(self.insertAfterMso)    # validate type ST_ID
        value = find_attr_value_('insertBeforeMso', node)
        if value is not None and 'insertBeforeMso' not in already_processed:
            already_processed.add('insertBeforeMso')
            self.insertBeforeMso = value
            self.validate_ST_ID(self.insertBeforeMso)    # validate type ST_ID
        value = find_attr_value_('insertAfterQ', node)
        if value is not None and 'insertAfterQ' not in already_processed:
            already_processed.add('insertAfterQ')
            self.insertAfterQ = value
            self.validate_ST_QID(self.insertAfterQ)    # validate type ST_QID
        value = find_attr_value_('insertBeforeQ', node)
        if value is not None and 'insertBeforeQ' not in already_processed:
            already_processed.add('insertBeforeQ')
            self.insertBeforeQ = value
            self.validate_ST_QID(self.insertBeforeQ)    # validate type ST_QID
        value = find_attr_value_('enabled', node)
        if value is not None and 'enabled' not in already_processed:
            already_processed.add('enabled')
            if value in ('true', '1'):
                self.enabled = True
            elif value in ('false', '0'):
                self.enabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getEnabled', node)
        if value is not None and 'getEnabled' not in already_processed:
            already_processed.add('getEnabled')
            self.getEnabled = value
            self.validate_ST_Delegate(self.getEnabled)    # validate type ST_Delegate
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
            self.validate_ST_String(self.label)    # validate type ST_String
        value = find_attr_value_('getLabel', node)
        if value is not None and 'getLabel' not in already_processed:
            already_processed.add('getLabel')
            self.getLabel = value
            self.validate_ST_Delegate(self.getLabel)    # validate type ST_Delegate
        value = find_attr_value_('visible', node)
        if value is not None and 'visible' not in already_processed:
            already_processed.add('visible')
            if value in ('true', '1'):
                self.visible = True
            elif value in ('false', '0'):
                self.visible = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('getVisible', node)
        if value is not None and 'getVisible' not in already_processed:
            already_processed.add('getVisible')
            self.getVisible = value
            self.validate_ST_Delegate(self.getVisible)    # validate type ST_Delegate
        value = find_attr_value_('keytip', node)
        if value is not None and 'keytip' not in already_processed:
            already_processed.add('keytip')
            self.keytip = value
            self.keytip = ' '.join(self.keytip.split())
            self.validate_ST_Keytip(self.keytip)    # validate type ST_Keytip
        value = find_attr_value_('getKeytip', node)
        if value is not None and 'getKeytip' not in already_processed:
            already_processed.add('getKeytip')
            self.getKeytip = value
            self.validate_ST_Delegate(self.getKeytip)    # validate type ST_Delegate
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.add('title')
            self.title = value
            self.validate_ST_String(self.title)    # validate type ST_String
        value = find_attr_value_('getTitle', node)
        if value is not None and 'getTitle' not in already_processed:
            already_processed.add('getTitle')
            self.getTitle = value
            self.validate_ST_Delegate(self.getTitle)    # validate type ST_Delegate
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'firstColumn':
            obj_ = CT_BackstageGroups.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.firstColumn = obj_
            obj_.original_tagname_ = 'firstColumn'
        elif nodeName_ == 'secondColumn':
            obj_ = CT_SimpleGroups.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.secondColumn = obj_
            obj_.original_tagname_ = 'secondColumn'
# end class CT_BackstageTab


class CT_Backstage(GeneratedsSuper):
    """Specifies the Backstage tag
    Specifies a callback which is invoked when a Backstage is opened.
    Specifies a callback which is invoked when a Backstage is closed."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, onShow=None, onHide=None, tab=None, button=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.onShow = _cast(None, onShow)
        self.onShow_nsprefix_ = None
        self.onHide = _cast(None, onHide)
        self.onHide_nsprefix_ = None
        if tab is None:
            self.tab = []
        else:
            self.tab = tab
        self.tab_nsprefix_ = None
        if button is None:
            self.button = []
        else:
            self.button = button
        self.button_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_Backstage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_Backstage.subclass:
            return CT_Backstage.subclass(*args_, **kwargs_)
        else:
            return CT_Backstage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_tab(self):
        return self.tab
    def set_tab(self, tab):
        self.tab = tab
    def add_tab(self, value):
        self.tab.append(value)
    def insert_tab_at(self, index, value):
        self.tab.insert(index, value)
    def replace_tab_at(self, index, value):
        self.tab[index] = value
    def get_button(self):
        return self.button
    def set_button(self, button):
        self.button = button
    def add_button(self, value):
        self.button.append(value)
    def insert_button_at(self, index, value):
        self.button.insert(index, value)
    def replace_button_at(self, index, value):
        self.button[index] = value
    def get_onShow(self):
        return self.onShow
    def set_onShow(self, onShow):
        self.onShow = onShow
    def get_onHide(self):
        return self.onHide
    def set_onHide(self, onHide):
        self.onHide = onHide
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.tab or
            self.button
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_Backstage', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_Backstage')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_Backstage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_Backstage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_Backstage'):
        if self.onShow is not None and 'onShow' not in already_processed:
            already_processed.add('onShow')
            outfile.write(' onShow=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.onShow), input_name='onShow')), ))
        if self.onHide is not None and 'onHide' not in already_processed:
            already_processed.add('onHide')
            outfile.write(' onHide=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.onHide), input_name='onHide')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_Backstage', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for tab_ in self.tab:
            namespaceprefix_ = self.tab_nsprefix_ + ':' if (UseCapturedNS_ and self.tab_nsprefix_) else ''
            tab_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tab', pretty_print=pretty_print)
        for button_ in self.button:
            namespaceprefix_ = self.button_nsprefix_ + ':' if (UseCapturedNS_ and self.button_nsprefix_) else ''
            button_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='button', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('onShow', node)
        if value is not None and 'onShow' not in already_processed:
            already_processed.add('onShow')
            self.onShow = value
            self.validate_ST_Delegate(self.onShow)    # validate type ST_Delegate
        value = find_attr_value_('onHide', node)
        if value is not None and 'onHide' not in already_processed:
            already_processed.add('onHide')
            self.onHide = value
            self.validate_ST_Delegate(self.onHide)    # validate type ST_Delegate
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'tab':
            obj_ = CT_BackstageTab.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tab.append(obj_)
            obj_.original_tagname_ = 'tab'
        elif nodeName_ == 'button':
            obj_ = CT_BackstageFastCommandButton.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.button.append(obj_)
            obj_.original_tagname_ = 'button'
# end class CT_Backstage


class CT_CustomUI(GeneratedsSuper):
    """Specifies the root element of the customization file which is used to
    create or modify the Ribbon.
    Specifies a callback which is invoked when custom UI is loaded.
    IRibbonUI object is passed as a parameter.
    Specifies a callback which is invoked to load custom images."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, onLoad=None, loadImage=None, commands=None, ribbon=None, backstage=None, contextMenus=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.onLoad = _cast(None, onLoad)
        self.onLoad_nsprefix_ = None
        self.loadImage = _cast(None, loadImage)
        self.loadImage_nsprefix_ = None
        self.commands = commands
        self.commands_nsprefix_ = None
        self.ribbon = ribbon
        self.ribbon_nsprefix_ = None
        self.backstage = backstage
        self.backstage_nsprefix_ = None
        self.contextMenus = contextMenus
        self.contextMenus_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_CustomUI)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_CustomUI.subclass:
            return CT_CustomUI.subclass(*args_, **kwargs_)
        else:
            return CT_CustomUI(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_commands(self):
        return self.commands
    def set_commands(self, commands):
        self.commands = commands
    def get_ribbon(self):
        return self.ribbon
    def set_ribbon(self, ribbon):
        self.ribbon = ribbon
    def get_backstage(self):
        return self.backstage
    def set_backstage(self, backstage):
        self.backstage = backstage
    def get_contextMenus(self):
        return self.contextMenus
    def set_contextMenus(self, contextMenus):
        self.contextMenus = contextMenus
    def get_onLoad(self):
        return self.onLoad
    def set_onLoad(self, onLoad):
        self.onLoad = onLoad
    def get_loadImage(self):
        return self.loadImage
    def set_loadImage(self, loadImage):
        self.loadImage = loadImage
    def validate_ST_Delegate(self, value):
        # Validate type ST_Delegate, a restriction on xsd:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 1024:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
            if len(value) < 1:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minLength restriction on ST_Delegate' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
    def hasContent_(self):
        if (
            self.commands is not None or
            self.ribbon is not None or
            self.backstage is not None or
            self.contextMenus is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_CustomUI', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_CustomUI')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_CustomUI')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_CustomUI', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_CustomUI'):
        if self.onLoad is not None and 'onLoad' not in already_processed:
            already_processed.add('onLoad')
            outfile.write(' onLoad=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.onLoad), input_name='onLoad')), ))
        if self.loadImage is not None and 'loadImage' not in already_processed:
            already_processed.add('loadImage')
            outfile.write(' loadImage=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.loadImage), input_name='loadImage')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui" ', name_='CT_CustomUI', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.commands is not None:
            namespaceprefix_ = self.commands_nsprefix_ + ':' if (UseCapturedNS_ and self.commands_nsprefix_) else ''
            self.commands.export(outfile, level, namespaceprefix_, namespacedef_='', name_='commands', pretty_print=pretty_print)
        if self.ribbon is not None:
            namespaceprefix_ = self.ribbon_nsprefix_ + ':' if (UseCapturedNS_ and self.ribbon_nsprefix_) else ''
            self.ribbon.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ribbon', pretty_print=pretty_print)
        if self.backstage is not None:
            namespaceprefix_ = self.backstage_nsprefix_ + ':' if (UseCapturedNS_ and self.backstage_nsprefix_) else ''
            self.backstage.export(outfile, level, namespaceprefix_, namespacedef_='', name_='backstage', pretty_print=pretty_print)
        if self.contextMenus is not None:
            namespaceprefix_ = self.contextMenus_nsprefix_ + ':' if (UseCapturedNS_ and self.contextMenus_nsprefix_) else ''
            self.contextMenus.export(outfile, level, namespaceprefix_, namespacedef_='', name_='contextMenus', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('onLoad', node)
        if value is not None and 'onLoad' not in already_processed:
            already_processed.add('onLoad')
            self.onLoad = value
            self.validate_ST_Delegate(self.onLoad)    # validate type ST_Delegate
        value = find_attr_value_('loadImage', node)
        if value is not None and 'loadImage' not in already_processed:
            already_processed.add('loadImage')
            self.loadImage = value
            self.validate_ST_Delegate(self.loadImage)    # validate type ST_Delegate
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'commands':
            obj_ = CT_Commands.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.commands = obj_
            obj_.original_tagname_ = 'commands'
        elif nodeName_ == 'ribbon':
            obj_ = CT_Ribbon.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ribbon = obj_
            obj_.original_tagname_ = 'ribbon'
        elif nodeName_ == 'backstage':
            obj_ = CT_Backstage.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.backstage = obj_
            obj_.original_tagname_ = 'backstage'
        elif nodeName_ == 'contextMenus':
            obj_ = CT_ContextMenus.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.contextMenus = obj_
            obj_.original_tagname_ = 'contextMenus'
# end class CT_CustomUI


class CT_ControlClone(CT_Button):
    """Specifies a clone of built-in control that can be sized.
    Custom controls can't be cloned by id.
    The onAction property does not apply to 'control'."""
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = CT_Button
    def __init__(self, image=None, imageMso=None, getImage=None, screentip=None, getScreentip=None, supertip=None, getSupertip=None, enabled=None, getEnabled=None, label=None, getLabel=None, insertAfterMso=None, insertBeforeMso=None, insertAfterQ=None, insertBeforeQ=None, visible=None, getVisible=None, keytip=None, getKeytip=None, showLabel=None, getShowLabel=None, showImage=None, getShowImage=None, id=None, idQ=None, tag=None, idMso=None, onAction=None, description=None, getDescription=None, size=None, getSize=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(CT_ControlClone, self).__init__(image, imageMso, getImage, screentip, getScreentip, supertip, getSupertip, enabled, getEnabled, label, getLabel, insertAfterMso, insertBeforeMso, insertAfterQ, insertBeforeQ, visible, getVisible, keytip, getKeytip, showLabel, getShowLabel, showImage, getShowImage, id, idQ, tag, idMso, onAction, description, getDescription, size, getSize,  **kwargs_)
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.onAction = _cast(None, onAction)
        self.onAction_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CT_ControlClone)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CT_ControlClone.subclass:
            return CT_ControlClone.subclass(*args_, **kwargs_)
        else:
            return CT_ControlClone(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_id(self):
        return self.id
    def set_id(self, id):
        self.id = id
    def get_onAction(self):
        return self.onAction
    def set_onAction(self, onAction):
        self.onAction = onAction
    def hasContent_(self):
        if (
            super(CT_ControlClone, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_ControlClone', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CT_ControlClone')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_ControlClone')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CT_ControlClone', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CT_ControlClone'):
        super(CT_ControlClone, self).exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CT_ControlClone')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.onAction is not None and 'onAction' not in already_processed:
            already_processed.add('onAction')
            outfile.write(' onAction=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.onAction), input_name='onAction')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CT_ControlClone', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('onAction', node)
        if value is not None and 'onAction' not in already_processed:
            already_processed.add('onAction')
            self.onAction = value
        super(CT_ControlClone, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CT_ControlClone


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'CT_CustomUI'
        rootClass = customUI
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'CT_CustomUI'
        rootClass = customUI
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'CT_CustomUI'
        rootClass = customUI
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'CT_CustomUI'
        rootClass = customUI
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from customUI14base import *\n\n')
        sys.stdout.write('import customUI14base as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

__all__ = [
    "CT_Backstage",
    "CT_BackstageButtonBase",
    "CT_BackstageCheckBox",
    "CT_BackstageCheckBoxBase",
    "CT_BackstageComboBox",
    "CT_BackstageDropDown",
    "CT_BackstageEditBox",
    "CT_BackstageFastCommandButton",
    "CT_BackstageGroup",
    "CT_BackstageGroupButton",
    "CT_BackstageGroups",
    "CT_BackstageItem",
    "CT_BackstageLabelControl",
    "CT_BackstageMenuBase",
    "CT_BackstageMenuButton",
    "CT_BackstageMenuCheckBox",
    "CT_BackstageMenuGroup",
    "CT_BackstageMenuToggleButton",
    "CT_BackstagePrimaryMenu",
    "CT_BackstageRegularButton",
    "CT_BackstageSubMenu",
    "CT_BackstageTab",
    "CT_Box",
    "CT_Button",
    "CT_ButtonGroup",
    "CT_ButtonRegular",
    "CT_CheckBox",
    "CT_ComboBox",
    "CT_Command",
    "CT_Commands",
    "CT_ContextMenu",
    "CT_ContextMenus",
    "CT_ContextualTabs",
    "CT_Control",
    "CT_ControlBase",
    "CT_ControlClone",
    "CT_ControlCloneQat",
    "CT_ControlCloneRegular",
    "CT_CustomUI",
    "CT_DialogLauncher",
    "CT_DropDownRegular",
    "CT_DynamicMenu",
    "CT_DynamicMenuRegular",
    "CT_EditBox",
    "CT_Gallery",
    "CT_GalleryRegular",
    "CT_Group",
    "CT_GroupBox",
    "CT_GroupControls",
    "CT_HeaderGroup",
    "CT_Hyperlink",
    "CT_ImageControl",
    "CT_Item",
    "CT_LabelControl",
    "CT_LayoutContainer",
    "CT_Menu",
    "CT_MenuRegular",
    "CT_MenuRoot",
    "CT_MenuSeparator",
    "CT_MenuSeparatorNoTitle",
    "CT_MenuWithTitle",
    "CT_PrimaryItem",
    "CT_Qat",
    "CT_QatItems",
    "CT_RadioGroup",
    "CT_Ribbon",
    "CT_Separator",
    "CT_SimpleGroups",
    "CT_SplitButton",
    "CT_SplitButtonBase",
    "CT_SplitButtonRegular",
    "CT_SplitButtonRestricted",
    "CT_SplitButtonWithTitle",
    "CT_Tab",
    "CT_TabSet",
    "CT_Tabs",
    "CT_TaskFormGroup",
    "CT_TaskFormGroupCategory",
    "CT_TaskFormGroupTask",
    "CT_TaskGroup",
    "CT_TaskGroupCategory",
    "CT_TaskGroupTask",
    "CT_ToggleButton",
    "CT_ToggleButtonRegular",
    "CT_VisibleButton",
    "CT_VisibleToggleButton"
]

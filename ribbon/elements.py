import random
import re

from ribbon import customUI14base

TAB_TYPES = {
    'normal': None,
    'chart': 'TabSetChartTools',
}

class BaseRootElement(object):
    """Defines common properties to extend autogenerated classes."""
    name = None
    id = None

    def __setattr__(self, name, value):
        if name == 'id' and value is not None:
            value = sanitize_id(value)
        super().__setattr__(name, value)

    def __init__(self, *args, **kwargs):
        if kwargs.get('id', None) is None and kwargs.get('label', None) is not None:
            kwargs['id'] = sanitize_id(kwargs['label'])
        super(BaseRootElement, self).__init__(*args, **kwargs)
        self.children = []

    def export(self, *args, **kwargs):
        kwargs.update({
            'name_': self.name,
        })
        super(BaseRootElement, self).export(*args, **kwargs)

    def exportAttributes(self, *args, **kwargs):
        kwargs.update({
            'name_': self.name,
        })
        super(BaseRootElement, self).exportAttributes(*args, **kwargs)


class BaseNodeElement(BaseRootElement):
    """Defines common properties to extend autogenerated classes other than Root()."""

    def exportChildren(self, outfile, level, namespaceprefix_='',
        namespacedef_=' xmlns:None="http://schemas.microsoft.com/office/2009/07/customui"', name_="",
        fromsubclass_=False, pretty_print=True):

        for child in self.children:
            child.export(outfile=outfile, level=level, namespaceprefix_=namespaceprefix_,
            namespacedef_=namespacedef_, name_=name_, pretty_print=pretty_print)

class Root(BaseRootElement, customUI14base.CT_CustomUI):
    """Defines the root-level customUI tag for customUI14.xml"""

    name = 'customUI'

    def __init__(self, onLoad=None, loadImage=None, commands=None, ribbon=None,
        backstage=None, contextMenus=None, **kwargs):
        super(Root, self).__init__(onLoad, loadImage, commands, ribbon,
            backstage, contextMenus, **kwargs)
        self.ns_prefix_ = ""
    
    def export(self, *args, **kwargs):
        kwargs.update({
            'namespacedef_': 'xmlns="http://schemas.microsoft.com/office/2009/07/customui"',
        })
        super(Root, self).export(*args, **kwargs)


class Ribbon(BaseNodeElement, customUI14base.CT_Ribbon):
    """
    This class extends the base CT_Ribbon with abstractions for the addition
    of its various children such as tabs, groups and their elements. Most of the
    time, you'll want to use this class and its helper methods in lieu of the
    specific element classes defined below such as Group, Tab and Button.

    Rather than using .export() as ordinarily defined in customUI14base.py, you may
    instead prefer to use .build_ribbon() which will also create the root <customUI>
    tag.

    Sample usage:

    >>> r = Ribbon()
    >>> r.create_tab(id='MyTab', label='My Tab')
    >>> r.create_tab(label='My Chart Tab', type='Chart') # generated id is 'MyChartTab'
    >>> # the following line references an inexistent group, which is inferred
    >>> # and automatically created in the MyTab tab for simplicity 
    >>> r.add_button(id='Foo', label='Foo button', group='My Group', tab='MyTab')
    >>> r.add_button(id='Bar', label='Bar button', group='My Group', tab='MyTab')
    >>> r.add_button(id='Baz', label='Chart button', group='Chart Group', tab='ChartTab')
    >>> r.build_ribbon()

    Output:
    # TODO: paste output here based on results from tests.py
    """

    name = 'ribbon'
    root = None

    def build_ribbon(self, *args, **kwargs):
        kwargs.update({'level': kwargs.get('level', 0)})
        if kwargs.get('with_root', True):
            if self.root is None:
                self.root = Root()
                self.root.ribbon = self
            self.root.export(*args, **kwargs)
        else:
            super(Ribbon, self).export(*args, **kwargs)

    def build_callbacks(self, *args, **kwargs):
        """Generates a VBA module with all callbacks from each child element."""
        raise NotImplementedError

    def get_or_create_tabs(self, **kwargs):
        if self.tabs is None:
            tabs_object = Tabs(**kwargs)
            self.children.append(tabs_object)
            self.tabs = tabs_object
        return self.tabs

    def get_or_create_contextualTabs(self, **kwargs):
        if self.contextualTabs is None:
            contextualTabs_object = ContextualTabs(**kwargs)
            self.children.append(contextualTabs_object)
            self.contextualTabs = contextualTabs_object
        return self.contextualTabs

    # The methods below expose children / grandchildren of the Ribbon element directly
    # for easier access, while also abstracting away idiosyncrasies of the customUI schema
    def get_or_create_tab(self, id=None, label=None, tab_type='normal', **kwargs):
        id = sanitize_id(id)
        try:
            return self.get_tab(id, tab_type)
        except IndexError:
            return self.create_tab(id, label, tab_type, **kwargs)

    def create_tab(self, id=None, label=None, tab_type='normal', **kwargs):
        if label is None and id is None:
            raise ValueError(f'Either label or id must be provided.')
        if id is None:
            id = label
        id = sanitize_id(id)

        if tab_type == 'normal':
            tab_object = self.get_or_create_tabs().create_tab(id, **kwargs)

        else:
            tab_object = self.get_or_create_contextualTabs(). \
                get_or_create_tabSet(TAB_TYPES[tab_type]). \
                create_tab(id, **kwargs)

        return tab_object

    def add_tab(self, tab_object, tab_type='normal', **kwargs):
        if tab_type == 'normal':
            tab_object = self.get_or_create_tabs().add_tab(tab_object, **kwargs)

        else:
            tab_object = self.get_or_create_contextualTabs().get_or_create_tabSet(
                TAB_TYPES[tab_type]).add_tab(tab_object, **kwargs)

        return tab_object

    def get_tab(self, id, tab_type='normal'):
        if tab_type == 'normal':
            tab_object = self.get_or_create_tabs().get_tab(id)

        else:
            tab_object = self.get_or_create_contextualTabs(). \
                get_or_create_tabSet(TAB_TYPES[tab_type]). \
                get_tab(id)

        return tab_object
    
    def get_or_create_group(self, id=None, label=None, tab=None, tab_type='normal', tab_kwargs={}, **kwargs):
        if tab is None:
            raise ValueError(f'Specify which tab the group should be placed in.')
        if label is None and id is None:
            raise ValueError(f'Either label or id must be provided.')
        if id is None:
            id = label
        id = sanitize_id(id)

        return self.get_or_create_tab(id=tab, tab_type=tab_type, **tab_kwargs). \
            get_or_create_group(id=id, label=label, **kwargs)

    def create_group(self, id=None, label=None, tab=None, tab_type='normal', tab_kwargs={}, **kwargs):
        if tab is None:
            raise ValueError(f'Specify which tab the group should be placed in.')
        if label is None and id is None:
            raise ValueError(f'Either label or id must be provided.')
        if id is None:
            id = label
        id = sanitize_id(id)

        return self.get_or_create_tab(id=tab, tab_type=tab_type, **tab_kwargs). \
            create_group(id=id, label=label, **kwargs)

    def add_group(self, group_object, tab, tab_type='normal', tab_kwargs={}, **kwargs):
        return self.get_or_create_tab(tab, tab_type, **tab_kwargs). \
            add_group(group_object, **kwargs)

    def get_or_create_button(self, id=None, label=None, tab=None, tab_type='normal', tab_kwargs={}, 
        group=None, group_kwargs={}, **kwargs):
        if tab is None:
            raise ValueError(f'Specify which tab the button should be placed in.')
        if group is None:
            raise ValueError(f'Specify which group the button should be placed in.')
        if label is None and id is None:
            raise ValueError(f'Either label or id must be provided.')
        if id is None:
            id = label
        id = sanitize_id(id)

        return self.get_or_create_tab(id=tab, tab_type=tab_type, **tab_kwargs). \
            get_or_create_group(id=group, **group_kwargs).get_or_create_button(id=id, label=label, **kwargs)

    def create_button(self, id=None, label=None, tab=None, tab_type='normal', tab_kwargs={},
        group=None, group_kwargs={}, **kwargs):
        if tab is None:
            raise ValueError(f'Specify which tab the button should be placed in.')
        if group is None and ( #TODO: Do we want this?
            group_kwargs is none or
            (group_kwargs.get('id', None) is group_kwargs.get('label', None) is None)):
            raise ValueError(f'Specify which group the button should be placed in.')
        if label is None and id is None:
            raise ValueError(f'Either label or id must be provided.')
        if id is None:
            id = label
        id = sanitize_id(id)

        return self.get_or_create_tab(id=tab, tab_type=tab_type, **tab_kwargs). \
            get_or_create_group(id=group, **group_kwargs).create_button(id=id, label=label, **kwargs)

    def add_button(self, button_object, tab=None, tab_type='normal', tab_kwargs={},
        group=None, group_kwargs={}, **kwargs):
        return self.get_or_create_tab(id=tab, tab_type=tab_type, **tab_kwargs). \
            get_or_create_group(id=group, **group_kwargs).add_button(button_object, **kwargs)

    def create_separator(self, id=None, label=None, tab=None, tab_type='normal', tab_kwargs={},
        group=None, group_kwargs={}, **kwargs):
        if tab is None:
            raise ValueError(f'Specify which tab the separator should be placed in.')
        if group is None:
            raise ValueError(f'Specify which group the separator should be placed in.')

        return self.get_or_create_tab(id=tab, tab_type=tab_type, **tab_kwargs). \
            get_or_create_group(id=group, **group_kwargs).create_separator(id=id, label=label, **kwargs)

    def add_separator(self, separator_object, tab=None, tab_type='normal', tab_kwargs={},
        group=None, group_kwargs={}, **kwargs):
        return self.get_or_create_tab(id=tab, tab_type=tab_type, **tab_kwargs). \
            get_or_create_group(id=group, **group_kwargs).add_separator(separator_object, **kwargs)


class ContextualTabs(BaseNodeElement, customUI14base.CT_ContextualTabs):
    name = 'contextualTabs'

    def get_or_create_tabSet(self, idMso, **kwargs):
        try:
            return self.get_tabSet(idMso)
        except IndexError:
            return self.create_tabSet(idMso, **kwargs)

    def create_tabSet(self, idMso, **kwargs):
        idMso = sanitize_id(idMso)

        tabSet_object = TabSet(idMso=idMso, **kwargs)
        return self.add_tabSet(tabSet_object)
    
    def add_tabSet(self, tabSet_object, **kwargs):
        for _ in self.tabSet:
            if _.idMso == tabSet_object.idMso:
                raise ValueError(f'TabSet with idMso "{_.idMso} already exists."')
        
        self.children.append(tabSet_object)
        super(ContextualTabs, self).add_tabSet(tabSet_object)
        return tabSet_object
    
    def get_tabSet(self, idMso):
        for tabSet in self.tabSet:
            if tabSet.idMso == idMso:
                return tabSet
                
        raise IndexError(f'TabSet with idMso "{idMso}" does not exist')


class Tabs(BaseNodeElement, customUI14base.CT_Tabs):
    name = 'tabs'

    def get_or_create_tab(self, id=None, label=None, **kwargs):
        id = sanitize_id(id)
        try:
            return self.get_tab(id)
        except IndexError:
            return self.create_tab(id, label, **kwargs)

    def create_tab(self, id=None, label=None, **kwargs):
        if label is None and id is None:
            raise ValueError(f'Either label or id must be provided.')
        if id is None:
            id = label
        id = sanitize_id(id)

        tab_object = Tab(id=id, **kwargs)
        return self.add_tab(tab_object)

    def add_tab(self, tab_object, **kwargs):
        for _ in self.tab:
            if _.id == tab_object.id:
                raise ValueError(f'Tab with id "{_.id}" already exists')

        self.children.append(tab_object)
        super(Tabs, self).add_tab(tab_object)
        return tab_object

    def get_tab(self, id):
        for tab in self.tab:
            if tab.id == id:
                return tab

        raise IndexError(f'Tab with id "{id}" does not exist')


class TabSet(BaseNodeElement, customUI14base.CT_TabSet):
    name = 'tabSet'

    def get_or_create_tab(self, id=None, label=None, **kwargs):
        id = sanitize_id(id)
        try:
            return self.get_tab(id)
        except IndexError:
            return self.create_tab(id, label, **kwargs)

    def create_tab(self, id=None, label=None, **kwargs):
        if label is None and id is None:
            raise ValueError(f'Either label or id must be provided.')
        if id is None:
            id = label
        id = sanitize_id(id)

        tab_object = Tab(id=id, **kwargs)
        return self.add_tab(tab_object)

    def add_tab(self, tab_object, **kwargs):
        for _ in self.tab:
            if _.id == tab_object.id:
                raise ValueError(f'Tab with id "{_.id}" already exists')

        self.children.append(tab_object)
        super(TabSet, self).add_tab(tab_object)
        return tab_object

    def get_tab(self, id):
        for tab in self.tab:
            if tab.id == id:
                return tab

        raise IndexError(f'Tab with id "{id}" does not exist')


class Tab(BaseRootElement, customUI14base.CT_Tab):
    name = 'tab'

    def get_or_create_group(self, id, **kwargs):
        id = sanitize_id(id)
        try:
            return self.get_group(id)
        except IndexError:
            return self.create_group(id, **kwargs)

    def create_group(self, id=None, label=None, **kwargs):
        if label is None and id is None:
            raise ValueError(f'Either label or id must be provided.')
        if id is None:
            id = label
        id = sanitize_id(id)

        group_object = Group(id=id, **kwargs)
        return self.add_group(group_object)

    def add_group(self, group_object, **kwargs):
        for _ in self.group:
            if _.id == group_object.id:
                raise ValueError(f'Group with id "{_.id}" already exists in Tab.{self.id}')

        self.children.append(group_object)
        super(Tab, self).add_group(group_object)
        return group_object

    def get_group(self, id):
        for _ in self.group:
            if _.id == id:
                return _

        raise IndexError(f'Group with id "{id}" does not exist in Tab.{self.id}')


class Group(BaseNodeElement, customUI14base.CT_Group):
    name = 'group'

    def get_or_create_button(self, id, **kwargs):
        id = sanitize_id(id)
        try:
            return self.get_button(id)
        except IndexError:
            return self.create_button(id, **kwargs)

    def create_button(self, id, **kwargs):
        strict = kwargs.pop('force', False)
        retry = kwargs.pop('retry', 10)

        for _ in self.button:
            if _.id == id:
                if strict or retry == 0:
                    raise ValueError(f'Button with id "{_.id}" already exists in Group.{self.id}')
                else:
                    r = random.getrandbits(32)
                    id = sanitize_id(f'{id}{r}')
                    kwargs.update({'retry': retry - 1, 'strict': False})
                    return self.create_button(id, **kwargs)

        button_object = ButtonRegular(id=id, **kwargs)
        return self.add_button(button_object)

    def add_button(self, button_object, **kwargs):
        for _ in self.button:
            if _.id == button_object.id:
                raise ValueError(f'Button with id "{_.id}" already exists in Group.{self.id}')

        self.children.append(button_object)
        super(Group, self).add_button(button_object)
        return button_object

    def get_button(self, id, **kwargs):
        for _ in self.button:
            if _.id == id:
                return _

        raise IndexError(f'Button with id "{id}" does not exist in Group.{self.id}')

    def create_separator(self, id=None, **kwargs):
        if id is None:
            r = random.getrandbits(64)
            id = sanitize_id(f'{r}')

        separator = Separator(id=id, **kwargs)
        return self.add_separator(separator)

    def add_separator(self, separator_object, **kwargs):
        for _ in self.separator:
            if _.id == separator_object.id:
                raise ValueError(f'Separator with id "{_.id}" already exists in Group.{self.id}')

        self.children.append(separator_object)
        super(Group, self).add_separator(separator_object)
        return separator_object

    def get_separator(self, id, **kwargs):
        for _ in self.separator:
            if _.id == id:
                return _

        raise IndexError(f'Separator with id "{id}" does not exist in Group.{self.id}')


class ButtonRegular(BaseNodeElement, customUI14base.CT_ButtonRegular):
    name = 'button'
    template_callback = """
    Sub call{fun}(control as IRibbonControl)
        Call {fun}
    End Sub
    """


class Separator(BaseNodeElement, customUI14base.CT_Separator):
    name = 'separator'


def sanitize_id(text: str) -> str:
    pattern = re.compile('[\W_]+', re.UNICODE)
    return pattern.sub('', text)


def expand_kwargs(kwargs: dict, into: dict) -> dict:
    for (key, value) in kwargs.items:
        if '__' in key:
            (k, v) = key.split('__')
            into.update({k: v})

    return into

